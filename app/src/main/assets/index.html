<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="theme-color" content="#0d0d0d">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Расписание">
<title>Расписание колледжа</title>
<link href="https://fonts.googleapis.com/css2?family=Geologica:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
<style>
:root{
  --bg:#0d0d0d;--surface:#161616;--surface2:#1f1f1f;--surface3:#2a2a2a;
  --accent:#e87722;--accent2:#c45f0a;--text:#f0ede8;--muted:#6b6762;
  --success:#4a9e5c;--danger:#c94f4f;--r:16px;--rb:10px;
  --safe-top:env(safe-area-inset-top,0px);--safe-bot:env(safe-area-inset-bottom,0px);
}
*{box-sizing:border-box;margin:0;padding:0;-webkit-tap-highlight-color:transparent}
html,body{height:100%;background:var(--bg);color:var(--text);font-family:'Geologica',sans-serif;overflow:hidden}

.screen{
  position:absolute;inset:0;display:flex;flex-direction:column;
  padding-top:var(--safe-top);padding-bottom:calc(var(--safe-bot) + 58px);overflow:hidden;
  opacity:0;pointer-events:none;transform:translateY(18px) translateZ(0);
  transition:opacity .2s cubic-bezier(.4,0,.2,1),transform .2s cubic-bezier(.4,0,.2,1);
  will-change:opacity,transform;backface-visibility:hidden;-webkit-backface-visibility:hidden
}
.screen.active{opacity:1;pointer-events:all;transform:none}
.screen.exit-left{opacity:0;transform:translateX(-28px) translateZ(0);transition:opacity .15s ease-in,transform .15s ease-in}
.screen.exit-right{opacity:0;transform:translateX(28px) translateZ(0);transition:opacity .15s ease-in,transform .15s ease-in}
/* В glass-режиме убираем compositing layer с домашнего экрана,
   чтобы backdrop-filter на hero-card видел настоящий фон */
body.glass-mode #s-home.active{
  will-change:auto!important;
  transform:none!important;
  backface-visibility:visible!important;
  -webkit-backface-visibility:visible!important;
}

.body{flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch;padding:16px 18px}
.body::-webkit-scrollbar{display:none}
*::-webkit-scrollbar{display:none!important;width:0!important;height:0!important}
*{scrollbar-width:none!important}

.hdr{
  padding:14px 18px 12px;display:flex;align-items:center;gap:12px;
  border-bottom:1px solid rgba(255,255,255,.06);flex-shrink:0;
  background:var(--surface)
}
.hdr-back{
  background:var(--surface2);border:none;color:var(--accent);
  width:36px;height:36px;border-radius:50%;cursor:pointer;font-size:20px;
  display:flex;align-items:center;justify-content:center;
  position:relative;overflow:hidden;flex-shrink:0
}
.hdr-title{font-size:16px;font-weight:700;flex:1;letter-spacing:-.01em}
.hdr-sub{font-size:11px;color:var(--muted);margin-top:2px;font-weight:400}

.home-hero{
  padding:44px 20px 28px;text-align:center;position:relative
}
.home-hero::before{
  content:'';position:absolute;top:0;left:50%;transform:translateX(-50%);
  width:240px;height:240px;border-radius:50%;
  background:radial-gradient(circle,color-mix(in srgb,var(--accent) 12%,transparent) 0%,transparent 70%);
  pointer-events:none
}
/* ── Плашка "Колледж Расписание" ── */
.hero-card{
  display:inline-block;
  padding:18px 32px 16px;
  border-radius:24px;
  background:var(--surface2);
  border:1.5px solid var(--surface3);
  box-shadow:0 4px 32px rgba(0,0,0,0.32),
             inset 0 1px 0 rgba(255,255,255,0.07);
  position:relative;
  z-index:1;
}
.hero-title{font-size:38px;font-weight:800;color:var(--accent);letter-spacing:-.03em;line-height:1.1;
  text-shadow:0 0 20px color-mix(in srgb,var(--accent) 55%,transparent),
              0 0 60px color-mix(in srgb,var(--accent) 22%,transparent),
              0 0 120px color-mix(in srgb,var(--accent) 10%,transparent)}
/* glass-mode: плашка становится настоящим frosted glass */
body.glass-mode .hero-card{
  background:rgba(255,255,255,0.07);
  backdrop-filter:blur(20px) saturate(180%) brightness(1.05);
  -webkit-backdrop-filter:blur(20px) saturate(180%) brightness(1.05);
  border:1.5px solid rgba(255,255,255,0.22);
  box-shadow:0 8px 40px rgba(0,0,0,0.28),
             inset 0 1.5px 0 rgba(255,255,255,0.40),
             inset 0 -1px 0 rgba(255,255,255,0.08);
}
/* При кастомном фоне — hero card тоже использует pre-blur (Telegram-style) */
body.custom-bg-active .hero-card{
  background-image: var(--pre-blurred-bg, none) !important;
  background-size: cover !important;
  background-position: center center !important;
  background-attachment: fixed !important;
  background-color: rgba(0,0,0,0.38) !important;
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;
  border:1.5px solid rgba(255,255,255,0.18);
  box-shadow:0 8px 40px rgba(0,0,0,0.30),
             inset 0 1.5px 0 rgba(255,255,255,0.38),
             inset 0 -1px 0 rgba(255,255,255,0.08);
}
/* Fallback пока blur не готов */
body.custom-bg-active:not(.preblur-ready) .hero-card{
  background-image: none !important;
  background-color: rgba(0,0,0,0.45) !important;
  backdrop-filter: blur(16px) saturate(160%) !important;
  -webkit-backdrop-filter: blur(16px) saturate(160%) !important;
}

.section-label{font-size:10px;font-weight:700;color:var(--muted);letter-spacing:.15em;text-transform:uppercase;margin-bottom:8px;margin-top:2px}

.inp{
  width:100%;background:var(--surface2);border:1.5px solid var(--surface3);
  border-radius:var(--rb);color:var(--text);font-family:inherit;
  font-size:14px;padding:13px 14px;outline:none;
  transition:border-color .18s,box-shadow .18s
}
.inp:focus{border-color:var(--accent);box-shadow:0 0 0 3px color-mix(in srgb,var(--accent) 18%,transparent)}
.inp::placeholder{color:var(--muted)}

.btn{
  width:100%;border:none;border-radius:var(--rb);font-family:inherit;
  font-size:14px;font-weight:700;padding:15px;cursor:pointer;
  display:flex;align-items:center;justify-content:center;gap:8px;
  position:relative;overflow:hidden;letter-spacing:.01em;
  transition:transform .12s,box-shadow .12s
}
.btn:active{transform:scale(.97)}
.btn-accent{background:var(--accent);color:#fff;box-shadow:0 4px 20px color-mix(in srgb,var(--accent) 35%,transparent)}
.btn-accent:active{box-shadow:0 2px 8px color-mix(in srgb,var(--accent) 22%,transparent)}
.btn-accent2{background:var(--accent2);color:#fff;box-shadow:0 4px 20px color-mix(in srgb,var(--accent2) 30%,transparent)}
.btn-surface{background:var(--surface2);color:var(--text)}
.btn-surface3{background:var(--surface3);color:var(--accent)}
.btn-success{background:var(--success);color:#fff;box-shadow:0 4px 16px rgba(74,158,92,.25)}
.btn-danger{background:var(--danger);color:#fff;box-shadow:0 4px 16px rgba(201,79,79,.25)}

.ripple{
  position:absolute;border-radius:50%;
  background:rgba(255,255,255,.2);
  transform:scale(0);animation:ripple-anim .55s ease-out forwards;
  pointer-events:none
}
@keyframes ripple-anim{to{transform:scale(4);opacity:0}}
[data-theme="bw"] .btn-accent,[data-theme="bw"] .btn-accent2,
[data-theme="win11"] .btn-accent,[data-theme="win11"] .btn-accent2,
[data-theme="amoled"] .btn-accent,[data-theme="amoled"] .btn-accent2,
[data-theme="pixel"] .btn-accent,[data-theme="pixel"] .btn-accent2,
[data-theme="aero"] .btn-accent,[data-theme="aero"] .btn-accent2{color:#000}

.status{font-size:12px;color:var(--muted);text-align:center;min-height:18px;line-height:18px}
.progress{height:2px;background:var(--surface3);border-radius:1px;overflow:hidden;margin:6px 0}
.progress-bar{height:100%;background:var(--accent);width:0;border-radius:1px;transition:width .35s cubic-bezier(.4,0,.2,1)}
.sep{height:1px;background:rgba(255,255,255,.06);margin:14px 0}

.list{display:flex;flex-direction:column;gap:7px}
.list-item{
  background:var(--surface2);border-radius:var(--rb);padding:14px 16px;
  cursor:pointer;display:flex;align-items:center;justify-content:space-between;
  font-size:14px;position:relative;overflow:hidden;
  border:1.5px solid transparent;
  transition:border-color .15s,background .15s
}
.list-item:active{background:var(--surface3)}
.list-item.selected{
  background:color-mix(in srgb,var(--accent) 15%,transparent);
  border-color:color-mix(in srgb,var(--accent) 70%,transparent);
  box-shadow:0 0 0 1px color-mix(in srgb,var(--accent) 40%,transparent),
             0 0 18px color-mix(in srgb,var(--accent) 45%,transparent),
             0 0 50px color-mix(in srgb,var(--accent) 20%,transparent)
}
.list-item.selected .item-name{
  color:var(--accent);
  text-shadow:0 0 8px color-mix(in srgb,var(--accent) 90%,transparent),
              0 0 20px color-mix(in srgb,var(--accent) 60%,transparent),
              0 0 50px color-mix(in srgb,var(--accent) 30%,transparent)
}
.list-item .item-name{font-weight:600;flex:1;line-height:1.3}
.list-item .item-sub{font-size:11px;color:var(--muted);margin-top:2px;font-weight:400}
.list-item .item-arrow{color:var(--muted);font-size:18px;margin-left:8px;flex-shrink:0}

.search-wrap{position:relative}
.search-wrap .inp{padding-left:40px}
.search-icon{position:absolute;left:13px;top:50%;transform:translateY(-50%);color:var(--muted);font-size:15px;pointer-events:none}

.sched-header{
  padding:16px 18px 14px;background:var(--surface);
  border-bottom:1px solid rgba(255,255,255,.06);flex-shrink:0
}
.sched-group{font-size:24px;font-weight:800;color:var(--accent);letter-spacing:-.02em}
.sched-date{font-size:11px;color:var(--muted);margin-top:3px}

.pair-card{
  background:var(--surface2);border-radius:var(--r);
  margin-bottom:9px;overflow:hidden;
  border:1.5px solid var(--surface3);
  border-left:3px solid var(--surface3)
}
.pair-card.has-subject{border-left-color:var(--accent2)}
.pair-card.is-now{border-left-color:var(--accent);background:color-mix(in srgb,var(--accent) 10%,transparent);border-color:color-mix(in srgb,var(--accent) 30%,transparent)}
.pair-card.is-next{border-left-color:var(--success)}

.pair-top{display:flex;align-items:flex-start;padding:13px 14px 8px;gap:10px}
.pair-num{font-family:'JetBrains Mono',monospace;font-size:11px;font-weight:600;color:var(--muted);min-width:26px;text-transform:uppercase;padding-top:2px;flex-shrink:0}
.pair-subject-wrap{flex:1;min-width:0;display:flex;flex-direction:column;gap:5px}
.pair-subject{font-size:14px;font-weight:700;line-height:1.35;word-break:break-word;letter-spacing:-.01em}
.pair-subject.empty{color:var(--muted);font-weight:400;font-style:italic}
.pair-remain{font-size:11px;color:var(--muted);flex-shrink:0;padding-top:3px;font-family:'JetBrains Mono',monospace;white-space:nowrap}

.now-badge{
  display:inline-flex;align-items:center;gap:4px;
  background:var(--accent);color:#fff;
  font-size:10px;font-weight:700;padding:2px 8px;border-radius:20px;
  letter-spacing:.04em;text-transform:uppercase;align-self:flex-start
}
.next-badge{background:var(--success)}

.pair-times{padding:0 14px 12px 50px;display:flex;flex-direction:column;gap:5px}
.pair-time-row{display:flex;align-items:center;gap:8px}
.pair-time-val{font-family:'JetBrains Mono',monospace;font-size:13px;font-weight:600;color:var(--text)}
.pair-time-tag{font-size:9px;font-weight:700;color:var(--muted);background:var(--surface3);padding:2px 6px;border-radius:4px;letter-spacing:.08em;text-transform:uppercase}
.pair-details{padding:0 14px 12px 50px;font-size:12.5px;color:var(--muted);line-height:1.55}

.last-group-btn{
  background:var(--surface2);border:1.5px solid var(--surface3);border-radius:var(--rb);
  color:var(--accent);font-family:inherit;font-size:14px;font-weight:700;
  padding:15px;width:100%;cursor:pointer;text-align:center;
  position:relative;overflow:hidden;
  transition:transform .12s,border-color .15s
}
.last-group-btn:active{transform:scale(.97)}

/* Спиннер загрузки */
@keyframes spin{to{transform:rotate(360deg)}}
.loading-spinner{
  display:inline-block;width:16px;height:16px;
  border:2.5px solid rgba(255,255,255,.25);
  border-top-color:currentColor;border-radius:50%;
  animation:spin .7s linear infinite;vertical-align:middle;
  margin-right:8px;flex-shrink:0
}
.last-group-btn.loading{opacity:.75;pointer-events:none}
.last-group-btn .btn-label{display:inline}
/* Анимация скачивания в sched-body */
.sched-loading{
  display:flex;flex-direction:column;align-items:center;
  justify-content:center;padding:64px 20px;gap:18px
}
.sched-loading-circle{
  width:48px;height:48px;
  border:3.5px solid var(--surface3);
  border-top-color:var(--accent);border-radius:50%;
  animation:spin .8s linear infinite
}
.sched-loading-dots{display:flex;gap:6px;align-items:center}
.sched-loading-dot{
  width:6px;height:6px;border-radius:50%;background:var(--accent);
  animation:dotPulse 1.2s ease-in-out infinite;
}
.sched-loading-dot:nth-child(2){animation-delay:.2s}
.sched-loading-dot:nth-child(3){animation-delay:.4s}
@keyframes dotPulse{0%,80%,100%{opacity:.25;transform:scale(.8)}40%{opacity:1;transform:scale(1)}}

.toast{
  position:fixed;bottom:calc(24px + var(--safe-bot));
  left:50%;transform:translateX(-50%) translateY(80px);
  background:var(--surface3);color:var(--text);font-size:13px;font-weight:500;
  padding:10px 20px;border-radius:100px;white-space:nowrap;
  border:1px solid rgba(255,255,255,.08);box-shadow:0 8px 32px rgba(0,0,0,.4);
  transition:transform .3s cubic-bezier(.34,1.56,.64,1),opacity .3s;
  opacity:0;z-index:999;max-width:88vw;overflow:hidden;text-overflow:ellipsis
}
.toast.show{transform:translateX(-50%) translateY(0);opacity:1}

.bell-day{font-size:10px;font-weight:700;color:var(--accent);letter-spacing:.15em;text-transform:uppercase;margin:18px 0 8px}
.bell-card{background:var(--surface2);border-radius:var(--rb);padding:13px;margin-bottom:7px;display:flex;align-items:flex-start;gap:14px;border:1.5px solid var(--surface3)}
.bell-num{font-family:'JetBrains Mono',monospace;font-size:12px;color:var(--muted);min-width:26px;padding-top:2px}
.bell-slots{display:flex;flex-direction:column;gap:7px;flex:1}
.bell-slot{display:flex;align-items:center;gap:10px}
.bell-slot-time{font-family:'JetBrains Mono',monospace;font-size:13px;font-weight:600;color:var(--text)}
.bell-slot-tag{font-size:9px;font-weight:700;color:var(--muted);background:var(--surface3);padding:2px 6px;border-radius:4px;letter-spacing:.08em;text-transform:uppercase}

.bottom-nav{
  position:fixed;bottom:0;left:0;right:0;z-index:200;
  display:flex;
  border-top:1px solid rgba(255,255,255,.06);
  padding-bottom:var(--safe-bot);
  background:var(--surface);
  transition:background 0.3s ease, backdrop-filter 0.3s ease;
}
.nav-item{
  flex:1;display:flex;flex-direction:column;align-items:center;
  padding:10px 0;cursor:pointer;color:var(--muted);
  transition:color .18s;font-size:10px;font-weight:600;gap:3px;
  background:none;border:none;font-family:inherit;
  position:relative;overflow:hidden;letter-spacing:.02em
}
.nav-item .nav-icon{font-size:20px;transition:transform .2s cubic-bezier(.34,1.56,.64,1)}
.nav-item.active{color:var(--accent)}
.nav-item.active .nav-icon{transform:scale(1.15)}

.toggle-switch{width:44px;height:26px;border-radius:100px;background:var(--surface3);position:relative;cursor:pointer;transition:background .2s;flex-shrink:0}
.toggle-switch.on{background:var(--accent)}
.toggle-switch::after{content:'';position:absolute;width:18px;height:18px;border-radius:50%;background:#fff;top:3px;left:3px;transition:left .2s;box-shadow:0 1px 4px rgba(0,0,0,.3)}
.toggle-switch.on::after{left:21px}
.settings-row{display:flex;align-items:center;justify-content:space-between;padding:14px 16px;background:var(--surface2);border-radius:var(--rb);margin-bottom:8px;font-size:14px;font-weight:500;border:1.5px solid var(--surface3)}
.settings-row-sub{font-size:11px;color:var(--muted);margin-top:2px}

.theme-grid{display:flex;flex-direction:column;gap:7px;margin-top:8px}
.theme-card{background:var(--surface2);border-radius:var(--rb);padding:13px 16px;cursor:pointer;display:flex;align-items:center;gap:12px;border:1.5px solid var(--surface3);position:relative;overflow:hidden;transition:border-color .15s,background .15s}
.theme-card:active{background:var(--surface3)}
.theme-card.selected{background:color-mix(in srgb,var(--accent) 12%,transparent);border-color:color-mix(in srgb,var(--accent) 70%,transparent)}
.theme-card.selected .theme-name{color:var(--accent)}
.theme-swatch{display:flex;gap:5px;flex-shrink:0}
.swatch{width:14px;height:14px;border-radius:50%}
.theme-check{font-size:16px;flex-shrink:0;opacity:0;transition:opacity .15s;color:var(--accent)}
.theme-card.selected .theme-check{opacity:1}
.icon-picker{display:flex;gap:12px;padding:4px 0}
.icon-btn{background:none;border:none;padding:0;cursor:pointer;display:flex;flex-direction:column;align-items:center;gap:6px;position:relative;outline:none}
.icon-preview{display:block;width:56px;height:56px;border-radius:14px;overflow:hidden;box-sizing:border-box;transition:transform .15s,box-shadow .15s}
.icon-btn.selected .icon-preview{box-shadow:0 0 0 2.5px var(--accent);transform:scale(1.08)}
.icon-btn:active .icon-preview{transform:scale(0.95)}
.icon-label{font-size:10px;color:var(--muted);font-weight:600;letter-spacing:.03em}
.icon-btn.selected .icon-label{color:var(--accent)}
.icon-check{position:absolute;top:-4px;right:-4px;background:var(--accent);color:#fff;font-size:9px;width:16px;height:16px;border-radius:50%;display:flex;align-items:center;justify-content:center;opacity:0;transition:opacity .15s;font-weight:700}
.icon-btn.selected .icon-check{opacity:1}
.hidden{display:none!important}
.mt8{margin-top:8px}.mt16{margin-top:16px}

/* ── Difficulty Picker ── */
.diff-picker{display:flex;gap:7px;margin:6px 0 10px}
.diff-btn{flex:1;border:1.5px solid var(--surface3);border-radius:var(--rb);background:var(--surface2);color:var(--muted);font-family:inherit;font-size:12px;font-weight:700;padding:8px 4px;cursor:pointer;text-align:center;transition:all .15s;letter-spacing:.02em}
.diff-btn.active{background:color-mix(in srgb,var(--accent) 20%,transparent);border-color:var(--accent);color:var(--accent)}
.diff-btn:active{transform:scale(.95)}

/* ═══════════════════════════════════════════════════════════════
   iOS 26 LIQUID GLASS — точное воспроизведение Apple design language
   Ключевые принципы:
   · Frosted translucency  — backdrop-filter blur + saturate
   · Specular highlight    — яркая белая полоска сверху (отражение)
   · Refraction tint       — полупрозрачный градиент, имитирующий преломление
   · Layered depth         — тени с мягким свечением, без жёстких границ
   · Spring physics        — cubic-bezier отскок при нажатии
   · Pill geometry         — сильно скруглённые элементы
═══════════════════════════════════════════════════════════════ */

body.glass-mode {
  /* Уменьшены радиусы blur: blur(N) ~ N^2 нагрузка на GPU.
     28→20 и 20→14 даёт ~2x ускорение при визуально незаметной разнице */
  --gb: blur(20px) saturate(180%) brightness(1.05);
  --gb-opt: blur(7px) saturate(140%);
  --gb-cards: blur(14px) saturate(160%);
  --gb-cards-opt: blur(4px) saturate(120%);
  --gspring: cubic-bezier(0.34, 1.56, 0.64, 1);
  --gease:   cubic-bezier(0.4, 0, 0.2, 1);
  /* Specular: верхний блик стекла */
  --g-spec-top: inset 0 1.5px 0 rgba(255,255,255,0.55);
  /* Refraction: нижний внутренний контур */
  --g-refract-bot: inset 0 -1px 0 rgba(255,255,255,0.12);
  /* Outer glow accent */
  --g-glow: 0 2px 20px rgba(0,0,0,0.18);
}

/* ── Animated wallpaper blobs ── */
body.glass-mode::before {
  content: '';
  position: fixed;
  inset: 0;
  z-index: -1;
  background:
    radial-gradient(ellipse 70% 55% at 15% 18%,  color-mix(in srgb, var(--accent)  42%, transparent) 0%, transparent 65%),
    radial-gradient(ellipse 55% 65% at 82% 72%,  color-mix(in srgb, var(--accent2) 36%, transparent) 0%, transparent 65%),
    radial-gradient(ellipse 45% 40% at 55%  8%,  color-mix(in srgb, var(--accent)  22%, transparent) 0%, transparent 60%),
    radial-gradient(ellipse 38% 50% at 90% 30%,  color-mix(in srgb, var(--accent2) 18%, transparent) 0%, transparent 55%),
    radial-gradient(ellipse 50% 35% at 10% 80%,  color-mix(in srgb, var(--accent)  15%, transparent) 0%, transparent 55%),
    var(--bg);
  animation: lgBlobs 18s ease-in-out infinite alternate;
  will-change: filter;
}
/* Когда стоит кастомный фон — блобы почти прозрачны, чтобы фото было видно */
body.glass-mode.custom-bg-active::before {
  background:
    radial-gradient(ellipse 70% 55% at 15% 18%,  color-mix(in srgb, var(--accent)  14%, transparent) 0%, transparent 65%),
    radial-gradient(ellipse 55% 65% at 82% 72%,  color-mix(in srgb, var(--accent2) 10%, transparent) 0%, transparent 65%),
    transparent;
  opacity: 0.5;
}
body.glass-mode.glass-optimized::before { animation: none; }
@keyframes lgBlobs {
  0%   { filter: hue-rotate(0deg)   brightness(1);    }
  33%  { filter: hue-rotate(22deg)  brightness(1.04); }
  66%  { filter: hue-rotate(-15deg) brightness(0.97); }
  100% { filter: hue-rotate(35deg)  brightness(1.02); }
}

/* ── Screens ── */
body.glass-mode #s-home { background: transparent !important; }

body.glass-mode .screen:not(#s-home) {
  background: color-mix(in srgb, var(--bg) 55%, transparent) !important;
  backdrop-filter: var(--gb);
  -webkit-backdrop-filter: var(--gb);
  transition: opacity 0.28s var(--gease), transform 0.38s var(--gspring) !important;
}
body.glass-mode.glass-optimized .screen:not(#s-home) {
  backdrop-filter: var(--gb-opt) !important;
  -webkit-backdrop-filter: var(--gb-opt) !important;
  transition: opacity 0.15s ease !important;
}

/* ── Header (Navigation Bar) — iOS 26 style ── */
body.glass-mode .hdr {
  background: color-mix(in srgb, var(--bg) 40%, transparent) !important;
  backdrop-filter: var(--gb);
  -webkit-backdrop-filter: var(--gb);
  /* specular + refract */
  box-shadow:
    var(--g-spec-top),
    var(--g-refract-bot),
    0 1px 0 rgba(255,255,255,0.08),
    0 4px 24px rgba(0,0,0,0.14) !important;
  border-bottom: none !important;
}
body.glass-mode.glass-optimized .hdr {
  backdrop-filter: var(--gb-opt) !important;
  -webkit-backdrop-filter: var(--gb-opt) !important;
}

/* ── Bottom Tab Bar — iOS 26 style: floating pill ── */
body.glass-mode .bottom-nav {
  background: color-mix(in srgb, var(--bg) 38%, transparent) !important;
  backdrop-filter: var(--gb);
  -webkit-backdrop-filter: var(--gb);
  border-top: 1px solid rgba(255,255,255,0.14) !important;
  /* Specular highlight across top edge */
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.5),
    inset 0 2px 12px rgba(255,255,255,0.06),
    0 -2px 20px rgba(0,0,0,0.12) !important;
}
body.glass-mode.glass-optimized .bottom-nav {
  backdrop-filter: var(--gb-opt) !important;
  -webkit-backdrop-filter: var(--gb-opt) !important;
}
body.glass-mode .nav-item {
  color: rgba(255,255,255,0.55) !important;
  transition: color 0.3s var(--gspring) !important;
}
body.glass-mode .nav-item.active { color: var(--accent) !important; }
body.glass-mode .nav-item .nav-icon {
  transition: transform 0.5s var(--gspring), filter 0.3s ease !important;
}
body.glass-mode .nav-item:active .nav-icon { transform: scale(0.88) !important; }
body.glass-mode .nav-item.active .nav-icon {
  transform: scale(1.18) !important;
  filter: drop-shadow(0 0 10px color-mix(in srgb, var(--accent) 80%, transparent));
}

/* ── Schedule section header ── */
body.glass-mode .sched-header {
  background: color-mix(in srgb, var(--bg) 44%, transparent) !important;
  backdrop-filter: var(--gb);
  -webkit-backdrop-filter: var(--gb);
  box-shadow: var(--g-spec-top), var(--g-refract-bot), 0 2px 12px rgba(0,0,0,0.1) !important;
}

/* ═══ GLASS MATERIAL — карточки, панели, строки iOS 26 ═══ */
/* Базовый «material» — многослойное стекло с бликом и преломлением */
body.glass-mode .list-item,
body.glass-mode .pair-card,
body.glass-mode .bell-card,
body.glass-mode .settings-row,
body.glass-mode .last-group-btn,
body.glass-mode .theme-card,
body.glass-mode .proxy-card,
body.glass-mode .diff-btn {
  position: relative;
  background: rgba(255,255,255,0.09) !important;
  backdrop-filter: var(--gb-cards);
  -webkit-backdrop-filter: var(--gb-cards);
  border: 1px solid rgba(255,255,255,0.18) !important;
  box-shadow:
    /* specular highlight сверху */
    inset 0 1.5px 0 rgba(255,255,255,0.50),
    /* refraction bottom edge */
    inset 0 -1px 0 rgba(255,255,255,0.10),
    /* боковые внутренние контуры (эффект толщины стекла) */
    inset 1px 0 0 rgba(255,255,255,0.08),
    inset -1px 0 0 rgba(255,255,255,0.08),
    /* внешняя тень глубины */
    0 4px 20px rgba(0,0,0,0.16),
    0 1px 6px rgba(0,0,0,0.10) !important;
  overflow: hidden;
  /* GPU layer promotion: каждый элемент с backdrop-filter получает свой compositor layer */
  transform: translateZ(0);
  will-change: transform;
  backface-visibility: hidden;
  -webkit-backface-visibility: hidden;
  transition:
    transform  0.38s var(--gspring),
    background 0.25s var(--gease),
    box-shadow 0.25s var(--gease) !important;
}

/* Gradient refraction overlay — имитирует преломление как у Apple */
body.glass-mode .list-item::after,
body.glass-mode .pair-card::after,
body.glass-mode .bell-card::after,
body.glass-mode .settings-row::after,
body.glass-mode .last-group-btn::after,
body.glass-mode .theme-card::after {
  content: '';
  position: absolute;
  inset: 0;
  pointer-events: none;
  border-radius: inherit;
  background: linear-gradient(
    168deg,
    rgba(255,255,255,0.13) 0%,
    rgba(255,255,255,0.04) 35%,
    transparent 60%,
    rgba(0,0,0,0.04) 100%
  );
  z-index: 0;
}

body.glass-mode.glass-optimized .list-item,
body.glass-mode.glass-optimized .pair-card,
body.glass-mode.glass-optimized .bell-card,
body.glass-mode.glass-optimized .settings-row,
body.glass-mode.glass-optimized .last-group-btn,
body.glass-mode.glass-optimized .theme-card,
body.glass-mode.glass-optimized .proxy-card,
body.glass-mode.glass-optimized .diff-btn {
  /* Оптимизация: не убираем блюр полностью, а уменьшаем радиус —
     GPU продолжает использоваться, но нагрузка существенно ниже */
  backdrop-filter: var(--gb-cards-opt) !important;
  -webkit-backdrop-filter: var(--gb-cards-opt) !important;
  transition: none !important;
}

/* Telegram-style при glass-mode + custom bg: используем pre-blur вместо backdrop-filter
   Нет больше backdrop-filter на карточках — 0 GPU нагрузки при скролле */
body.glass-mode.custom-bg-active.preblur-ready .list-item,
body.glass-mode.custom-bg-active.preblur-ready .pair-card,
body.glass-mode.custom-bg-active.preblur-ready .bell-card,
body.glass-mode.custom-bg-active.preblur-ready .settings-row,
body.glass-mode.custom-bg-active.preblur-ready .last-group-btn,
body.glass-mode.custom-bg-active.preblur-ready .theme-card,
body.glass-mode.custom-bg-active.preblur-ready .proxy-card,
body.glass-mode.custom-bg-active.preblur-ready .diff-btn {
  background-image: var(--pre-blurred-bg) !important;
  background-size: cover !important;
  background-position: center center !important;
  background-attachment: fixed !important;
  /* Telegram tint для glass-mode чуть светлее — rgba(255,255,255,0.09) как в исходниках */
  background-color: rgba(255,255,255,0.09) !important;
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;
}
body.glass-mode.glass-optimized .list-item::after,
body.glass-mode.glass-optimized .pair-card::after,
body.glass-mode.glass-optimized .bell-card::after,
body.glass-mode.glass-optimized .settings-row::after,
body.glass-mode.glass-optimized .last-group-btn::after,
body.glass-mode.glass-optimized .theme-card::after { display:none; }

/* Press / active states — spring bounce */
body.glass-mode .list-item:active,
body.glass-mode .pair-card:active,
body.glass-mode .theme-card:active,
body.glass-mode .last-group-btn:active,
body.glass-mode .proxy-card:active {
  transform: scale(0.972) !important;
  background: rgba(255,255,255,0.14) !important;
  box-shadow:
    inset 0 1.5px 0 rgba(255,255,255,0.65),
    inset 0 -1px 0 rgba(255,255,255,0.12),
    0 2px 10px rgba(0,0,0,0.10) !important;
}

/* Selected highlight */
body.glass-mode .list-item.selected {
  background: color-mix(in srgb, var(--accent) 20%, rgba(255,255,255,0.08)) !important;
  border-color: color-mix(in srgb, var(--accent) 55%, rgba(255,255,255,0.18)) !important;
  box-shadow:
    inset 0 1.5px 0 rgba(255,255,255,0.55),
    inset 0 -1px 0 rgba(255,255,255,0.10),
    0 0 24px color-mix(in srgb, var(--accent) 30%, transparent),
    0 4px 16px rgba(0,0,0,0.14) !important;
}
body.glass-mode .theme-card.selected {
  background: color-mix(in srgb, var(--accent) 18%, rgba(255,255,255,0.09)) !important;
  border-color: color-mix(in srgb, var(--accent) 60%, rgba(255,255,255,0.2)) !important;
}
body.glass-mode .diff-btn.active {
  background: color-mix(in srgb, var(--accent) 22%, rgba(255,255,255,0.1)) !important;
  border-color: color-mix(in srgb, var(--accent) 60%, transparent) !important;
}

/* Currently active pair */
body.glass-mode .pair-card.is-now {
  background: color-mix(in srgb, var(--accent) 16%, rgba(255,255,255,0.09)) !important;
  border-color: color-mix(in srgb, var(--accent) 50%, rgba(255,255,255,0.18)) !important;
  box-shadow:
    inset 0 1.5px 0 rgba(255,255,255,0.55),
    inset 0 -1px 0 rgba(255,255,255,0.12),
    0 0 32px color-mix(in srgb, var(--accent) 28%, transparent),
    0 4px 20px rgba(0,0,0,0.16) !important;
}

/* ═══ BUTTONS — iOS 26 pill glass buttons ═══ */
body.glass-mode .btn {
  position: relative;
  border-radius: 100px !important;   /* pill shape как в iOS 26 */
  overflow: hidden;
  backdrop-filter: var(--gb-cards);
  -webkit-backdrop-filter: var(--gb-cards);
  transition:
    transform  0.36s var(--gspring),
    box-shadow 0.25s var(--gease),
    background 0.2s  var(--gease) !important;
}
body.glass-mode .btn::after {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: inherit;
  pointer-events: none;
  background: linear-gradient(
    175deg,
    rgba(255,255,255,0.22) 0%,
    rgba(255,255,255,0.06) 40%,
    transparent 70%
  );
  z-index: 1;
}
body.glass-mode .btn:active {
  transform: scale(0.94) !important;
}
body.glass-mode.glass-optimized .btn {
  /* Оптимизация кнопок: уменьшенный blur вместо полного отключения */
  backdrop-filter: var(--gb-cards-opt) !important;
  -webkit-backdrop-filter: var(--gb-cards-opt) !important;
  border-radius: 100px !important;
  transition: transform 0.2s ease !important;
}
body.glass-mode.glass-optimized .btn::after { display: none; }

/* Accent button */
body.glass-mode .btn-accent {
  background: color-mix(in srgb, var(--accent) 28%, rgba(255,255,255,0.06)) !important;
  border: 1px solid color-mix(in srgb, var(--accent) 55%, rgba(255,255,255,0.3)) !important;
  color: #fff !important;
  box-shadow:
    inset 0 1.5px 0 rgba(255,255,255,0.45),
    inset 0 -1px 0 rgba(0,0,0,0.08),
    0 4px 24px color-mix(in srgb, var(--accent) 40%, transparent),
    0 1px 6px rgba(0,0,0,0.12) !important;
}
body.glass-mode .btn-accent2 {
  background: color-mix(in srgb, var(--accent2) 28%, rgba(255,255,255,0.06)) !important;
  border: 1px solid color-mix(in srgb, var(--accent2) 50%, rgba(255,255,255,0.28)) !important;
  color: #fff !important;
  box-shadow:
    inset 0 1.5px 0 rgba(255,255,255,0.40),
    inset 0 -1px 0 rgba(0,0,0,0.08),
    0 4px 20px color-mix(in srgb, var(--accent2) 35%, transparent),
    0 1px 5px rgba(0,0,0,0.10) !important;
}

/* Surface / neutral button */
body.glass-mode .btn-surface {
  background: rgba(255,255,255,0.10) !important;
  border: 1px solid rgba(255,255,255,0.22) !important;
  color: var(--text) !important;
  box-shadow:
    inset 0 1.5px 0 rgba(255,255,255,0.45),
    inset 0 -1px 0 rgba(255,255,255,0.06),
    0 3px 14px rgba(0,0,0,0.14) !important;
}
body.glass-mode .btn-surface3 {
  background: color-mix(in srgb, var(--accent) 16%, rgba(255,255,255,0.08)) !important;
  border: 1px solid color-mix(in srgb, var(--accent) 40%, rgba(255,255,255,0.2)) !important;
  color: var(--accent) !important;
  box-shadow:
    inset 0 1.5px 0 rgba(255,255,255,0.40),
    inset 0 -1px 0 rgba(255,255,255,0.06),
    0 3px 14px color-mix(in srgb, var(--accent) 20%, transparent) !important;
}
body.glass-mode .btn-success {
  background: rgba(74,158,92,0.28) !important;
  border: 1px solid rgba(74,158,92,0.50) !important;
  box-shadow:
    inset 0 1.5px 0 rgba(255,255,255,0.40),
    0 4px 16px rgba(74,158,92,0.30) !important;
}
body.glass-mode .btn-danger {
  background: rgba(201,79,79,0.28) !important;
  border: 1px solid rgba(201,79,79,0.50) !important;
  box-shadow:
    inset 0 1.5px 0 rgba(255,255,255,0.35),
    0 4px 16px rgba(201,79,79,0.28) !important;
}

/* ── Toggle switch — стеклянный вариант iOS ── */
body.glass-mode .toggle-switch {
  background: rgba(255,255,255,0.18) !important;
  border: 1px solid rgba(255,255,255,0.28) !important;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.45),
    inset 0 2px 6px rgba(0,0,0,0.14),
    0 2px 8px rgba(0,0,0,0.12) !important;
}
body.glass-mode .toggle-switch.on {
  background: var(--accent) !important;
  border-color: color-mix(in srgb, var(--accent) 70%, rgba(255,255,255,0.4)) !important;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.50),
    0 2px 12px color-mix(in srgb, var(--accent) 50%, transparent),
    0 0 20px color-mix(in srgb, var(--accent) 30%, transparent) !important;
}
body.glass-mode .toggle-switch::after {
  box-shadow: 0 2px 6px rgba(0,0,0,0.30) !important;
}

/* ── Input fields ── */
body.glass-mode .inp {
  background: rgba(255,255,255,0.07) !important;
  border: 1px solid rgba(255,255,255,0.16) !important;
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.12), inset 0 2px 8px rgba(0,0,0,0.10) !important;
}
body.glass-mode .inp:focus {
  background: rgba(255,255,255,0.10) !important;
  border-color: color-mix(in srgb, var(--accent) 65%, rgba(255,255,255,0.25)) !important;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.20),
    0 0 0 3px color-mix(in srgb, var(--accent) 20%, transparent),
    0 0 16px color-mix(in srgb, var(--accent) 18%, transparent) !important;
}

/* ── Toast notification — стеклянная плашка ── */
body.glass-mode .toast {
  background: color-mix(in srgb, var(--bg) 50%, rgba(20,20,30,0.5)) !important;
  backdrop-filter: blur(28px) saturate(180%) !important;
  -webkit-backdrop-filter: blur(28px) saturate(180%) !important;
  border: 1px solid rgba(255,255,255,0.20) !important;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.40),
    0 8px 32px rgba(0,0,0,0.25) !important;
}

/* ── Ripple ── */
body.glass-mode .ripple {
  background: radial-gradient(circle, rgba(255,255,255,0.35) 0%, transparent 70%) !important;
}

/* ── Now badge ── */
body.glass-mode .now-badge {
  background: color-mix(in srgb, var(--accent) 40%, rgba(255,255,255,0.1)) !important;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  box-shadow: 0 2px 8px color-mix(in srgb, var(--accent) 30%, transparent) !important;
}

/* ── Section labels ── */
body.glass-mode .section-label {
  text-shadow: 0 1px 4px rgba(0,0,0,0.4);
}

/* ── Overlays ── */
body.glass-mode .egg-overlay {
  background: color-mix(in srgb, var(--bg) 70%, transparent) !important;
  backdrop-filter: blur(30px) saturate(200%) !important;
  -webkit-backdrop-filter: blur(30px) saturate(200%) !important;
}
body.glass-mode .ota-overlay .ota-sheet {
  background: color-mix(in srgb, var(--bg) 55%, rgba(20,20,30,0.4)) !important;
  backdrop-filter: blur(30px) saturate(200%) !important;
  -webkit-backdrop-filter: blur(30px) saturate(200%) !important;
  border: 1px solid rgba(255,255,255,0.18) !important;
  box-shadow: inset 0 1.5px 0 rgba(255,255,255,0.45), 0 20px 60px rgba(0,0,0,0.4) !important;
}

/* ── Custom background layer ── */
#bg-layer {
  position: fixed;
  inset: 0;
  z-index: -2;
  background-size: cover;
  background-position: center center;
  background-repeat: no-repeat;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.5s ease;
  /* GPU-promotion: фон рендерится в отдельном compositor layer,
     это позволяет backdrop-filter работать через GPU без repaint CPU */
  transform: translateZ(0);
  will-change: transform;
  backface-visibility: hidden;
  -webkit-backface-visibility: hidden;
}
#bg-layer.active { opacity: 1; }
/* Когда фон активен — убираем background тела, чтобы bg-layer просвечивал */
body.custom-bg-active,
html:has(body.custom-bg-active) {
  background-color: transparent !important;
}
body.custom-bg-active .screen:not(#s-home) {
  background: rgba(0,0,0,0.25) !important;
}
body.custom-bg-active #s-home {
  background: transparent !important;
}
body.custom-bg-active .hdr,
body.custom-bg-active .bottom-nav {
  /* Telegram: hdr/nav при кастомном фоне — pre-blurred static bg + glass tint */
  background-image: var(--pre-blurred-bg, none) !important;
  background-size: cover !important;
  background-position: center center !important;
  background-attachment: fixed !important;
  background-color: rgba(0,0,0,0.38) !important;
  backdrop-filter: none;
  -webkit-backdrop-filter: none;
  border-top: 1px solid rgba(255,255,255,0.12) !important;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.20), 0 -1px 0 rgba(0,0,0,0.15) !important;
}
/* Fallback пока blur не готов */
body.custom-bg-active:not(.preblur-ready) .hdr,
body.custom-bg-active:not(.preblur-ready) .bottom-nav {
  background-image: none !important;
  background-color: rgba(0,0,0,0.45) !important;
  backdrop-filter: blur(16px) saturate(160%);
  -webkit-backdrop-filter: blur(16px) saturate(160%);
}
body.custom-bg-active.glass-mode .screen:not(#s-home) {
  background: rgba(0,0,0,0.18) !important;
}
body.custom-bg-active.glass-mode .hdr,
body.custom-bg-active.glass-mode .bottom-nav {
  background-image: var(--pre-blurred-bg, none) !important;
  background-size: cover !important;
  background-position: center center !important;
  background-attachment: fixed !important;
  background-color: rgba(0,0,0,0.30) !important;
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;
  border-top: 1px solid rgba(255,255,255,0.15) !important;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.25), 0 -2px 20px rgba(0,0,0,0.18) !important;
}
body.custom-bg-active.glass-mode:not(.preblur-ready) .hdr,
body.custom-bg-active.glass-mode:not(.preblur-ready) .bottom-nav {
  background-image: none !important;
  background-color: rgba(0,0,0,0.32) !important;
  backdrop-filter: var(--gb) !important;
  -webkit-backdrop-filter: var(--gb) !important;
}

/* ══════════════════════════════════════════════════════════════════════
   TELEGRAM LIQUID GLASS — кнопки файлов, выбора группы, last-group-btn
   ══════════════════════════════════════════════════════════════════════
   Точный принцип Telegram Android (Utilities.java + ImageLoader.java):

   1. blurBitmap: createScaledBitmap(src, w/4, h/4) → StackBlur(radius=7)
   2. BitmapShader → используется как paint.shader при drawRoundRect
   3. Поверх рисуется tint: canvas.drawColor(0x55000000) — ~33% чёрный
   4. Верхний блик: drawLine(specular rgba(255,255,255,0.4)) по верхней грани

   В CSS:
   - background-image = var(--pre-blurred-bg)   ← заблюренная фотография
   - background-color = rgba(0,0,0,0.28)         ← тёмный tint (Telegram 0x55=~33%)
   - ::after            = specular highlight       ← верхний блик стекла
   - border             = rgba(255,255,255,0.20)   ← контур стекла
   ══════════════════════════════════════════════════════════════════════ */

body.custom-bg-active .list-item,
body.custom-bg-active .last-group-btn,
body.custom-bg-active #file-section .btn {
  /* Telegram BitmapShader background — заблюренная фотография */
  background-image: var(--pre-blurred-bg, none) !important;
  background-size: cover !important;
  background-position: center center !important;
  background-attachment: fixed !important;
  /* Telegram tint — rgba(0,0,0,~0x55/255=0.33) поверх blur */
  background-color: rgba(0,0,0,0.33) !important;
  /* Telegram glass border */
  border: 1px solid rgba(255,255,255,0.18) !important;
  /* Telegram outer shadow */
  box-shadow:
    /* specular highlight — верхняя грань стекла */
    inset 0 1px 0 rgba(255,255,255,0.42),
    /* refraction bottom — нижняя внутренняя грань */
    inset 0 -1px 0 rgba(255,255,255,0.08),
    /* side thickness effect */
    inset 1px 0 0 rgba(255,255,255,0.06),
    inset -1px 0 0 rgba(255,255,255,0.06),
    /* outer elevation shadow */
    0 2px 12px rgba(0,0,0,0.20) !important;
  position: relative;
  overflow: hidden;
  /* Один compositor layer — не backdrop-filter на каждый элемент */
  transform: translateZ(0);
  /* Нет will-change: backdrop-filter — это и был источник нагрузки! */
}

/* Telegram specular gradient (linear gradient поверх шейдера) */
body.custom-bg-active .list-item::after,
body.custom-bg-active .last-group-btn::after,
body.custom-bg-active #file-section .btn::after {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: inherit;
  /* Telegram: верхняя половина чуть светлее (преломление света в стекле) */
  background: linear-gradient(180deg,
    rgba(255,255,255,0.14) 0%,
    rgba(255,255,255,0.04) 50%,
    rgba(0,0,0,0.04) 100%);
  pointer-events: none;
  z-index: 0;
}

/* Fallback: пока StackBlur canvas ещё обсчитывается (~100-250мс после установки фото) */
body.custom-bg-active:not(.preblur-ready) .list-item,
body.custom-bg-active:not(.preblur-ready) .last-group-btn,
body.custom-bg-active:not(.preblur-ready) #file-section .btn {
  background-image: none !important;
  background-color: rgba(0,0,0,0.45) !important;
  /* Временный lёгкий backdrop-filter пока pre-blur не готов */
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}

/* Selected state */
body.custom-bg-active .list-item.selected {
  border-color: color-mix(in srgb, var(--accent) 55%, rgba(255,255,255,0.18)) !important;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.42),
    inset 0 -1px 0 rgba(255,255,255,0.08),
    0 2px 12px rgba(0,0,0,0.20),
    0 0 0 1px color-mix(in srgb, var(--accent) 30%, transparent) !important;
}
body.custom-bg-active .list-item.selected::after {
  background: linear-gradient(180deg,
    color-mix(in srgb, var(--accent) 20%, rgba(255,255,255,0.14)) 0%,
    color-mix(in srgb, var(--accent) 12%, rgba(0,0,0,0.02)) 100%) !important;
}

/* Pill shape для кнопок файлов */
body.custom-bg-active #file-section .btn {
  border-radius: 100px !important;
}

/* Когда pre-blur готов И включена оптимизация — backdrop-filter уже выключен, ничего не делаем */
body.custom-bg-active.glass-optimized.preblur-ready .list-item,
body.custom-bg-active.glass-optimized.preblur-ready .last-group-btn,
body.custom-bg-active.glass-optimized.preblur-ready #file-section .btn {
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;
}



/* Legacy fallback */
[data-theme="glass"] body::before { animation: lgBlobs 18s ease-in-out infinite alternate; }

/* ── Easter Egg (overlay) ── */
.egg-overlay{
  position:fixed;inset:0;z-index:2000;
  background:var(--bg);
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  opacity:0;pointer-events:none;
  transition:opacity .3s ease;
  padding:calc(60px + var(--safe-top)) 24px calc(24px + var(--safe-bot));
  overflow-y:auto
}
.egg-overlay.show{opacity:1;pointer-events:all}
.egg-close{
  position:fixed;top:calc(16px + var(--safe-top));right:16px;
  background:var(--surface2);border:none;color:var(--muted);
  width:36px;height:36px;border-radius:50%;font-size:20px;
  cursor:pointer;display:flex;align-items:center;justify-content:center;z-index:10
}
.egg-back{
  position:fixed;top:calc(16px + var(--safe-top));left:16px;
  background:var(--surface2);border:none;color:var(--accent);
  width:36px;height:36px;border-radius:50%;font-size:22px;
  cursor:pointer;display:flex;align-items:center;justify-content:center;z-index:10;
  opacity:0;pointer-events:none;transition:opacity .2s
}
.egg-back.show{opacity:1;pointer-events:all}
.egg-title{
  font-size:26px;font-weight:800;text-align:center;
  letter-spacing:-.03em;margin-bottom:6px;
  background:linear-gradient(135deg,var(--accent),#ff4e00);
  -webkit-background-clip:text;-webkit-text-fill-color:transparent
}
.egg-sub{font-size:13px;color:var(--muted);text-align:center;margin-bottom:20px;line-height:1.6}
.egg-score{font-family:'JetBrains Mono',monospace;font-size:13px;color:var(--accent);margin-top:10px;letter-spacing:.05em;text-align:center}
/* ── Picker ── */
.egg-picker{width:100%;max-width:340px}
.egg-picker-title{font-size:10px;font-weight:700;color:var(--muted);letter-spacing:.15em;text-transform:uppercase;margin-bottom:10px}
.egg-cards{display:flex;flex-direction:column;gap:8px}
.egg-card{
  background:var(--surface2);border:1.5px solid var(--surface3);
  border-radius:14px;padding:14px 16px;cursor:pointer;
  display:flex;align-items:center;gap:14px;
  position:relative;overflow:hidden;
  transition:border-color .15s,box-shadow .15s,transform .12s
}
.egg-card:active{transform:scale(.97);background:var(--surface3)}
.egg-card:hover{border-color:color-mix(in srgb,var(--accent) 55%,transparent);box-shadow:0 0 16px color-mix(in srgb,var(--accent) 20%,transparent)}
.egg-card-icon{font-size:30px;flex-shrink:0;line-height:1}
.egg-card-body{flex:1;min-width:0}
.egg-card-name{font-size:15px;font-weight:700}
.egg-card-desc{font-size:11px;color:var(--muted);margin-top:2px}
.egg-card-badge{
  display:inline-block;font-size:9px;font-weight:700;
  font-family:'JetBrains Mono',monospace;
  color:var(--accent);background:color-mix(in srgb,var(--accent) 15%,transparent);
  border:1px solid color-mix(in srgb,var(--accent) 40%,transparent);
  padding:2px 7px;border-radius:20px;margin-top:5px;letter-spacing:.05em
}
.egg-card-new{color:#4caf7d;background:rgba(76,175,125,.15);border-color:rgba(76,175,125,.4)}
.egg-card-arrow{color:var(--muted);font-size:20px;flex-shrink:0}
/* ── Game view ── */
.egg-game{width:100%;display:flex;flex-direction:column;align-items:center}
.egg-game-title{font-size:18px;font-weight:800;color:var(--text);letter-spacing:-.02em;margin-bottom:4px}
/* ── Snake d-pad ── */
.snake-dpad{display:grid;grid-template-columns:repeat(3,48px);grid-template-rows:repeat(3,48px);gap:5px;margin-top:14px}
.dpad-btn{background:var(--surface2);border:1.5px solid var(--surface3);border-radius:10px;color:var(--text);font-size:18px;cursor:pointer;display:flex;align-items:center;justify-content:center;user-select:none;-webkit-user-select:none;transition:background .1s,transform .1s}
.dpad-btn:active{background:var(--surface3);transform:scale(.92)}
/* ── Tic-tac-toe ── */
.ttt-board{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;width:min(280px,80vw);margin:0 auto}
.ttt-cell{
  aspect-ratio:1;background:var(--surface2);border:1.5px solid var(--surface3);
  border-radius:12px;display:flex;align-items:center;justify-content:center;
  font-size:36px;cursor:pointer;user-select:none;
  transition:background .12s,transform .12s,border-color .12s,box-shadow .15s
}
.ttt-cell:active{transform:scale(.91)}
.ttt-cell.x-cell{color:var(--accent);text-shadow:0 0 12px color-mix(in srgb,var(--accent) 80%,transparent)}
.ttt-cell.o-cell{color:#60cdff;text-shadow:0 0 12px rgba(96,205,255,.7)}
.ttt-cell.win{background:color-mix(in srgb,var(--accent) 18%,transparent);border-color:color-mix(in srgb,var(--accent) 60%,transparent);box-shadow:0 0 16px color-mix(in srgb,var(--accent) 35%,transparent)}
.ttt-scores{display:flex;gap:20px;margin-bottom:14px}
.ttt-score-item{display:flex;flex-direction:column;align-items:center;gap:3px;font-size:11px;color:var(--muted)}
.ttt-score-val{font-size:22px;font-weight:800;color:var(--text);font-family:'JetBrains Mono',monospace}
.ttt-status{font-size:13px;font-weight:600;color:var(--muted);margin-top:14px;min-height:20px;text-align:center}
/* ── Tetris controls ── */
.tet-controls{display:flex;gap:8px;margin-top:12px;align-items:center}
.tet-btn{background:var(--surface2);border:1.5px solid var(--surface3);border-radius:10px;color:var(--text);font-size:16px;width:50px;height:46px;cursor:pointer;display:flex;align-items:center;justify-content:center;user-select:none;-webkit-user-select:none;flex-shrink:0;transition:background .1s,transform .1s}
.tet-btn:active{background:var(--surface3);transform:scale(.92)}
.tet-btn-wide{width:70px}

/* ── OTA Update Modal ── */
.ota-overlay{
  position:fixed;inset:0;z-index:1000;
  background:rgba(0,0,0,.65);
  display:flex;align-items:flex-end;justify-content:center;
  opacity:0;pointer-events:none;
  transition:opacity .25s ease;
  backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px)
}
.ota-overlay.show{opacity:1;pointer-events:all}
.ota-sheet{
  width:100%;max-width:480px;
  background:var(--surface);
  border-radius:24px 24px 0 0;
  padding:12px 22px calc(22px + var(--safe-bot));
  transform:translateY(100%);
  transition:transform .32s cubic-bezier(.34,1.1,.64,1);
  border-top:1px solid rgba(255,255,255,.08)
}
.ota-overlay.show .ota-sheet{transform:translateY(0)}
.ota-handle{
  width:40px;height:4px;border-radius:2px;
  background:var(--surface3);margin:0 auto 20px
}
.ota-icon{font-size:38px;text-align:center;margin-bottom:10px;line-height:1}
.ota-title{
  font-size:20px;font-weight:800;text-align:center;
  letter-spacing:-.02em;margin-bottom:6px;color:var(--text)
}
.ota-version{
  font-size:13px;font-weight:600;text-align:center;
  color:var(--accent);margin-bottom:14px;
  font-family:'JetBrains Mono',monospace
}
.ota-notes{
  font-size:13px;color:var(--muted);line-height:1.6;
  background:var(--surface2);border-radius:var(--rb);
  padding:12px 14px;margin-bottom:18px;
  border:1px solid var(--surface3);
  max-height:120px;overflow-y:auto;white-space:pre-wrap;
  display:none
}
.ota-notes.has-text{display:block}
.ota-progress-wrap{margin-bottom:16px}
.ota-progress-track{
  height:6px;background:var(--surface3);border-radius:3px;overflow:hidden;margin-bottom:7px
}
.ota-progress-bar{
  height:100%;width:0%;background:var(--accent);border-radius:3px;
  transition:width .15s ease
}
.ota-progress-label{
  font-size:12px;color:var(--muted);text-align:center;font-family:'JetBrains Mono',monospace
}
/* ── Приветствие (Sber-style) ── */
.greeting-overlay{
  position:fixed;inset:0;z-index:9999;
  display:flex; /* виден сразу — не ждёт JS */
  flex-direction:column;align-items:center;justify-content:center;
  background:var(--bg);
  will-change:opacity;
  transition:opacity .5s cubic-bezier(.4,0,.2,1);
}
.greeting-overlay.greet-hidden{
  opacity:0;pointer-events:none;
}
.greet-logo{
  width:80px;height:80px;border-radius:26px;
  background:linear-gradient(135deg,var(--accent),var(--accent2));
  display:flex;align-items:center;justify-content:center;
  font-size:36px;
  box-shadow:0 6px 24px color-mix(in srgb,var(--accent) 38%,transparent);
  margin-bottom:28px;
  animation:greet-logo-float 2.6s ease-in-out infinite;
}
@keyframes greet-logo-float{
  0%,100%{transform:translateY(0)}
  50%{transform:translateY(-6px)}
}
.greet-main{
  font-size:28px;font-weight:800;color:var(--text);
  letter-spacing:-.02em;text-align:center;
  min-height:36px;
}
.greet-main .greet-char{
  display:inline-block;
  opacity:0;transform:translateY(10px);
  animation:greet-char-in .35s cubic-bezier(.34,1.56,.64,1) forwards;
}
@keyframes greet-char-in{
  to{opacity:1;transform:translateY(0)}
}
.greet-sub{
  font-size:13px;color:var(--muted);margin-top:10px;
  letter-spacing:.04em;text-align:center;
  opacity:0;animation:greet-sub-in .5s .55s ease forwards;
}
@keyframes greet-sub-in{to{opacity:1}}
.greet-divider{
  width:40px;height:2px;border-radius:1px;
  background:color-mix(in srgb,var(--accent) 50%,transparent);
  margin:14px 0;
  opacity:0;animation:greet-sub-in .4s .45s ease forwards;
}
.greet-time{
  position:absolute;bottom:calc(var(--safe-bot) + 44px);
  font-family:'JetBrains Mono',monospace;font-size:13px;
  color:var(--muted);letter-spacing:.1em;
  opacity:0;animation:greet-sub-in .4s .7s ease forwards;
}
.greet-particles{position:absolute;inset:0;pointer-events:none;overflow:hidden;}
.greet-particle{
  position:absolute;border-radius:50%;
  background:var(--accent);opacity:0;
  animation:greet-particle-anim var(--dur,3s) var(--del,0s) ease-in-out infinite;
}
@keyframes greet-particle-anim{
  0%{opacity:0;transform:translateY(0) scale(1)}
  20%{opacity:.18}
  80%{opacity:.06}
  100%{opacity:0;transform:translateY(-120px) scale(.4)}
}

/* ── Секретная CMD-консоль ── */
.cmd-overlay{
  position:fixed;inset:0;z-index:600;display:flex;flex-direction:column;
  background:#0c0c0c;font-family:'JetBrains Mono',monospace;
  padding-top:var(--safe-top);padding-bottom:var(--safe-bot);
}
.cmd-titlebar{
  background:#1a1a1a;padding:10px 14px;display:flex;align-items:center;gap:10px;
  border-bottom:1px solid #333;flex-shrink:0;
}
.cmd-titlebar-dots{display:flex;gap:6px;}
.cmd-dot{width:12px;height:12px;border-radius:50%;}
.cmd-title{font-size:12px;color:#888;flex:1;text-align:center;letter-spacing:.06em;}
.cmd-close{background:none;border:none;color:#888;font-size:18px;cursor:pointer;padding:0 4px;line-height:1;}
.cmd-body{flex:1;overflow-y:auto;padding:14px 16px;display:flex;flex-direction:column;gap:2px;}
.cmd-body::-webkit-scrollbar{display:none;}
.cmd-line{font-size:12.5px;line-height:1.65;white-space:pre-wrap;word-break:break-word;}
.cmd-line.out{color:#cccccc;}
.cmd-line.ok{color:#4ec94e;}
.cmd-line.err{color:#ff6b6b;}
.cmd-line.info{color:#5bb8f5;}
.cmd-line.warn{color:#f5c842;}
.cmd-line.prompt{color:#888;}
.cmd-input-row{
  display:flex;align-items:center;gap:0;padding:10px 16px;
  border-top:1px solid #222;flex-shrink:0;background:#0c0c0c;
}
.cmd-prompt-sym{color:var(--accent);font-family:'JetBrains Mono',monospace;font-size:13px;margin-right:8px;flex-shrink:0;}
.cmd-input{
  flex:1;background:transparent;border:none;outline:none;
  font-family:'JetBrains Mono',monospace;font-size:13px;color:#eee;caret-color:var(--accent);
}
.cmd-cursor-blink{display:inline-block;width:8px;height:14px;background:var(--accent);margin-left:1px;vertical-align:text-bottom;animation:blink 1s step-end infinite;}
@keyframes blink{0%,100%{opacity:1}50%{opacity:0}}
/* ── Секретные эффекты ── */
#matrix-canvas{position:fixed;inset:0;z-index:9998;pointer-events:none;opacity:0;transition:opacity .5s;}
#matrix-canvas.active{opacity:.85;}
#snow-canvas{position:fixed;inset:0;z-index:8;pointer-events:none;}
@keyframes app-shake{0%,100%{transform:translateX(0)}20%{transform:translateX(-9px)}40%{transform:translateX(9px)}60%{transform:translateX(-5px)}80%{transform:translateX(5px)}}
body.shaking{animation:app-shake .45s ease;}
/* ── Диско: насыщенный RGB-режим ── */
#disco-overlay{
  position:fixed;inset:0;z-index:900;pointer-events:none;
  display:none;opacity:0;
  mix-blend-mode:screen;
}
body.disco-mode #disco-overlay{display:block;}

@keyframes disco-rgb{
  0%   {background:hsl(0,100%,55%);   opacity:calc(.55 * var(--disco-intensity,1))}
  14%  {background:hsl(50,100%,55%);  opacity:calc(.50 * var(--disco-intensity,1))}
  28%  {background:hsl(110,100%,50%); opacity:calc(.55 * var(--disco-intensity,1))}
  42%  {background:hsl(185,100%,55%); opacity:calc(.50 * var(--disco-intensity,1))}
  57%  {background:hsl(240,100%,65%); opacity:calc(.58 * var(--disco-intensity,1))}
  71%  {background:hsl(290,100%,60%); opacity:calc(.52 * var(--disco-intensity,1))}
  85%  {background:hsl(330,100%,60%); opacity:calc(.55 * var(--disco-intensity,1))}
  100% {background:hsl(360,100%,55%); opacity:calc(.55 * var(--disco-intensity,1))}
}
body.disco-mode #disco-overlay{animation:disco-rgb 3s linear infinite;}

/* Второй оверлей — противофазный блик */
#disco-overlay::after{
  content:'';position:absolute;inset:0;
  background:radial-gradient(ellipse 70% 60% at 50% 50%, rgba(255,255,255,0.18) 0%, transparent 70%);
  animation:disco-spot 5s ease-in-out infinite alternate;
}
@keyframes disco-spot{
  0%  {transform:translate(-30%,-20%) scale(1.2);}
  33% {transform:translate(25%, 15%) scale(0.9);}
  66% {transform:translate(-15%, 30%) scale(1.1);}
  100%{transform:translate(30%,-25%) scale(1.3);}
}

/* Вспышки на всём теле */
@keyframes disco-pulse{
  0%,100%{filter:brightness(1)    saturate(calc(1   + var(--disco-intensity,1)*0));}
  25%    {filter:brightness(calc(1 + var(--disco-intensity,1)*.2))  saturate(calc(1 + var(--disco-intensity,1)*.8))  hue-rotate(0deg);}
  50%    {filter:brightness(calc(1 - var(--disco-intensity,1)*.1))  saturate(calc(1 + var(--disco-intensity,1)*.5))  hue-rotate(60deg);}
  75%    {filter:brightness(calc(1 + var(--disco-intensity,1)*.25)) saturate(calc(1 + var(--disco-intensity,1)*1.0)) hue-rotate(30deg);}
}
body.disco-mode{animation:disco-pulse 3s ease-in-out infinite;}

/* Карточки пульсируют контуром */
@keyframes disco-card-glow{
  0%,100%{box-shadow:0 0 8px  2px hsl(0,100%,60%);}
  33%    {box-shadow:0 0 14px 4px hsl(120,100%,55%);}
  66%    {box-shadow:0 0 12px 3px hsl(240,100%,70%);}
}
body.disco-mode .pair-card,
body.disco-mode .list-item,
body.disco-mode .btn-accent{
  animation:disco-card-glow 3s linear infinite!important;
}

/* Текст переливается */
@keyframes disco-text{
  0%  {color:hsl(0,100%,80%);}
  25% {color:hsl(90,100%,75%);}
  50% {color:hsl(200,100%,80%);}
  75% {color:hsl(300,100%,80%);}
  100%{color:hsl(360,100%,80%);}
}
body.disco-mode .hdr-title,
body.disco-mode .item-name,
body.disco-mode .pair-subject,
body.disco-mode .hero-title{
  animation:disco-text 4s linear infinite!important;
}

/* Нижняя панель мигает */
@keyframes disco-nav{
  0%,100%{background:rgba(255,0,100,0.35)!important;}
  33%    {background:rgba(0,255,120,0.35)!important;}
  66%    {background:rgba(50,100,255,0.40)!important;}
}
body.disco-mode .bottom-nav{animation:disco-nav 3s linear infinite!important;}
</style>
<body>
<div id="bg-layer"></div>

<!-- ГЛАВНАЯ -->
<div class="screen active" id="s-home">
  <div class="body">
    <div class="home-hero">
      <div class="hero-card">
        <div class="hero-title">колледж<br>расписание</div>
      </div>
    </div>
    <div id="last-group-wrap" class="hidden">
      <div class="section-label">Быстрый запуск</div>
      <button class="last-group-btn" id="last-group-btn" onclick="jumpToLastGroup()"></button>
      <div style="height:14px"></div>
    </div>
    <div class="status" id="home-status"></div>
    <div class="progress"><div class="progress-bar" id="home-bar"></div></div>
    <div id="file-section" class="hidden">
      <div class="section-label">Файл расписания</div>
      <div class="list" id="file-list"></div>
      <div style="height:14px"></div>
      <button class="btn btn-accent" onclick="goToGroups()">Выбрать группу →</button>
    </div>
    <div id="no-url-hint" class="hidden" style="text-align:center;padding:48px 20px">
      <div style="font-size:38px;margin-bottom:12px">⚙️</div>
      <div style="color:var(--muted);font-size:14px;line-height:1.6;margin-bottom:20px">Укажи ссылку на Яндекс Диск<br>в <b style="color:var(--accent)">Настройках</b></div>
      <button class="btn btn-accent" onclick="navTo('s-settings','nav-settings')">Открыть настройки →</button>
    </div>
    <div id="home-error-hint" class="hidden" style="text-align:center;padding:36px 20px">
      <div style="font-size:36px;margin-bottom:10px">🔌</div>
      <div style="color:var(--text);font-size:15px;font-weight:700;margin-bottom:6px">Не удалось загрузить файлы</div>
      <div class="error-msg" style="color:var(--muted);font-size:12px;line-height:1.6;margin-bottom:6px;word-break:break-word"></div>
      <div style="color:var(--muted);font-size:12px;line-height:1.6;margin-bottom:20px">
        Проверь подключение к интернету и повтори попытку.
      </div>
      <button class="btn btn-surface" onclick="loadFiles()">🔄 Повторить</button>
    </div>
  </div>
</div>

<!-- ГРУППЫ -->
<div class="screen" id="s-groups">
  <div class="hdr">
    <button class="hdr-back" onclick="SFX.play('screenBack');goHome()">‹</button>
    <div><div class="hdr-title" id="groups-title">Выбор группы</div>
    <div class="hdr-sub" id="groups-sub"></div></div>
  </div>
  <div style="padding:12px 18px 0;flex-shrink:0">
    <div class="search-wrap">
      <span class="search-icon">🔍</span>
      <input class="inp" id="group-search" placeholder="Найти группу..." oninput="filterGroups(this.value)">
    </div>
    <div class="status mt8" id="groups-status"></div>
    <div class="progress"><div class="progress-bar" id="groups-bar"></div></div>
  </div>
  <div class="body" style="padding-top:10px"><div class="list" id="group-list"></div></div>
</div>

<!-- РАСПИСАНИЕ -->
<div class="screen" id="s-schedule">
  <div class="sched-header" id="sched-header-tap">
    <div style="display:flex;align-items:center;gap:10px">
      <button class="hdr-back" onclick="SFX.play('screenBack');showScreen('s-groups','back')">‹</button>
      <div><div class="sched-group" id="sched-group-name"></div>
      <div class="sched-date" id="sched-date"></div></div>
    </div>
  </div>
  <div class="body" id="sched-body"></div>
</div>

<!-- ЗВОНКИ -->
<div class="screen" id="s-bells">
  <div class="hdr">
    <button class="hdr-back" onclick="SFX.play('screenBack');goHome()">‹</button>
    <div class="hdr-title">Расписание звонков</div>
  </div>
  <div class="body" id="bells-body"></div>
</div>

<!-- НАСТРОЙКИ -->
<div class="screen" id="s-settings">
  <div class="hdr">
    <button class="hdr-back" onclick="SFX.play('screenBack');goHome()">‹</button>
    <div class="hdr-title">Настройки</div>
  </div>
  <div class="body">

    <!-- Яндекс Диск -->
    <div class="section-label">Яндекс Диск</div>
    <input class="inp" id="url-input" type="url"
           placeholder="https://disk.yandex.ru/d/..."
           autocomplete="off" autocorrect="off" autocapitalize="off">
    <div style="height:8px"></div>
    <button class="btn btn-accent2" onclick="SFX.play('btnAccent');saveUrlAndLoad()">⬇ Обновить файлы</button>
    <div style="height:6px"></div>
    <div class="status" id="proxy-status" style="text-align:left;font-size:11px"></div>
    <div class="sep"></div>

    <!-- Тема оформления -->
    <div class="section-label">Тема оформления</div>
    <div id="theme-current-row" class="list-item" onclick="showScreen('s-themes')" style="margin-bottom:8px">
      <div>
        <div class="item-name" id="theme-current-name">Колледж</div>
        <div class="item-sub" id="theme-current-sub">Нажми для выбора</div>
      </div>
      <span class="item-arrow">›</span>
    </div>

    <!-- Liquid Glass режим -->
    <div class="settings-row" style="flex-direction:column;align-items:stretch;gap:0;padding:0;overflow:hidden;margin-bottom:8px">
      <div style="display:flex;align-items:center;justify-content:space-between;padding:14px 16px;">
        <div>
          <div style="font-size:14px;font-weight:600;display:flex;align-items:center;gap:7px">
            🫧 Liquid Glass
            <span style="font-size:9px;font-weight:800;background:var(--accent);color:#000;padding:2px 6px;border-radius:4px;letter-spacing:.06em;opacity:.85">БЕТА</span>
          </div>
          <div class="settings-row-sub" style="color:var(--accent);font-weight:600;margin-top:3px">⚠️ Экспериментально · очень сильно влияет на производительность</div>
        </div>
        <div id="glass-toggle" class="toggle-switch" onclick="toggleGlassMode()" style="flex-shrink:0"></div>
      </div>
      <div id="glass-opt-row" style="border-top:1px solid rgba(255,255,255,.07);padding:12px 16px;display:none;align-items:center;justify-content:space-between;">
        <div>
          <div style="font-size:13px;font-weight:600">⚡ Оптимизация блюра</div>
          <div class="settings-row-sub">Снижает радиус блюра (GPU-слои остаются), отключает анимации и псевдоэлементы. Работает и для кастомного фона, и для Liquid Glass. Значительно улучшает FPS</div>
        </div>
        <div id="glass-opt-toggle" class="toggle-switch" onclick="toggleGlassOpt()" style="flex-shrink:0"></div>
      </div>
    </div>

    <!-- Фон приложения -->
    <div class="section-label">Фон приложения</div>
    <div id="custom-bg-preview" style="display:none;border-radius:var(--rb);overflow:hidden;margin-bottom:8px;position:relative">
      <img id="custom-bg-img-thumb" style="width:100%;height:80px;object-fit:cover;display:block" src="" alt="">
      <div style="position:absolute;inset:0;background:linear-gradient(transparent,rgba(0,0,0,.5));display:flex;align-items:flex-end;padding:8px 12px">
        <span style="font-size:11px;color:#fff;font-weight:600">Свой фон активен</span>
      </div>
    </div>
    <button class="btn btn-surface" onclick="pickBgImage()" style="margin-bottom:6px">🖼 Загрузить фон (PNG / JPG)</button>
    <button id="remove-bg-btn" class="btn btn-danger" onclick="removeBgImage()" style="display:none;margin-bottom:6px">🗑 Удалить фон</button>
    <input type="file" id="bg-file-input" accept="image/*,image/png,image/jpeg,image/jpg,image/gif,image/webp,image/bmp,image/heic,image/heif,image/avif,.png,.jpg,.jpeg,.gif,.webp,.bmp,.heic,.heif,.avif" style="display:none" onchange="onBgFileChosen(event)">
    <div class="sep"></div>

    <!-- Звук -->
    <div class="section-label">Звук</div>
    <div class="list-item" onclick="toggleMute()" style="margin-bottom:8px">
      <div>
        <div class="item-name" id="mute-label">🔇 Звук выключен</div>
        <div class="item-sub">Звуки интерфейса</div>
      </div>
      <span class="item-arrow">›</span>
    </div>
    <div class="sep"></div>

    <!-- Диагностика -->
    <div class="section-label">Диагностика</div>
    <div style="font-size:12px;color:var(--muted);margin-bottom:10px;line-height:1.6">
      Если что-то не работает — логи помогут найти причину.<br>
      Файл: <span style="color:var(--accent);font-family:'JetBrains Mono',monospace;font-size:11px">Download/ScheduleApp_logs.txt</span>
    </div>
    <button class="btn btn-surface" onclick="if(window.Android&&window.Android.showLogPath){window.Android.showLogPath();}else{alert('Лог: Download/ScheduleApp_logs.txt');}">
      📋 Где лог-файл?
    </button>
    <div style="height:8px"></div>
    <button class="btn btn-surface" onclick="var ok=window.Android&&window.Android.logMsg;if(ok){window.Android.logMsg('INFO','Ручная проверка логгера '+new Date().toISOString());toast('Строка записана в лог');}else{toast('Android bridge не найден');}">
      🔬 Записать тест в лог
    </button>
    <div class="sep"></div>

    <!-- Приложение / OTA -->
    <div class="section-label">Приложение</div>
    <div class="list-item" style="cursor:default;margin-bottom:8px">
      <div id="egg-tap-zone"
        onclick="eggTap()"
        ontouchstart="eggTap()"
        style="cursor:pointer;-webkit-tap-highlight-color:transparent;padding:10px 0;flex:1;min-width:0;user-select:none">
        <div class="item-name">Версия</div>
        <div class="item-sub" id="app-version-str">3.1.7 — Android</div>
      </div>
      <button class="btn btn-surface3" style="width:auto;padding:8px 14px;font-size:12px;flex-shrink:0" onclick="checkOtaUpdate()">🔄 Проверить</button>
    </div>
    <button class="btn btn-surface" onclick="clearCacheAndReload()" style="margin-bottom:4px">🧹 Очистить кэш и перезагрузить</button>
    <div style="height:24px"></div>
  </div>
</div>


<!-- ВЫБОР ТЕМЫ -->
<div class="screen" id="s-themes">
  <div class="hdr">
    <button class="hdr-back" onclick="SFX.play('screenBack');showScreen('s-settings','back')">‹</button>
    <div>
      <div class="hdr-title">Тема оформления</div>
      <div class="hdr-sub" id="theme-screen-sub">Выбери цветовую схему</div>
    </div>
  </div>
  <div class="body">
    <div class="theme-grid" id="theme-grid-screen"></div>

    <!-- Выбор иконки приложения -->
    <div id="icon-picker-section">
      <div class="section-label" style="margin-top:16px;margin-bottom:8px">Иконка приложения</div>
      <div class="theme-grid" id="icon-grid-screen"></div>
    </div>
  </div>
</div>

<!-- ══ Секретные эффекты ══ -->
<canvas id="matrix-canvas"></canvas>
<canvas id="snow-canvas" style="display:none"></canvas>
<div id="disco-overlay"></div>

<!-- ГЛОБАЛЬНАЯ НИЖНЯЯ НАВИГАЦИЯ — вне .screen, чтобы backdrop-filter работал -->
<nav class="bottom-nav" id="global-bottom-nav">
  <button class="nav-item active" id="nav-home" onclick="SFX.play('navHome');goHome()">
    <span class="nav-icon">🏠</span><span>Главная</span></button>
  <button class="nav-item" id="nav-bells" onclick="SFX.play('navBells');navTo('s-bells','nav-bells')">
    <span class="nav-icon">🔔</span><span>Звонки</span></button>
  <button class="nav-item" id="nav-settings" onclick="SFX.play('navSettings');navTo('s-settings','nav-settings')">
    <span class="nav-icon">⚙️</span><span>Настройки</span></button>
</nav>

<!-- ══ Приветствие (показывается сразу) ══ -->
<div id="greeting-overlay" class="greeting-overlay">
  <div class="greet-particles" id="greet-particles"></div>
  <div class="greet-logo" id="greet-logo">📅</div>
  <div class="greet-main" id="greet-main"></div>
  <div class="greet-divider"></div>
  <div class="greet-sub" id="greet-sub">колледжа</div>
  <div class="greet-time" id="greet-time"></div>
</div>

<!-- ══ Секретная CMD-консоль ══ -->
<div class="cmd-overlay" id="cmd-overlay" style="display:none">
  <div class="cmd-titlebar">
    <div class="cmd-titlebar-dots">
      <div class="cmd-dot" style="background:#ff5f57"></div>
      <div class="cmd-dot" style="background:#febc2e"></div>
      <div class="cmd-dot" style="background:#28c840"></div>
    </div>
    <div class="cmd-title">Schedule App — Developer Console</div>
    <button class="cmd-close" onclick="cmdClose()">×</button>
  </div>
  <div class="cmd-body" id="cmd-body"></div>
  <div class="cmd-input-row">
    <span class="cmd-prompt-sym">C:\&gt;</span>
    <input class="cmd-input" id="cmd-input" autocomplete="off" autocorrect="off" spellcheck="false"
      placeholder="введи команду..." onkeydown="cmdKey(event)">
  </div>
</div>

<div class="toast" id="toast"></div>

<!-- ══ Секретная пасхалка — выбор игры (5 тапов по строке «Версия») ══ -->
<div class="egg-overlay" id="egg-overlay">
  <button class="egg-close" onclick="eggClose()">×</button>
  <button class="egg-back" id="egg-back" onclick="eggShowPicker()">‹</button>

  <!-- Пикер игр -->
  <div id="egg-picker" class="egg-picker">
    <div class="egg-title">🎮 Секретный режим</div>
    <div class="egg-sub">Ты нашёл пасхалку!<br>Убей время до пары 🎲</div>
    <div class="egg-picker-title">Выбери игру</div>
    <div class="egg-cards">
      <div class="egg-card" onclick="eggStartGame('snake')">
        <div class="egg-card-icon">🐍</div>
        <div class="egg-card-body">
          <div class="egg-card-name">Змейка</div>
          <div class="egg-card-desc">Ешь, расти, не врезайся в себя</div>
          <div class="egg-card-badge">v1.6.0 • свайп / d-pad</div>
        </div>
        <div class="egg-card-arrow">›</div>
      </div>
      <div class="egg-card" onclick="eggStartGame('ttt')">
        <div class="egg-card-icon">❌</div>
        <div class="egg-card-body">
          <div class="egg-card-name">Крестики-нолики</div>
          <div class="egg-card-desc">Против ИИ на minimax — попробуй выиграть</div>
          <div class="egg-card-badge">v1.7.0 • tap</div>
        </div>
        <div class="egg-card-arrow">›</div>
      </div>
      <div class="egg-card" onclick="eggStartGame('pong')">
        <div class="egg-card-icon">🏓</div>
        <div class="egg-card-body">
          <div class="egg-card-name">Пинг-понг</div>
          <div class="egg-card-desc">Отбивай мяч и не давай ему упасть</div>
          <div class="egg-card-badge">v1.8.0 • свайп</div>
        </div>
        <div class="egg-card-arrow">›</div>
      </div>
      <div class="egg-card" onclick="eggStartGame('tetris')">
        <div class="egg-card-icon">🧱</div>
        <div class="egg-card-body">
          <div class="egg-card-name">Тетрис</div>
          <div class="egg-card-desc">Укладывай фигуры, не заполняй экран</div>
          <div class="egg-card-badge">v1.9.0 • кнопки / свайп</div>
        </div>
        <div class="egg-card-arrow">›</div>
      </div>
      <div class="egg-card" onclick="eggStartGame('dino')">
        <div class="egg-card-icon">🦕</div>
        <div class="egg-card-body">
          <div class="egg-card-name">Динозаврик</div>
          <div class="egg-card-desc">Прыгай через кактусы, не умри</div>
          <div class="egg-card-badge egg-card-new">v2.0.0 ✦ НОВАЯ</div>
        </div>
        <div class="egg-card-arrow">›</div>
      </div>
      <div class="egg-card" onclick="eggStartGame('blockblast')">
        <div class="egg-card-icon">🟦</div>
        <div class="egg-card-body">
          <div class="egg-card-name">Block Blast</div>
          <div class="egg-card-desc">Перетаскивай блоки, заполняй линии</div>
          <div class="egg-card-badge egg-card-new">v2.0.0 ✦ НОВАЯ</div>
        </div>
        <div class="egg-card-arrow">›</div>
      </div>
      <div class="egg-card" onclick="eggStartGame('breakout')">
        <div class="egg-card-icon">🧱</div>
        <div class="egg-card-body">
          <div class="egg-card-name">Арканоид</div>
          <div class="egg-card-desc">Разбивай кирпичи мячом, не урони!</div>
          <div class="egg-card-badge egg-card-new">v2.1.0 ✦</div>
        </div>
        <div class="egg-card-arrow">›</div>
      </div>
      <div class="egg-card" onclick="eggStartGame('bubbles')">
        <div class="egg-card-icon">🫧</div>
        <div class="egg-card-body">
          <div class="egg-card-name">Пузыри</div>
          <div class="egg-card-desc">Лопай пузыри до того, как они исчезнут!</div>
          <div class="egg-card-badge egg-card-new">v2.2.0 ✦ НОВАЯ</div>
        </div>
        <div class="egg-card-arrow">›</div>
      </div>
      <div class="egg-card" onclick="eggStartGame('flappy')">
        <div class="egg-card-icon">🐦</div>
        <div class="egg-card-body">
          <div class="egg-card-name">Флаппи птица</div>
          <div class="egg-card-desc">Лети между трубами, не касайся!</div>
          <div class="egg-card-badge egg-card-new">v2.6.0 ✦ НОВАЯ</div>
        </div>
        <div class="egg-card-arrow">›</div>
      </div>
      <div class="egg-card" onclick="eggStartGame('2048')">
        <div class="egg-card-icon">🔢</div>
        <div class="egg-card-body">
          <div class="egg-card-name">2048</div>
          <div class="egg-card-desc">Складывай плитки, доберись до 2048!</div>
          <div class="egg-card-badge egg-card-new">v2.6.0 ✦ НОВАЯ</div>
        </div>
        <div class="egg-card-arrow">›</div>
      </div>
    </div>
  </div>

  <!-- Змейка -->
  <div id="egg-snake" class="egg-game" style="display:none">
    <div class="egg-game-title">🐍 Змейка</div>
    <div class="diff-picker">
      <button class="diff-btn" onclick="snakeDifficulty='easy';updateDiffBtns('snake');snakeRestart()">🐢 Легко</button>
      <button class="diff-btn active" onclick="snakeDifficulty='normal';updateDiffBtns('snake');snakeRestart()">⚡ Нормально</button>
      <button class="diff-btn" onclick="snakeDifficulty='hard';updateDiffBtns('snake');snakeRestart()">💀 Хардкор</button>
    </div>
    <div class="egg-score" id="snake-score-label">Счёт: 0 • Рекорд: 0</div>
    <canvas id="snake-canvas" style="border-radius:14px;border:1.5px solid var(--surface3);margin-top:10px;display:block;touch-action:none"></canvas>
    <div class="snake-dpad">
      <div></div>
      <div class="dpad-btn" ontouchstart="snakeDir(0,-1)" onclick="snakeDir(0,-1)">▲</div>
      <div></div>
      <div class="dpad-btn" ontouchstart="snakeDir(-1,0)" onclick="snakeDir(-1,0)">◀</div>
      <div class="dpad-btn" style="background:var(--surface3);font-size:12px;color:var(--muted)" ontouchstart="snakeTogglePause()" onclick="snakeTogglePause()">⏸</div>
      <div class="dpad-btn" ontouchstart="snakeDir(1,0)" onclick="snakeDir(1,0)">▶</div>
      <div></div>
      <div class="dpad-btn" ontouchstart="snakeDir(0,1)" onclick="snakeDir(0,1)">▼</div>
      <div></div>
    </div>
    <button class="btn btn-surface3" style="width:auto;padding:9px 22px;margin-top:10px;font-size:13px" onclick="snakeRestart()">🔄 Заново</button>
  </div>

  <!-- Крестики-нолики -->
  <div id="egg-ttt" class="egg-game" style="display:none">
    <div class="egg-game-title">❌ Крестики-нолики</div>
    <div class="ttt-scores">
      <div class="ttt-score-item"><div class="ttt-score-val" id="ttt-score-x">0</div><div>Ты (✕)</div></div>
      <div class="ttt-score-item"><div class="ttt-score-val" id="ttt-score-d">0</div><div>Ничья</div></div>
      <div class="ttt-score-item"><div class="ttt-score-val" id="ttt-score-o">0</div><div>ИИ (◯)</div></div>
    </div>
    <div class="ttt-board" id="ttt-board"></div>
    <div class="ttt-status" id="ttt-status">Твой ход — ставь ✕</div>
    <button class="btn btn-surface3" style="width:auto;padding:9px 22px;margin-top:14px;font-size:13px" onclick="tttRestart()">🔄 Заново</button>
  </div>

  <!-- Пинг-понг -->
  <div id="egg-pong" class="egg-game" style="display:none">
    <div class="egg-game-title">🏓 Пинг-понг</div>
    <div class="diff-picker">
      <button class="diff-btn" onclick="pongDifficulty='easy';updateDiffBtns('pong');pongRestart()">🐢 Легко</button>
      <button class="diff-btn active" onclick="pongDifficulty='normal';updateDiffBtns('pong');pongRestart()">⚡ Нормально</button>
      <button class="diff-btn" onclick="pongDifficulty='hard';updateDiffBtns('pong');pongRestart()">💀 Хардкор</button>
    </div>
    <div class="egg-score" id="pong-score-label">Счёт: 0 • Рекорд: 0</div>
    <canvas id="pong-canvas" style="border-radius:14px;border:1.5px solid var(--surface3);margin-top:10px;display:block;touch-action:none"></canvas>
    <button class="btn btn-surface3" style="width:auto;padding:9px 22px;margin-top:10px;font-size:13px" onclick="pongRestart()">🔄 Заново</button>
  </div>

  <!-- Тетрис -->
  <div id="egg-tetris" class="egg-game" style="display:none">
    <div class="egg-game-title">🧱 Тетрис</div>
    <div class="diff-picker">
      <button class="diff-btn" onclick="tetDifficulty='easy';updateDiffBtns('tetris');tetRestart()">🐢 Легко</button>
      <button class="diff-btn active" onclick="tetDifficulty='normal';updateDiffBtns('tetris');tetRestart()">⚡ Нормально</button>
      <button class="diff-btn" onclick="tetDifficulty='hard';updateDiffBtns('tetris');tetRestart()">💀 Хардкор</button>
    </div>
    <div class="egg-score" id="tet-score-label">Счёт: 0 • Рекорд: 0 • Уровень: 1</div>
    <canvas id="tet-canvas" style="border-radius:14px;border:1.5px solid var(--surface3);margin-top:10px;display:block;touch-action:none"></canvas>
    <div class="tet-controls">
      <button class="tet-btn" ontouchstart="tetMove(-1)" onclick="tetMove(-1)">◀</button>
      <button class="tet-btn tet-btn-wide" ontouchstart="tetRotate()" onclick="tetRotate()">↻</button>
      <button class="tet-btn" ontouchstart="tetMove(1)" onclick="tetMove(1)">▶</button>
      <button class="tet-btn tet-btn-wide" ontouchstart="tetDrop()" onclick="tetDrop()">⬇</button>
    </div>
    <button class="btn btn-surface3" style="width:auto;padding:9px 22px;margin-top:10px;font-size:13px" onclick="tetRestart()">🔄 Заново</button>
  </div>

  <!-- Дино -->
  <div id="egg-dino" class="egg-game" style="display:none">
    <div class="egg-game-title">🦕 Динозаврик</div>
    <div class="diff-picker">
      <button class="diff-btn" onclick="dinoDifficulty='easy';updateDiffBtns('dino');dinoRestart()">🐢 Легко</button>
      <button class="diff-btn active" onclick="dinoDifficulty='normal';updateDiffBtns('dino');dinoRestart()">⚡ Нормально</button>
      <button class="diff-btn" onclick="dinoDifficulty='hard';updateDiffBtns('dino');dinoRestart()">💀 Хардкор</button>
    </div>
    <div class="egg-score" id="dino-score-label">Счёт: 0 • Рекорд: 0</div>
    <canvas id="dino-canvas" style="border-radius:14px;border:1.5px solid var(--surface3);margin-top:10px;display:block;touch-action:none"></canvas>
    <button class="btn btn-surface3" style="width:auto;padding:9px 22px;margin-top:10px;font-size:13px" onclick="dinoRestart()">🔄 Заново</button>
  </div>

  <!-- BlockBlast -->
  <div id="egg-blockblast" class="egg-game" style="display:none">
    <div class="egg-game-title">🟦 Block Blast</div>
    <div class="diff-picker">
      <button class="diff-btn" onclick="bbDifficulty='easy';updateDiffBtns('blockblast')">🐢 Легко</button>
      <button class="diff-btn active" onclick="bbDifficulty='normal';updateDiffBtns('blockblast')">⚡ Нормально</button>
      <button class="diff-btn" onclick="bbDifficulty='hard';updateDiffBtns('blockblast')">💀 Хардкор</button>
    </div>
    <div class="egg-score" id="bb-score-label">Счёт: 0 • Рекорд: 0</div>
    <div id="bb-board-wrap" style="margin-top:10px;display:flex;justify-content:center"></div>
    <div style="font-size:11px;color:var(--muted);text-align:center;margin-top:6px">Перетаскивай фигуры на поле</div>
    <div id="bb-pieces-wrap" style="display:flex;gap:10px;justify-content:center;align-items:flex-end;margin-top:8px;min-height:80px"></div>
    <button class="btn btn-surface3" style="width:auto;padding:9px 22px;margin-top:10px;font-size:13px" onclick="bbRestart()">🔄 Заново</button>
  </div>

  <!-- Арканоид -->
  <div id="egg-breakout" class="egg-game" style="display:none">
    <div class="egg-game-title">🧱 Арканоид</div>
    <div class="diff-picker">
      <button class="diff-btn" onclick="brDifficulty='easy';updateDiffBtns('breakout')">🐢 Легко</button>
      <button class="diff-btn active" onclick="brDifficulty='normal';updateDiffBtns('breakout')">⚡ Нормально</button>
      <button class="diff-btn" onclick="brDifficulty='hard';updateDiffBtns('breakout')">💀 Хардкор</button>
    </div>
    <div class="egg-score" id="br-score-label">Счёт: 0 • Рекорд: 0 • Жизни: ❤️❤️❤️</div>
    <canvas id="br-canvas" style="border-radius:14px;border:1.5px solid var(--surface3);margin-top:10px;display:block;touch-action:none"></canvas>
    <button class="btn btn-surface3" style="width:auto;padding:9px 22px;margin-top:10px;font-size:13px" onclick="brRestart()">🔄 Заново</button>
  </div>

  <!-- Пузыри -->
  <div id="egg-bubbles" class="egg-game" style="display:none">
    <div class="egg-game-title">🫧 Пузыри</div>
    <div class="diff-picker">
      <button class="diff-btn" onclick="bubDifficulty='easy';updateDiffBtns('bubbles')">🐢 Легко</button>
      <button class="diff-btn active" onclick="bubDifficulty='normal';updateDiffBtns('bubbles')">⚡ Нормально</button>
      <button class="diff-btn" onclick="bubDifficulty='hard';updateDiffBtns('bubbles')">💀 Хардкор</button>
    </div>
    <div class="egg-score" id="bub-score-label">Счёт: 0 • Рекорд: 0 • Жизни: ❤️❤️❤️</div>
    <canvas id="bub-canvas" style="border-radius:14px;border:1.5px solid var(--surface3);margin-top:8px;display:block;touch-action:none"></canvas>
    <button class="btn btn-surface3" style="width:auto;padding:9px 22px;margin-top:10px;font-size:13px" onclick="bubRestart()">🔄 Заново</button>
  </div>

  <!-- Флаппи птица -->
  <div id="egg-flappy" class="egg-game" style="display:none">
    <div class="egg-game-title">🐦 Флаппи птица</div>
    <div class="egg-score" id="flappy-score-label">Счёт: 0 • Рекорд: 0</div>
    <canvas id="flappy-canvas" style="border-radius:14px;border:1.5px solid var(--surface3);margin-top:8px;display:block;touch-action:none"></canvas>
    <div style="font-size:11px;color:var(--muted);text-align:center;margin-top:8px">тап / пробел — взмах</div>
  </div>

  <!-- 2048 -->
  <div id="egg-2048" class="egg-game" style="display:none">
    <div class="egg-game-title">🔢 2048</div>
    <div class="egg-score" id="g2048-score-label">Счёт: 0 • Рекорд: 0</div>
    <div id="g2048-board" style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;width:min(300px,85vw);margin:12px auto 0;touch-action:none"></div>
    <div style="font-size:11px;color:var(--muted);text-align:center;margin-top:10px">свайп или стрелки — двигать плитки</div>
    <button class="btn btn-surface3" style="width:auto;padding:9px 22px;margin-top:10px;font-size:13px" onclick="g2048Restart()">🔄 Заново</button>
  </div>

</div>

<!-- ══ Модальное окно обновления (в стиле приложения) ══ -->
<div class="ota-overlay" id="ota-overlay" onclick="otaOverlayClose(event)">
  <div class="ota-sheet" id="ota-sheet">
    <div class="ota-handle"></div>
    <div class="ota-icon">⬆️</div>
    <div class="ota-title">Доступно обновление</div>
    <div class="ota-version" id="ota-version-label"></div>
    <div class="ota-notes" id="ota-notes-text"></div>

    <!-- Прогресс-бар (скрыт до скачивания) -->
    <div class="ota-progress-wrap hidden" id="ota-progress-wrap">
      <div class="ota-progress-track">
        <div class="ota-progress-bar" id="ota-progress-bar"></div>
      </div>
      <div class="ota-progress-label" id="ota-progress-label">Скачивание...</div>
    </div>

    <button class="btn btn-accent" id="ota-dl-btn" onclick="otaStartDownload()">⬇ Скачать и установить</button>
    <button class="btn btn-surface" id="ota-cancel-btn" onclick="otaClose()" style="margin-top:8px">Позже</button>
  </div>
</div>

<script>
// ══ Глобальные переменные — объявлены в начале во избежание TDZ ══
var _otaApkUrl = '', _otaVersion = '';
var _eggTaps = 0, _eggTimer = null, _eggLastTouch = 0;
var _discoActive = false;
// ══ ПОЛИФИЛ AbortSignal.timeout ══
// AbortSignal.timeout появился в Chrome 103 (2022).
// На Android с устаревшим WebView его нет — без полифила приложение крашит.
if (typeof AbortSignal !== 'undefined' && !AbortSignal.timeout) {
  AbortSignal.timeout = function(ms) {
    var ctrl = new AbortController();
    setTimeout(function() {
      ctrl.abort(new DOMException('TimeoutError', 'TimeoutError'));
    }, ms);
    return ctrl.signal;
  };
}

// ══════════════════════════════════════════════════════════════════
// Карта падежных форм дней недели → именительный падеж
const DAY_NOMINATIVE={
  'ПОНЕДЕЛЬНИК':'ПОНЕДЕЛЬНИК','ПОНЕДЕЛЬНИКА':'ПОНЕДЕЛЬНИК','ПОНЕДЕЛЬНИКУ':'ПОНЕДЕЛЬНИК',
  'ВТОРНИК':'ВТОРНИК','ВТОРНИКА':'ВТОРНИК','ВТОРНИКУ':'ВТОРНИК',
  'СРЕДУ':'СРЕДА','СРЕДЫ':'СРЕДА','СРЕДЕ':'СРЕДА','СРЕДА':'СРЕДА',
  'ЧЕТВЕРГ':'ЧЕТВЕРГ','ЧЕТВЕРГА':'ЧЕТВЕРГ','ЧЕТВЕРГУ':'ЧЕТВЕРГ',
  'ПЯТНИЦУ':'ПЯТНИЦА','ПЯТНИЦЫ':'ПЯТНИЦА','ПЯТНИЦЕ':'ПЯТНИЦА','ПЯТНИЦА':'ПЯТНИЦА',
  'СУББОТУ':'СУББОТА','СУББОТЫ':'СУББОТА','СУББОТЕ':'СУББОТА','СУББОТА':'СУББОТА',
  'ВОСКРЕСЕНЬЕ':'ВОСКРЕСЕНЬЕ','ВОСКРЕСЕНЬЯ':'ВОСКРЕСЕНЬЕ','ВОСКРЕСЕНЬЮ':'ВОСКРЕСЕНЬЕ',
};
function formatScheduleDate(hdr){
  // Ищем в строке: ДеньНедели ДД.ММ.ГГГГ (неделя)
  const m=hdr.match(/([А-ЯЁа-яё]+)\s+(\d{2}\.\d{2}\.\d{4})\s*(\([^)]*\))?/);
  if(m){
    const dayRaw=m[1].toUpperCase();
    const day=DAY_NOMINATIVE[dayRaw]||dayRaw;
    const date=m[2];
    const week=m[3]||'';
    return [day,date,week].filter(Boolean).join(' ');
  }
  // Запасной вариант: убираем служебный префикс и мусор
  return hdr.replace('Расписание занятий на ','')
    .replace(/[^\u0401\u0410-\u044F\u0451\d\s.,()]/g,'')
    .replace(/\s{2,}/g,' ').trim();
}
// ── 🔊 ЗВУКОВАЯ СИСТЕМА (Web Audio API, синтетическая) ───────────
// ══════════════════════════════════════════════════════════════════
const SFX = (() => {
  let ctx = null;
  let muted = true; // по дефолту выключено

  function ac() {
    if (!ctx) { try { ctx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) {} }
    if (ctx && ctx.state === 'suspended') ctx.resume();
    return ctx;
  }
  const V = 0.5;
  function tone(freq, type, attack, sustain, release, vol=0.18) {
    const c = ac(); if (!c || muted) return;
    const g = c.createGain(), o = c.createOscillator();
    o.type = type; o.frequency.value = freq;
    const v = vol * V;
    g.gain.setValueAtTime(0, c.currentTime);
    g.gain.linearRampToValueAtTime(v, c.currentTime + attack);
    g.gain.setValueAtTime(v, c.currentTime + attack + sustain);
    g.gain.exponentialRampToValueAtTime(0.0001, c.currentTime + attack + sustain + release);
    o.connect(g); g.connect(c.destination);
    o.start(c.currentTime); o.stop(c.currentTime + attack + sustain + release + 0.05);
  }
  function sweep(f0, f1, type, dur, vol=0.15) {
    const c = ac(); if (!c || muted) return;
    const g = c.createGain(), o = c.createOscillator();
    o.type = type;
    o.frequency.setValueAtTime(f0, c.currentTime);
    o.frequency.exponentialRampToValueAtTime(f1, c.currentTime + dur * 0.85);
    const v = vol * V;
    g.gain.setValueAtTime(v, c.currentTime);
    g.gain.exponentialRampToValueAtTime(0.0001, c.currentTime + dur);
    o.connect(g); g.connect(c.destination);
    o.start(c.currentTime); o.stop(c.currentTime + dur + 0.05);
  }
  function noise(dur, vol=0.08, lpFreq=800) {
    const c = ac(); if (!c || muted) return;
    const bufSize = Math.floor(c.sampleRate * dur);
    const buf = c.createBuffer(1, bufSize, c.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1);
    const src = c.createBufferSource(); src.buffer = buf;
    const filt = c.createBiquadFilter();
    filt.type = 'lowpass'; filt.frequency.value = lpFreq;
    const g = c.createGain();
    const v = vol * V;
    g.gain.setValueAtTime(v, c.currentTime);
    g.gain.exponentialRampToValueAtTime(0.0001, c.currentTime + dur);
    src.connect(filt); filt.connect(g); g.connect(c.destination);
    src.start(); src.stop(c.currentTime + dur + 0.05);
  }
  const after = (fn, ms) => setTimeout(fn, ms);

  const sounds = {
    // Навигация — мягкие, низкие, тёплые
    navHome()     { tone(220,'sine',.03,.06,.28,.10); after(()=>tone(330,'sine',.03,.04,.22,.06),80); },
    navBells()    { tone(440,'sine',.02,.06,.38,.09); after(()=>tone(660,'sine',.02,.03,.28,.05),70); },
    navSettings() { tone(180,'triangle',.03,.05,.22,.08); after(()=>tone(240,'triangle',.03,.03,.18,.05),90); },
    screenPush()  { sweep(200,300,'sine',.14,.08); },
    screenBack()  { sweep(300,180,'sine',.12,.08); },
    themeSelect() { [330,415,494].forEach((f,i)=>after(()=>tone(f,'sine',.02,.06,.26,.07),i*70)); },
    // Кнопки — почти неслышные тихие касания
    btnClick()    { noise(.025,.018,500); tone(280,'sine',.008,.01,.10,.03); },
    btnAccent()   { sweep(220,360,'sine',.15,.08); },
    keyTap()      { noise(.015,.012,400); },
    // Тост / статус
    toastShow()   { tone(440,'sine',.015,.04,.24,.07); after(()=>tone(550,'sine',.015,.02,.18,.04),90); },
    success()     { [330,415,494,660].forEach((f,i)=>after(()=>tone(f,'sine',.02,.06,.28,.06),i*80)); },
    error()       { tone(160,'triangle',.02,.10,.22,.08); after(()=>tone(130,'triangle',.02,.08,.22,.07),140); },
    // Пасхалка / игры
    eggOpen()     { [196,247,294,370,494].forEach((f,i)=>after(()=>tone(f,'sine',.02,.06,.30,.06),i*70)); },
    gameSelect()  { sweep(280,420,'sine',.12,.08); },
    // ── Змейка ──
    snakeEat()    { tone(440,'sine',.01,.03,.14,.07); after(()=>tone(550,'sine',.01,.02,.10,.04),60); },
    snakeDie()    { sweep(300,80,'sine',.42,.09); after(()=>noise(.20,.04,350),120); },
    snakeTurn()   { noise(.018,.014,600); },
    // ── Крестики-нолики ──
    tttPlace()    { tone(360,'sine',.01,.03,.18,.06); },
    tttWin()      { [330,415,494,660,830].forEach((f,i)=>after(()=>tone(f,'sine',.02,.06,.28,.07),i*90)); },
    tttLose()     { sweep(280,120,'sine',.52,.09); },
    tttDraw()     { tone(330,'sine',.02,.18,.28,.06); },
    // ── Пинг-понг ──
    pongHit()     { noise(.018,.04,800); tone(440,'sine',.005,.01,.08,.04); },
    pongWall()    { noise(.014,.03,600); },
    pongScore()   { sweep(240,420,'sine',.18,.08); },
    pongLose()    { sweep(360,100,'sine',.36,.09); },
    // ── Тетрис ──
    tetMove()     { noise(.014,.022,700); },
    tetRotate()   { tone(330,'sine',.01,.02,.12,.05); },
    tetLine()     { [294,370,440,587].forEach((f,i)=>after(()=>tone(f,'sine',.01,.05,.20,.07),i*55)); },
    tetDrop()     { noise(.040,.05,500); tone(120,'sine',.01,.04,.16,.07); },
    tetGameOver() { [330,277,233,196].forEach((f,i)=>after(()=>tone(f,'triangle',.02,.10,.28,.08),i*110)); },
    // ── Дино ──
    dinoJump()    { sweep(220,380,'sine',.15,.07); },
    dinoCactus()  { noise(.050,.06,450); tone(140,'triangle',.01,.06,.18,.07); },
    dinoScore()   { tone(550,'sine',.008,.01,.12,.05); },
    // ── Block Blast ──
    bbPlace()     { tone(280,'sine',.01,.03,.14,.06); },
    bbLine()      { [330,415,494].forEach((f,i)=>after(()=>tone(f,'sine',.01,.06,.22,.07),i*60)); },
    bbGameOver()  { sweep(240,80,'sine',.50,.09); },
    // ── Арканоид ──
    brBrick()     { noise(.020,.05,1000); tone(440,'sine',.004,.01,.09,.04); },
    brWall()      { noise(.016,.035,700); },
    brPaddle()    { noise(.020,.04,800); tone(360,'sine',.005,.01,.08,.04); },
    brLive()      { sweep(420,160,'sine',.32,.09); },
    brLevelUp()   { [294,370,440,587].forEach((f,i)=>after(()=>tone(f,'sine',.02,.06,.26,.07),i*65)); },
    // ── Пузыри ──
    bubPop() {
      const c = ac(); if (!c || muted) return;
      // Слоёный поп: основной «влажный» щелчок + призвук
      const o = c.createOscillator(), g = c.createGain();
      o.type = 'sine';
      const bf = 180 + Math.random() * 120;
      o.frequency.setValueAtTime(bf * 2.2, c.currentTime);
      o.frequency.exponentialRampToValueAtTime(bf * 0.35, c.currentTime + 0.10);
      const v = 0.13 * V;
      g.gain.setValueAtTime(v, c.currentTime);
      g.gain.linearRampToValueAtTime(v * 1.1, c.currentTime + 0.015);
      g.gain.exponentialRampToValueAtTime(0.0001, c.currentTime + 0.22);
      o.connect(g); g.connect(c.destination);
      o.start(); o.stop(c.currentTime + 0.26);
      // Шлепок воздуха
      noise(0.035, 0.05, 320);
    },
    bubMiss()     { sweep(140, 80, 'sine', 0.28, 0.07); after(() => noise(0.04, 0.03, 250), 60); },
    bubCombo()    { [280, 350, 470].forEach((f,i) => after(() => tone(f, 'sine', 0.02, 0.05, 0.22, 0.07), i*55)); },
  };

  return {
    play(name) { try { if (sounds[name]) sounds[name](); } catch(e){} },
    toggle()   { muted = !muted; return muted; },
    isMuted()  { return muted; },
    init()     { ac(); }
  };
})();

// Разблокировать AudioContext при первом жесте
document.addEventListener('click',      () => SFX.init(), {once:true});
document.addEventListener('touchstart', () => SFX.init(), {once:true});

// ── Глобальный btnClick на все кнопки без явного SFX ────────────
document.addEventListener('pointerdown', e => {
  const el = e.target.closest('button,a,[role=button],.btn,.nav-item,.hdr-back,.list-item,.theme-card,.egg-card,.diff-btn,.dpad-btn,.ttt-cell,.dino-ctrl-btn');
  if (!el) return;
  const hasExplicit = el.onclick && ('' + el.onclick).includes('SFX.play');
  if (!hasExplicit) SFX.play('btnClick');
  if (e.target.matches('input,textarea')) SFX.play('keyTap');
});

function toggleMute(){
  const m = SFX.toggle();
  const lbl = document.getElementById('mute-label');
  if (lbl) lbl.textContent = m ? '🔇 Звук выключен' : '🔊 Звук включён';
  if (!m) SFX.play('btnClick');
}
function updateMuteLabel(){
  const el = document.getElementById('mute-label');
  if (el) el.textContent = SFX.isMuted() ? '🔇 Звук выключен' : '🔊 Звук включён';
}

// ══ RIPPLE ══
document.addEventListener('click',function(e){
  const el=e.target.closest('.btn,.hdr-back,.last-group-btn,.nav-item,.theme-card,.list-item,.dns-card,.dpi-item,.theme-card');
  if(!el)return;
  const r=document.createElement('span');
  r.className='ripple';
  const rect=el.getBoundingClientRect();
  const size=Math.max(rect.width,rect.height)*2;
  r.style.cssText=`width:${size}px;height:${size}px;left:${e.clientX-rect.left-size/2}px;top:${e.clientY-rect.top-size/2}px`;
  el.appendChild(r);
  setTimeout(()=>r.remove(),560);
});

// ══ ТЕМЫ ══
const THEMES={
  'orange': {name:'Колледж',  ico:'🟠', vars:{'--bg':'#0d0d0d','--surface':'#161616','--surface2':'#1f1f1f','--surface3':'#2a2a2a','--accent':'#e87722','--accent2':'#c45f0a','--text':'#f0ede8','--muted':'#6b6762'},sw:['#0d0d0d','#e87722','#c45f0a']},
  'amoled': {name:'AMOLED',   ico:'⚫', vars:{'--bg':'#000','--surface':'#080808','--surface2':'#111','--surface3':'#1a1a1a','--accent':'#00e5ff','--accent2':'#00acc1','--text':'#fff','--muted':'#505050'},sw:['#000','#00e5ff','#00acc1']},
  'win11':  {name:'Win 11',   ico:'🔵', vars:{'--bg':'#1a1a1a','--surface':'#222','--surface2':'#2d2d2d','--surface3':'#383838','--accent':'#60cdff','--accent2':'#0067c0','--text':'#fff','--muted':'#888'},sw:['#1a1a1a','#60cdff','#0067c0']},
  'pixel':  {name:'Material', ico:'🟣', vars:{'--bg':'#191c1e','--surface':'#22272a','--surface2':'#2c3237','--surface3':'#373d44','--accent':'#7fcfff','--accent2':'#2f71d4','--text':'#e3e5e8','--muted':'#8e9099'},sw:['#191c1e','#7fcfff','#2f71d4']},
  'aero':   {name:'Aero',     ico:'💎', vars:{'--bg':'#152030','--surface':'#1a2d44','--surface2':'#1f3755','--surface3':'#274466','--accent':'#7fd7ff','--accent2':'#00a8e8','--text':'#e8f4ff','--muted':'#7a9ab8'},sw:['#152030','#7fd7ff','#00a8e8']},
  'forest': {name:'Лес',      ico:'🌿', vars:{'--bg':'#0b1a10','--surface':'#111f15','--surface2':'#182a1d','--surface3':'#213627','--accent':'#4caf7d','--accent2':'#2d8653','--text':'#e0f0e8','--muted':'#6a9076'},sw:['#0b1a10','#4caf7d','#2d8653']},
  'rose':   {name:'Розовый',  ico:'🌸', vars:{'--bg':'#1a0d12','--surface':'#24111a','--surface2':'#2e1622','--surface3':'#3a1e2d','--accent':'#f472b6','--accent2':'#db2777','--text':'#fce7f3','--muted':'#9d6b80'},sw:['#1a0d12','#f472b6','#db2777']},
  'gold':   {name:'Золото',   ico:'✨', vars:{'--bg':'#100e00','--surface':'#1a1700','--surface2':'#222000','--surface3':'#2e2a00','--accent':'#f5c518','--accent2':'#c9a000','--text':'#fff9e6','--muted':'#7a7050'},sw:['#100e00','#f5c518','#c9a000']},
  'purple': {name:'Фиолет',   ico:'🫐', vars:{'--bg':'#0e0b1a','--surface':'#151025','--surface2':'#1c1630','--surface3':'#251e3d','--accent':'#a78bfa','--accent2':'#7c3aed','--text':'#ede9fe','--muted':'#7060a0'},sw:['#0e0b1a','#a78bfa','#7c3aed']},
  'sunset': {name:'Закат',    ico:'🌅', vars:{'--bg':'#0f0a00','--surface':'#1a1000','--surface2':'#241800','--surface3':'#302200','--accent':'#ff6b35','--accent2':'#c94a10','--text':'#fff3ee','--muted':'#7a5040'},sw:['#0f0a00','#ff6b35','#c94a10']},
  'bw':     {name:'Ч/Б',      ico:'⬜', vars:{'--bg':'#000','--surface':'#111','--surface2':'#1c1c1c','--surface3':'#2a2a2a','--accent':'#ffffff','--accent2':'#cccccc','--text':'#ffffff','--muted':'#666666'},sw:['#000','#fff','#888']},
  'glass':  {name:'Liquid Glass', ico:'🫧', vars:{'--bg':'#0a0f1e','--surface':'rgba(255,255,255,0.07)','--surface2':'rgba(255,255,255,0.11)','--surface3':'rgba(255,255,255,0.18)','--accent':'#a0c4ff','--accent2':'#7b9fff','--text':'#f0f4ff','--muted':'rgba(180,190,220,0.7)'},sw:['#0a0f1e','#a0c4ff','#7b9fff']},
  'light':  {name:'Светлая',  ico:'☀️', vars:{'--bg':'#f4f4f4','--surface':'#fff','--surface2':'#ebebeb','--surface3':'#d8d8d8','--accent':'#e87722','--accent2':'#c45f0a','--text':'#111','--muted':'#888'},sw:['#f4f4f4','#e87722','#c45f0a']},
};

// ══ DNS провайдеры ══
const DNS_PROVIDERS={
  'system': {name:'Системный',  addr:'по умолчанию', ico:'🌐', doh:''},
  'cf':     {name:'Cloudflare', addr:'1.1.1.1',       ico:'🟠', doh:'https://1.1.1.1/dns-query'},
  'google': {name:'Google',     addr:'8.8.8.8',       ico:'🔵', doh:'https://8.8.8.8/dns-query'},
  'adguard':{name:'AdGuard',    addr:'94.140.14.14',  ico:'🟢', doh:'https://dns.adguard.com/dns-query'},
  'yandex': {name:'Яндекс',     addr:'77.88.8.8',     ico:'🔴', doh:'https://common.dot.dns.yandex.net/dns-query'},
  'custom': {name:'Свой...',    addr:'DoH URL',       ico:'⚙️', doh:'custom'},
};

// ══ ПРОКСИ провайдеры ══
// format:
//   'append_encoded' → proxy_url + encodeURIComponent(target)
//   'append_raw'     → proxy_url + target (URL не кодируется)
//   'query_url'      → proxy_url + encodeURIComponent(target) (то же что append_encoded, другой ключ)
const PROXY_PROVIDERS = {
  'allorigins': {
    name: 'AllOrigins',
    addr: 'api.allorigins.win',
    ico: '🔓',
    tag: 'tag-free',
    tagText: 'бесплатно',
    desc: 'Стабильный публичный прокси. Бинарные файлы через base64.',
    url: 'https://api.allorigins.win/raw?url=',
    format: 'query_url',
  },
  'corsproxy': {
    name: 'corsproxy.io',
    addr: 'corsproxy.io',
    ico: '🌐',
    tag: 'tag-free',
    tagText: 'бесплатно',
    desc: 'Быстрый. Может требовать ожидания при лимите.',
    url: 'https://corsproxy.io/?url=',
    format: 'query_url',
  },
  'codetabs': {
    name: 'CodeTabs',
    addr: 'api.codetabs.com',
    ico: '📦',
    tag: 'tag-free',
    tagText: 'бесплатно',
    desc: 'Без авторизации, поддерживает бинарные файлы.',
    url: 'https://api.codetabs.com/v1/proxy?quest=',
    format: 'append_raw',
  },
  'thingproxy': {
    name: 'ThingProxy',
    addr: 'thingproxy.freeboard.io',
    ico: '🔁',
    tag: 'tag-free',
    tagText: 'бесплатно',
    desc: 'Простой CORS-прокси без ограничений по типу.',
    url: 'https://thingproxy.freeboard.io/fetch/',
    format: 'append_raw',
  },
  'corsanywhere': {
    name: 'CORS Anywhere',
    addr: 'cors-anywhere.herokuapp.com',
    ico: '🌍',
    tag: 'tag-limit',
    tagText: 'нужен запрос',
    desc: 'Нужно открыть сайт и нажать Request Access.',
    url: 'https://cors-anywhere.herokuapp.com/',
    format: 'append_raw',
  },
  'cf_worker': {
    name: 'Cloudflare Worker',
    addr: 'your-proxy.workers.dev',
    ico: '☁️',
    tag: 'tag-own',
    tagText: 'свой',
    desc: 'Самый надёжный. Деплой за 5 мин, 100k/день бесплатно.',
    url: '',
    format: 'append_encoded',
  },
  'custom': {
    name: 'Свой URL',
    addr: 'любой адрес',
    ico: '⚙️',
    tag: 'tag-own',
    tagText: 'свой',
    desc: 'Введи адрес своего прокси вручную.',
    url: '',
    format: 'append_encoded',
  },
};

// ══ DPI стратегии (на основе ByeByeDPI) ══
// cmd — аргументы для ciadpi, передаются в DnsVpnService
// {sni} заменяется на www.iana.org
const DPI_STRATEGIES = [
  {id:'auto',       badge:'AUTO',   name:'Авто (рекомендуется)', cmd:'-Ku -a1 -An -o1 -At,r,s -d1',
    desc:'Базовые настройки ByeByeDPI. Попробуй первым.'},
  {id:'preset1',    badge:'P-1',    name:'Preset 1 — multisplit',
    cmd:'-f-200 -Qr -s3:5+sm -a1 -As -d1 -s4+sm -s8+sh -f-300 -d6+sh -a1 -At,r,s -o2 -f-30 -As -r5 -Mh -r6+sh -f-250 -s2:7+s -s3:6+sm -a1 -At,r,s -s3:5+sm -s6+s -s7:9+s -q30+sm -a1',
    desc:'Многосегментное разделение. Хорош для многих провайдеров.'},
  {id:'preset2',    badge:'P-2',    name:'Preset 2 — disorder split',
    cmd:'-d1 -d3+s -s6+s -d9+s -s12+s -d15+s -s20+s -d25+s -s30+s -d35+s -r1+s -S -a1 -As -d1 -d3+s -s6+s -d9+s -s12+s -d15+s -s20+s -d25+s -s30+s -d35+s -S -a1',
    desc:'Чередование disorder и split по позициям.'},
  {id:'preset3',    badge:'P-3',    name:'Preset 3 — OOB + mixedcase',
    cmd:'-q2 -s2 -s3+s -r3 -s4 -r4 -s5+s -r5+s -s6 -s7+s -r8 -s9+s -Qr -Mh,d,r -a1 -At,r -s2+s -r2 -d2 -s3 -r3 -r4 -s4 -d5+s -r5 -d6 -s7+s -d7 -a1',
    desc:'OOB с перемешиванием регистра и разделением.'},
  {id:'preset4',    badge:'P-4',    name:'Preset 4 — S+disorder combo',
    cmd:'-o1 -d1 -a1 -At,r,s -s1 -d1 -s5+s -s10+s -s15+s -s20+s -r1+s -S -a1 -As -s1 -d1 -s5+s -s10+s -s15+s -s20+s -S -a1',
    desc:'Комбинация OOB и disorder со множеством позиций.'},
  {id:'preset5',    badge:'P-5',    name:'Preset 5 — Fake TLS + split',
    cmd:'-n www.iana.org -Qr -f-204 -s1:5+sm -a1 -As -d1 -s3+s -s5+s -q7 -a1 -As -o2 -f-43 -a1 -As -r5 -Mh -s1:5+s -s3:7+sm -a1',
    desc:'Поддельный TLS пакет + многосегментное разделение.'},
  {id:'preset6',    badge:'P-6',    name:'Preset 6 — Fake TLS variant',
    cmd:'-n www.iana.org -Qr -f-205 -a1 -As -s1:3+sm -a1 -As -s5:8+sm -a1 -As -d3 -q7 -o2 -f-43 -f-85 -f-165 -r5 -Mh -a1',
    desc:'Другой вариант fake TLS с разными смещениями.'},
  {id:'preset7',    badge:'P-7',    name:'Preset 7 — big split+fake',
    cmd:'-d1+s -s50+s -a1 -As -f20 -r2+s -a1 -At -d2 -s1+s -s5+s -s10+s -s15+s -s25+s -s35+s -s50+s -s60+s -a1',
    desc:'Крупные сегменты разделения + fake пакеты.'},
  {id:'preset8',    badge:'P-8',    name:'Preset 8 — SNI fake + S chain',
    cmd:'-o1 -a1 -At,r,s -f-1 -a1 -At,r,s -d1:11+sm -S -a1 -At,r,s -n www.iana.org -Qr -f1 -d1:11+sm -s1:11+sm -S -a1',
    desc:'Цепочка SNI-fake и многосегментного S.'},
  {id:'preset9',    badge:'P-9',    name:'Preset 9 — SACK drop',
    cmd:'-d1 -s1 -q1 -Y -a1 -Ar -s5 -o1+s -d3+s -s6+s -d9+s -s12+s -d15+s -s20+s -d25+s -s30+s -d35+s -a1',
    desc:'Отключение SACK + disorder по всем позициям.'},
  {id:'preset10',   badge:'P-10',   name:'Preset 10 — Fake+TLSrec+Mh',
    cmd:'-f1+nme -t6 -a1 -As -n www.iana.org -Qr -s1:6+sm -a1 -As -s5:12+sm -a1 -As -d3 -q7 -r6 -Mh -a1',
    desc:'Fake с TLS-record split и смешанным регистром.'},
  {id:'preset11',   badge:'P-11',   name:'Preset 11 — OOB SACK chain A',
    cmd:'-s1 -o1 -a1 -Y -Ar -s5 -o1+s -a1 -At -f-1 -r1+s -a1 -As -s1 -o1+s -s-1 -a1',
    desc:'Цепочка OOB с SACK drop.'},
  {id:'preset12',   badge:'P-12',   name:'Preset 12 — OOB SACK chain B',
    cmd:'-s1 -d1 -a1 -Y -Ar -d5 -o1+s -a1 -At -f-1 -r1+s -a1 -As -d1 -o1+s -s-1 -a1',
    desc:'Вариант цепочки OOB+SACK с disorder.'},
  {id:'preset13',   badge:'P-13',   name:'Preset 13 — light disorder',
    cmd:'-d1 -s1+s -d3+s -s6+s -d9+s -s12+s -d15+s -s20+s -d25+s -s30+s -d35+s -a1',
    desc:'Лёгкий disorder по нарастающим позициям.'},
  {id:'preset14',   badge:'P-14',   name:'Preset 14 — minimal OOB',
    cmd:'-s1 -q1 -a1 -Y -Ar -a1 -s5 -o2 -At -f-1 -r1+s -a1 -As -s1 -o1+s -s-1 -a1',
    desc:'Минимальный OOB с SACK drop.'},
  {id:'preset19',   badge:'P-19',   name:'Preset 19 — triple OOB',
    cmd:'-o1 -a1 -At,r,s -f-1 -a1 -Ar,s -o1 -a1 -At -r1+s -f-1 -t6 -a1',
    desc:'Тройная цепочка OOB разными методами.'},
  {id:'split_basic',badge:'SPLIT',  name:'Split — базовый',
    cmd:'-s1 -a1 -An',
    desc:'Простое разделение первого байта TLS ClientHello.'},
  {id:'disorder',   badge:'DIS',    name:'Disorder — базовый',
    cmd:'-d1 -a1 -An',
    desc:'Disorder первого байта TLS.'},
  {id:'fake',       badge:'FAKE',   name:'Fake — базовый',
    cmd:'-f-1 -t5 -n www.iana.org -a1 -An',
    desc:'Поддельный TLS пакет с фиктивным SNI.'},
  {id:'oob',        badge:'OOB',    name:'OOB — базовый',
    cmd:'-o1 -a1 -An',
    desc:'Out-of-band данные в первой позиции.'},
  {id:'disoob',     badge:'DOOB',   name:'DisOOB — базовый',
    cmd:'-q1 -a1 -An',
    desc:'Комбинация disorder+OOB.'},
];
// ══ ЗВОНКИ ══
const BELL_MON={'I':['09:00','09:45','09:50','10:35'],'II':['10:45','11:30','11:35','12:20'],'III':['12:50','13:35','13:40','14:25'],'IV':['14:35','15:35',null,null],'V':['15:45','16:45',null,null],'VI':['16:55','17:55',null,null]};
const BELL_TUE={'I':['08:30','09:15','09:20','10:05'],'II':['10:15','11:00','11:05','11:50'],'III':['12:20','13:05','13:10','13:55'],'IV':['14:05','15:05',null,null],'V':['15:15','16:15',null,null],'VI':['16:25','17:25',null,null]};

// ══ OLE2 ПАРСЕР ══
function u32(buf,off){return new DataView(buf instanceof Uint8Array?buf.buffer:buf,buf instanceof Uint8Array?buf.byteOffset:0).getUint32(off,true)}
function u16(buf,off){return new DataView(buf instanceof Uint8Array?buf.buffer:buf,buf instanceof Uint8Array?buf.byteOffset:0).getUint16(off,true)}
function ole2Text(ab){
  const sig=[0xD0,0xCF,0x11,0xE0,0xA1,0xB1,0x1A,0xE1];
  if(ab.byteLength<512)return'';
  const arr=new Uint8Array(ab);
  for(let i=0;i<8;i++)if(arr[i]!==sig[i])return'';
  const ss=Math.pow(2,u16(ab,30));
  const difat=[];
  for(let i=0;i<Math.min(109,u32(ab,44));i++){const v=u32(ab,76+i*4);if(v>=0xFFFFFFFC)break;difat.push(v);}
  const fat=[];
  for(const sn of difat){const off=512+sn*ss;for(let i=0;i<ss/4;i++){const p=off+i*4;if(p+4<=ab.byteLength)fat.push(u32(ab,p));}}
  function rd(sec,maxSz){
    const chunks=[];let total=0;const vis=new Set();
    while(sec!==0xFFFFFFFE&&sec!==0xFFFFFFFF&&!vis.has(sec)){
      vis.add(sec);const off=512+sec*ss;if(off>=ab.byteLength)break;
      const len=Math.min(ss,ab.byteLength-off);chunks.push(new Uint8Array(ab,off,len));total+=len;
      if(maxSz&&total>=maxSz)break;if(sec>=fat.length)break;sec=fat[sec];
    }
    const out=new Uint8Array(maxSz?Math.min(total,maxSz):total);let pos=0;
    for(const c of chunks){const take=Math.min(c.length,out.length-pos);out.set(c.slice(0,take),pos);pos+=take;if(pos>=out.length)break;}
    return out;
  }
  const dd=rd(u32(ab,48));
  let ws=0,wz=0;
  for(let i=0;i<Math.floor(dd.length/128);i++){
    const e=dd.slice(i*128,(i+1)*128);if(e.length<128)break;
    const nl=e[64]|e[65]<<8;
    const nm=nl>=2?new TextDecoder('utf-16le').decode(e.slice(0,nl-2)):'';
    if(nm==='WordDocument'){const dv=new DataView(dd.buffer,dd.byteOffset+i*128);ws=dv.getUint32(116,true);wz=dv.getUint32(120,true);break;}
  }
  if(!wz)return'';
  const wsd=rd(ws,wz);if(wsd.length<32)return'';
  const dv=new DataView(wsd.buffer,wsd.byteOffset);
  const fc=dv.getUint32(24,true),cc=dv.getUint32(28,true);
  if(fc>=wsd.length)return'';
  return new TextDecoder('utf-16le').decode(wsd.slice(fc,fc+cc*2));
}
function getCells(ab){
  const t=ole2Text(ab);
  if(!t)return[];
  return t.split('\x07').map(c=>{
    // Фильтруем бинарный мусор: оставляем только читаемые символы
    // Строгий белый список: ASCII-printable + только стандартный русский алфавит (А-Я а-я Ёё)
    // Это исключает мусорные расширенные кириллические символы (Ђ U+0402, Ѐ U+0400 и т.п.)
    const clean = c
      .replace(/\r/g,'\n')
      .replace(/[^\x09\x0A\x20-\x7E\u0401\u0410-\u044F\u0451«»№]/g,'')
      // Убираем строки где >60% символов — нечитаемые (бинарный мусор)
      .split('\n')
      .map(line => {
        if (!line.trim()) return line;
        const readable = (line.match(/[\u0401\u0410-\u044F\u0451A-Za-z\u0030-\u0039\s.,;:!?\-+=%()«»"'№]/g) || []).length;
        const ratio = readable / line.length;
        return ratio > 0.35 || line.length < 5 ? line : '';
      })
      .join('\n')
      .replace(/\n{3,}/g, '\n\n')
      .trim();
    return clean;
  });
}
const GRP=/^[А-ЯЁA-Z0-9]{1,5}[\-]?\d[\-]\d{2}$/u;
const GRP_SEARCH=/\b([А-ЯЁA-Z0-9]{1,5}[\-]?\d[\-]\d{2})\b/gu;
const ROM=/^(I{1,3}V?|VI{0,3}|IV)$/;
const HDR=/Расписание занятий/i;
function norm(s){return s.trim().toUpperCase().replace(/[\s\-\.]/g,'')}
function detectGroups(ab){
  const seen={};
  for(const c of getCells(ab)){
    const t=c.trim();
    // Сначала проверяем точное совпадение
    if(GRP.test(t)){const k=norm(t);if(!seen[k])seen[k]=t;continue;}
    // Проверяем первую строку ячейки
    const singleLine=t.split('\n')[0].trim();
    if(GRP.test(singleLine)){const k=norm(singleLine);if(!seen[k])seen[k]=singleLine;continue;}
    // Поиск шаблона группы внутри текста ячейки
    GRP_SEARCH.lastIndex=0;
    let m;
    while((m=GRP_SEARCH.exec(t))!==null){const k=norm(m[1]);if(!seen[k])seen[k]=m[1];}
  }
  return Object.values(seen).sort();
}
function parseDoc(ab,group){
  const cells=getCells(ab),tn=norm(group),labels=[];
  cells.forEach((c,i)=>{if(HDR.test(c))labels.push(i);});
  if(!labels.length)return{sched:[],hdr:''};
  labels.push(cells.length);
  for(let bi=0;bi<labels.length-1;bi++){
    let li=labels[bi],nx=labels[bi+1],gs=li+1;
    while(gs<nx&&!GRP.test(cells[gs]))gs++;
    if(gs>=nx)continue;
    let ge=gs;while(ge<nx&&GRP.test(cells[ge]))ge++;
    const fi=[...Array(ge-gs).keys()].map(j=>gs+j).find(i=>norm(cells[i])===tn);
    if(fi===undefined)continue;
    const off=fi-li;
    const hdr=cells[li].split('\n').find(l=>HDR.test(l))?.trim()||'';
    const sched=[],seen=new Set();
    for(let ri=ge;ri<nx;ri++){
      const c=cells[ri];
      if(ROM.test(c)&&!seen.has(c)){seen.add(c);const li2=ri+off;sched.push([c,li2<cells.length?cells[li2].trim():''|'']);}
    }
    return{sched,hdr};
  }
  return{sched:[],hdr:''};
}

// ══ СОСТОЯНИЕ ══
const DEFAULT_URL='https://disk.yandex.ru/d/mjhoc7kysmQEuQ';
const S={
  url:DEFAULT_URL,files:[],selectedFile:null,lastGroup:'',
  theme:'orange',dns:'system',customDns:'',dpi:'general',
  customProxy:'',proxyProvider:'allorigins',
  appIcon:'orange',liquidGlass:false,liquidGlassOpt:false,customBg:'',
  customBgBlurred:'' // кэш pre-blurred версии фона (не сохраняется в localStorage)
};
const FILE_CACHE={};
let allGroups=[];

const _mem={};
const stor={
  get(k){try{return localStorage.getItem(k);}catch(e){return _mem[k]||null;}},
  set(k,v){try{localStorage.setItem(k,v);}catch(e){_mem[k]=v;}},
  del(k){try{localStorage.removeItem(k);}catch(e){delete _mem[k];}}
};
function loadLocal(){
  try{
    const d=JSON.parse(stor.get('sched')||'{}');
    S.lastGroup=d.group||'';
    S.theme=d.theme||'orange';
    // Migrate: if old users had glass as theme, switch to orange + enable glass mode
    if(S.theme==='glass'){S.theme='orange';S.liquidGlass=true;}
    else S.liquidGlass=d.liquidGlass||false;
    S.liquidGlassOpt=d.liquidGlassOpt||false;
    // Фон грузим из отдельного ключа
    S.customBg = stor.get('sched_bg') || '';
    S.url=d.url||DEFAULT_URL;
    S.dns=d.dns||'system';
    S.customDns=d.customDns||'';
    S.dpi=d.dpi||'general';
    S.customProxy=d.customProxy||'';
    S.proxyProvider=d.proxyProvider||'corsproxy';
    S.appIcon=d.appIcon||'orange';
    const inp=document.getElementById('url-input');
    if(inp)inp.value=S.url;
    const pi=document.getElementById('proxy-input');
    if(pi)pi.value=S.customProxy;
    const ci=document.getElementById('custom-dns-input');
    if(ci)ci.value=S.customDns;
  }catch(e){}
}
function saveLocal(){
  // Основные настройки — без тяжёлого base64 фона
  stor.set('sched',JSON.stringify({
    group:S.lastGroup,theme:S.theme,url:S.url,
    dns:S.dns,customDns:S.customDns,dpi:S.dpi,customProxy:S.customProxy,proxyProvider:S.proxyProvider,
    appIcon:S.appIcon,liquidGlass:S.liquidGlass,liquidGlassOpt:S.liquidGlassOpt,
    hasBg: !!S.customBg
  }));
  // Фон хранится отдельно (может быть >1МБ base64)
  try {
    if(S.customBg) stor.set('sched_bg', S.customBg);
    else stor.del('sched_bg');
  } catch(e) {
    // Если квота превышена — уведомляем пользователя
    toast('⚠️ Не удалось сохранить фон: изображение слишком большое');
    S.customBg = '';
    applyCustomBg();
  }
}

// ══ ПРОКСИ ══
function buildProxyUrl(proxyBaseUrl, format, targetUrl) {
  if (format === 'append_raw') return proxyBaseUrl + targetUrl;
  // query_url and append_encoded both encode
  return proxyBaseUrl + encodeURIComponent(targetUrl);
}

function getActiveProxy() {
  const key = S.proxyProvider || 'allorigins';
  const p = PROXY_PROVIDERS[key] || PROXY_PROVIDERS['allorigins'];
  let url = p.url;
  if (key === 'cf_worker' || key === 'custom') {
    url = S.customProxy ? (S.customProxy.endsWith('/') ? S.customProxy : S.customProxy + '/') : '';
  }
  return { url, format: p.format || 'query_url', provider: key };
}

function renderProxyList() {
  const list = document.getElementById('proxy-list-screen'); if (!list) return;
  list.innerHTML = '';
  Object.entries(PROXY_PROVIDERS).forEach(([key, p]) => {
    const sel = S.proxyProvider === key;
    const card = document.createElement('div');
    card.className = 'proxy-card' + (sel ? ' selected' : '');
    card.innerHTML =
      '<div class="proxy-ico">' + p.ico + '</div>' +
      '<div style="flex:1;min-width:0">' +
        '<div style="display:flex;align-items:center">' +
          '<div class="proxy-name">' + p.name + '</div>' +
          '<span class="proxy-tag ' + p.tag + '">' + p.tagText + '</span>' +
        '</div>' +
        '<div class="proxy-addr">' + p.addr + '</div>' +
        '<div class="proxy-desc">' + p.desc + '</div>' +
      '</div>' +
      '<div class="proxy-check">✓</div>';
    card.onclick = () => selectProxy(key);
    list.appendChild(card);
  });
  // Show/hide custom input
  const needInput = (S.proxyProvider === 'cf_worker' || S.proxyProvider === 'custom');
  const wrap = document.getElementById('custom-proxy-screen-wrap');
  if (wrap) wrap.classList.toggle('hidden', !needInput);
  const inp = document.getElementById('proxy-input-screen');
  if (inp) inp.value = S.customProxy || '';
}

function updateProxyCurrentRow() {
  const p = PROXY_PROVIDERS[S.proxyProvider] || PROXY_PROVIDERS['allorigins'];
  const nameEl = document.getElementById('proxy-current-name');
  const subEl  = document.getElementById('proxy-current-sub');
  if (nameEl) nameEl.textContent = p.name;
  if (subEl)  subEl.textContent  = p.addr + ' • ' + p.tagText;
  const statusEl = document.getElementById('proxy-status');
  if (statusEl) statusEl.textContent = '';
}

function selectProxy(key) {
  S.proxyProvider = key; saveLocal();
  renderProxyList();
  updateProxyCurrentRow();
  toast('Прокси: ' + (PROXY_PROVIDERS[key]?.name || key));
  // Если на главной была ошибка — перезапустить загрузку
  const err = document.getElementById('home-error-hint');
  if (err && !err.classList.contains('hidden') && key !== 'cf_worker' && key !== 'custom') {
    loadFiles();
  }
}

function saveCustomProxyFromScreen() {
  const v = (document.getElementById('proxy-input-screen')?.value || '').trim();
  S.customProxy = v; saveLocal();
  if (document.getElementById('proxy-input')) document.getElementById('proxy-input').value = v;
  toast(v ? 'Прокси сохранён' : 'Адрес прокси очищен');
  updateProxyCurrentRow();
  if (v) {
    const err = document.getElementById('home-error-hint');
    if (err && !err.classList.contains('hidden')) loadFiles();
  }
}

// legacy, keep for backward compat
function saveProxy() { saveCustomProxyFromScreen(); }
function saveCustomProxy() { saveCustomProxyFromScreen(); }
function renderProxyGrid() { renderProxyList(); }

async function testCurrentProxy() {
  const btn = document.getElementById('proxy-test-btn');
  const status = document.getElementById('proxy-test-status');
  if (btn) { btn.disabled = true; btn.textContent = '⏳ Проверяю...'; }
  if (status) status.textContent = '';
  try {
    const {url: pBase, format, provider} = getActiveProxy();
    if (!pBase) throw new Error('Прокси не настроен');
    const testUrl = 'https://cloud-api.yandex.net/v1/disk/public/resources?public_key=test&limit=1';
    const proxyUrl = buildProxyUrl(pBase, format, testUrl);
    const r = await fetch(proxyUrl, {signal: AbortSignal.timeout(10000)});
    // 404 from Yandex is fine — means proxy works
    const ok = r.status < 500;
    if (status) status.textContent = ok
      ? '✅ Прокси работает! HTTP ' + r.status
      : '❌ Ошибка: HTTP ' + r.status;
  } catch(e) {
    if (status) status.textContent = '❌ ' + e.message;
  }
  if (btn) { btn.disabled = false; btn.textContent = '🔌 Проверить подключение'; }
}
// ══ НАТИВНАЯ ЗАГРУЗКА (Android Java, без CORS) ══
// Если запущено в Android-приложении — используем нативные методы.
// Иначе (браузер/тест) — fallback на CORS-прокси.

async function nativeGet(url) {
  // Запускаем синхронный @JavascriptInterface через Promise + setTimeout
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      try {
        const resStr = window.Android.nativeFetch(url);
        const res = JSON.parse(resStr);
        if (!res.ok) reject(new Error('HTTP ' + (res.status || 0) + (res.error ? ' — ' + res.error : '')));
        else resolve(JSON.parse(res.body));
      } catch(e) { reject(e); }
    }, 0);
  });
}

async function nativeDownloadBuf(url) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      try {
        const resStr = window.Android.nativeDownloadBase64(url);
        const res = JSON.parse(resStr);
        if (!res.ok) reject(new Error(res.error || 'Ошибка скачивания'));
        else resolve(base64ToArrayBuffer(res.base64));
      } catch(e) { reject(e); }
    }, 0);
  });
}

async function yadGet(path, params) {
  const qs = new URLSearchParams(params).toString();
  const raw = `https://cloud-api.yandex.net${path}?${qs}`;

  if (window.Android && window.Android.nativeFetch) {
    // Нативный путь — без CORS
    const data = await nativeGet(raw);
    const el = document.getElementById('proxy-status');
    if (el) el.textContent = '✅ Прямое подключение';
    return data;
  }

  // Fallback: CORS-прокси (браузер/дебаг)
  const {url: pBase, format} = getActiveProxy();
  if (!pBase) throw new Error('Прокси не настроен. Выбери прокси в настройках.');
  const proxyUrl = buildProxyUrl(pBase, format, raw);
  const r = await fetch(proxyUrl, {signal: AbortSignal.timeout(15000)});
  if (!r.ok) throw new Error(`Прокси вернул HTTP ${r.status}`);
  const el = document.getElementById('proxy-status');
  if (el) el.textContent = '✅ ' + (PROXY_PROVIDERS[S.proxyProvider]?.name || S.proxyProvider);
  return r.json();
}

async function yadDownload(rawUrl, filename) {
  if (window.Android && window.Android.nativeDownloadBase64) {
    // Нативный путь — без CORS, надёжно
    return await nativeDownloadBuf(rawUrl);
  }

  // Fallback: CORS-прокси
  const {url: pBase, format, provider} = getActiveProxy();
  if (!pBase) throw new Error('Прокси не настроен. Открой Настройки → Прокси');
  if (provider === 'allorigins') return await yadDownloadAllOrigins(rawUrl);
  const proxyUrl = buildProxyUrl(pBase, format, rawUrl);
  try {
    const r = await fetch(proxyUrl, {signal: AbortSignal.timeout(30000)});
    if (!r.ok) throw new Error('HTTP ' + r.status);
    const ct = r.headers.get('content-type') || '';
    if (ct.includes('text/html') && !filename?.toLowerCase().endsWith('.html'))
      throw new Error('Прокси вернул HTML вместо файла');
    return r.arrayBuffer();
  } catch(e) {
    try { return await yadDownloadAllOrigins(rawUrl); }
    catch(e2) { throw new Error('Не удалось скачать файл: ' + e.message); }
  }
}

async function yadDownloadAllOrigins(rawUrl) {
  const aoUrl = 'https://api.allorigins.win/get?url=' + encodeURIComponent(rawUrl);
  const r = await fetch(aoUrl, {signal: AbortSignal.timeout(45000)});
  if (!r.ok) throw new Error('AllOrigins HTTP ' + r.status);
  const data = await r.json();
  if (!data.contents) throw new Error('AllOrigins вернул пустой ответ');
  const contents = data.contents;
  if (typeof contents === 'string' && contents.startsWith('data:'))
    return base64ToArrayBuffer(contents.split(',')[1]);
  return new TextEncoder().encode(contents).buffer;
}

function base64ToArrayBuffer(b64) {
  const bin = atob(b64);
  const buf = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) buf[i] = bin.charCodeAt(i);
  return buf.buffer;
}

// ══ ИКОНКА ПРИЛОЖЕНИЯ ══
const ICON_VARIANTS = {
  orange:  {label:'Оранжевая',  ico:'🟠', bg:'#0d0d0d', accent:'#e87722', accent2:'#c45f0a', style:'gradient-warm'},
  amoled:  {label:'AMOLED',     ico:'⚫', bg:'#000000', accent:'#00e5ff', accent2:'#0088aa', style:'glow-cyan'},
  samek:   {label:'СаМеК',      ico:'🔵', bg:'#10388A', accent:'#7FBBFF', accent2:'#4a7fd4', style:'gradient-blue'},
  purple:  {label:'Фиолет',     ico:'🫐', bg:'#0e0b1a', accent:'#a78bfa', accent2:'#7c3aed', style:'glow-purple'},
  forest:  {label:'Лес',        ico:'🌿', bg:'#0b1a10', accent:'#4caf7d', accent2:'#2d8653', style:'glow-green'},
  gold:    {label:'Золото',     ico:'✨', bg:'#100e00', accent:'#f5c518', accent2:'#c9a000', style:'glow-gold'},
  glass:   {label:'Стекло',     ico:'🫧', bg:'#0a0f1e', accent:'#a0c4ff', accent2:'#7b9fff', style:'glass'},
  win11:   {label:'Win 11',     ico:'🔵', bg:'#1a1a1a', accent:'#60cdff', accent2:'#0067c0', style:'flat'},
  pixel:   {label:'Material',   ico:'🟣', bg:'#191c1e', accent:'#7fcfff', accent2:'#2f71d4', style:'flat'},
  aero:    {label:'Aero',       ico:'💎', bg:'#152030', accent:'#7fd7ff', accent2:'#00a8e8', style:'flat'},
  rose:    {label:'Розовый',    ico:'🌸', bg:'#1a0d12', accent:'#f472b6', accent2:'#db2777', style:'flat'},
  sunset:  {label:'Закат',      ico:'🌅', bg:'#0f0a00', accent:'#ff6b35', accent2:'#c94a10', style:'flat'},
  bw:      {label:'Ч/Б',        ico:'⬜', bg:'#000000', accent:'#ffffff', accent2:'#888888', style:'flat'},
  light:   {label:'Светлая',    ico:'☀️', bg:'#f4f4f4', accent:'#e87722', accent2:'#c45f0a', style:'flat'},
  candy:   {label:'Конфетка',   ico:'🍭', bg:'#1A0A12', accent:'#FF4DA6', accent2:'#d91a75', style:'flat'},
  ocean:   {label:'Океан',      ico:'🌊', bg:'#0A1520', accent:'#00B4D8', accent2:'#0077B6', style:'flat'},
};

// Draw CK icon preview on a canvas element
function drawIconPreview(canvas, variant) {
  const size = canvas.width;
  const ctx = canvas.getContext('2d');
  const t = variant;

  // Background
  if (t.style === 'gradient-warm') {
    const g = ctx.createRadialGradient(size*0.5,size*0.35,0, size*0.5,size*0.5,size*0.7);
    g.addColorStop(0, '#2a1800'); g.addColorStop(1, '#0d0d0d');
    ctx.fillStyle = g;
  } else if (t.style === 'gradient-blue') {
    const g = ctx.createLinearGradient(0, 0, size, size);
    g.addColorStop(0, '#0a1e4a'); g.addColorStop(1, '#10388A');
    ctx.fillStyle = g;
  } else if (t.style === 'glow-cyan') {
    const g = ctx.createRadialGradient(size*0.5,size*0.4,0, size*0.5,size*0.5,size*0.6);
    g.addColorStop(0, '#001a22'); g.addColorStop(1, '#000000');
    ctx.fillStyle = g;
  } else if (t.style === 'glow-purple') {
    const g = ctx.createRadialGradient(size*0.5,size*0.4,0, size*0.5,size*0.5,size*0.65);
    g.addColorStop(0, '#1a0f35'); g.addColorStop(1, '#0e0b1a');
    ctx.fillStyle = g;
  } else if (t.style === 'glow-green') {
    const g = ctx.createRadialGradient(size*0.5,size*0.4,0, size*0.5,size*0.5,size*0.65);
    g.addColorStop(0, '#0f2a18'); g.addColorStop(1, '#0b1a10');
    ctx.fillStyle = g;
  } else if (t.style === 'glow-gold') {
    const g = ctx.createRadialGradient(size*0.5,size*0.4,0, size*0.5,size*0.5,size*0.65);
    g.addColorStop(0, '#1f1a00'); g.addColorStop(1, '#100e00');
    ctx.fillStyle = g;
  } else if (t.style === 'glass') {
    const g = ctx.createLinearGradient(0,0,size,size);
    g.addColorStop(0,'#1a2040'); g.addColorStop(0.5,'#0f1535'); g.addColorStop(1,'#0a0f1e');
    ctx.fillStyle = g;
  } else if (t.style === 'flat') {
    ctx.fillStyle = t.bg;
  } else {
    ctx.fillStyle = t.bg;
  }

  // Rounded rect background
  ctx.beginPath();
  if (ctx.roundRect) ctx.roundRect(0,0,size,size, size*0.22);
  else ctx.rect(0,0,size,size);
  ctx.fill();

  // Outer border ring
  ctx.strokeStyle = t.accent + '55';
  ctx.lineWidth = size * 0.035;
  ctx.beginPath();
  if (ctx.roundRect) ctx.roundRect(size*0.04,size*0.04,size*0.92,size*0.92, size*0.18);
  else ctx.rect(size*0.04,size*0.04,size*0.92,size*0.92);
  ctx.stroke();

  // Glow under logo
  ctx.shadowColor = t.accent;
  ctx.shadowBlur = size * 0.22;
  ctx.fillStyle = 'transparent';
  ctx.fillRect(size*0.3, size*0.3, size*0.4, size*0.4);
  ctx.shadowBlur = 0;

  // Draw CK logo mark
  const cx = size * 0.5, cy = size * 0.5;
  const lw = size * 0.09; // stroke width

  ctx.strokeStyle = t.accent;
  ctx.lineWidth = lw;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.shadowColor = t.accent;
  ctx.shadowBlur = size * 0.12;

  // C shape (open on right)
  const cr = size * 0.22;
  ctx.beginPath();
  ctx.arc(cx - size*0.04, cy, cr, Math.PI * 0.28, Math.PI * 1.72);
  ctx.stroke();

  // K shape (right side)
  const kx = cx + size * 0.06, ky = cy;
  const kh = cr * 0.95;
  // Vertical bar of K
  ctx.beginPath();
  ctx.moveTo(kx, ky - kh);
  ctx.lineTo(kx, ky + kh);
  ctx.stroke();
  // Upper diagonal
  ctx.beginPath();
  ctx.moveTo(kx, ky - kh * 0.08);
  ctx.lineTo(kx + kh * 0.7, ky - kh);
  ctx.stroke();
  // Lower diagonal
  ctx.beginPath();
  ctx.moveTo(kx, ky - kh * 0.08);
  ctx.lineTo(kx + kh * 0.75, ky + kh);
  ctx.stroke();

  ctx.shadowBlur = 0;
}

function pickIcon(key) {
  if (!window.Android || !window.Android.setAppIcon) {
    toast('Смена иконки доступна только в приложении');
    return;
  }
  // Сохраняем выбор и обновляем UI — диалог подтверждения покажет Java
  S.appIcon = key;
  saveLocal();
  renderIconGrid();
  window.Android.setAppIcon(key);
}

function renderIconGrid() {
  const g = document.getElementById('icon-grid-screen');
  if (!g) return;
  const cur = S.appIcon || 'orange';
  const sec = document.getElementById('icon-picker-section');
  if (sec) sec.style.display = window.Android ? '' : 'none';

  g.innerHTML = '';
  // Use a flex-wrap grid instead of theme-card list
  const grid = document.createElement('div');
  grid.style.cssText = 'display:flex;flex-wrap:wrap;gap:14px;padding:4px 0';
  g.appendChild(grid);

  Object.entries(ICON_VARIANTS).forEach(([key, t]) => {
    const wrap = document.createElement('div');
    wrap.style.cssText = 'display:flex;flex-direction:column;align-items:center;gap:7px;cursor:pointer;position:relative';

    const cvWrap = document.createElement('div');
    const isSel = cur === key;
    cvWrap.style.cssText = `border-radius:16px;overflow:hidden;transition:transform .15s,box-shadow .15s;` +
      (isSel ? `box-shadow:0 0 0 2.5px var(--accent),0 0 18px color-mix(in srgb,var(--accent) 50%,transparent);transform:scale(1.08)` : '');

    const cv = document.createElement('canvas');
    cv.width = 64; cv.height = 64;
    cv.style.cssText = 'display:block;border-radius:16px;';
    drawIconPreview(cv, t);
    cvWrap.appendChild(cv);

    // Selection tick badge
    const tick = document.createElement('div');
    tick.style.cssText = `position:absolute;top:-4px;right:-4px;background:var(--accent);color:#fff;
      font-size:10px;width:18px;height:18px;border-radius:50%;display:flex;align-items:center;
      justify-content:center;font-weight:700;opacity:${isSel?1:0};transition:opacity .15s`;
    tick.textContent = '✓';
    wrap.appendChild(cvWrap);
    wrap.appendChild(tick);

    const label = document.createElement('div');
    label.style.cssText = `font-size:11px;font-weight:600;color:${isSel?'var(--accent)':'var(--muted)'};letter-spacing:.03em;text-align:center;max-width:68px;line-height:1.2`;
    label.textContent = t.label;
    wrap.appendChild(label);

    wrap.onclick = () => pickIcon(key);
    wrap.addEventListener('touchstart', () => { cvWrap.style.transform = 'scale(0.94)'; });
    wrap.addEventListener('touchend', () => { cvWrap.style.transform = isSel ? 'scale(1.08)' : ''; });
    grid.appendChild(wrap);
  });
}

function updateIconPicker() { renderIconGrid(); }
function initIconPicker() { renderIconGrid(); }

// ══ ТЕМЫ ══
function applyTheme(key){
  const t=THEMES[key]||THEMES['orange'];
  Object.entries(t.vars).forEach(([k,v])=>document.documentElement.style.setProperty(k,v));
  document.documentElement.setAttribute('data-theme',key);
  S.theme=key;saveLocal();renderThemeGrid();renderIconGrid();updateThemeCurrentRow();
  // Re-apply glass mode with new theme colors
  applyGlassMode(false);
}

/* ── Liquid Glass Mode ── */
function applyGlassMode(save){
  const body=document.body;
  body.classList.toggle('glass-mode', !!S.liquidGlass);
  // Оптимизация работает и при glass-mode, и при кастомном фоне
  const blurActive = !!(S.liquidGlass || S.customBg);
  body.classList.toggle('glass-optimized', !!(S.liquidGlassOpt && blurActive));
  // Update toggles
  const gt=document.getElementById('glass-toggle');
  const got=document.getElementById('glass-opt-toggle');
  const optRow=document.getElementById('glass-opt-row');
  if(gt) gt.classList.toggle('on', !!S.liquidGlass);
  if(got) got.classList.toggle('on', !!S.liquidGlassOpt);
  // Показываем строку оптимизации если есть хоть какой-то блюр (glass ИЛИ кастомный фон)
  if(optRow) optRow.style.display = blurActive ? 'flex' : 'none';
  if(save) saveLocal();
}
function toggleGlassMode(){
  S.liquidGlass = !S.liquidGlass;
  if(!S.liquidGlass) S.liquidGlassOpt=false;
  applyGlassMode(true);
  toast(S.liquidGlass ? '🫧 Liquid Glass включён' : 'Liquid Glass выключен');
}
function toggleGlassOpt(){
  // Работает и без glass-mode, если стоит кастомный фон
  if(!S.liquidGlass && !S.customBg) return;
  S.liquidGlassOpt = !S.liquidGlassOpt;
  applyGlassMode(true);
  toast(S.liquidGlassOpt ? '⚡ Оптимизация блюра включена' : 'Оптимизация блюра выключена');
}

/* ── Custom Background ── */
function applyCustomBg(){
  const layer = document.getElementById('bg-layer');
  const body  = document.body;
  if(S.customBg){
    if(layer){
      layer.style.backgroundImage = 'url(' + S.customBg + ')';
      layer.classList.add('active');
    }
    body.classList.add('custom-bg-active');
    // ── Pre-blur (Telegram-стиль): вычислить один раз, кэшировать ──
    if(S.customBgBlurred){
      // Уже есть кэш — применяем сразу
      applyPreBlurredBg(S.customBgBlurred);
    } else {
      // Нет кэша — вычисляем асинхронно (не блокируем UI)
      body.classList.remove('preblur-ready');
      computePreBlurredBg(S.customBg, function(blurUrl){
        if(blurUrl){
          S.customBgBlurred = blurUrl;
          // Не сохраняем в localStorage (слишком большой) — пересчитается при след. запуске
          applyPreBlurredBg(blurUrl);
        }
      });
    }
  } else {
    if(layer){
      layer.style.backgroundImage = '';
      layer.classList.remove('active');
    }
    body.classList.remove('custom-bg-active');
    body.classList.remove('preblur-ready');
    document.documentElement.style.removeProperty('--pre-blurred-bg');
  }
  // Обновляем видимость тоггла оптимизации (он нужен и при кастомном фоне)
  applyGlassMode(false);
  updateBgUI();
}
function updateBgUI(){
  const preview=document.getElementById('custom-bg-preview');
  const thumb=document.getElementById('custom-bg-img-thumb');
  const removeBtn=document.getElementById('remove-bg-btn');
  if(preview) preview.style.display = S.customBg ? 'block' : 'none';
  if(thumb && S.customBg) thumb.src = S.customBg;
  if(removeBtn) removeBtn.style.display = S.customBg ? '' : 'none';
}
function pickBgImage(){
  // На Android — используем нативный пикер (обходит проблему доступа к файлам)
  if(window.Android && window.Android.pickImageForBackground){
    window.Android.pickImageForBackground();
  } else {
    // Браузер / десктоп — обычный file input
    const inp=document.getElementById('bg-file-input');
    if(inp) inp.click();
  }
}

// Колбэк вызывается из Java после выбора изображения
function onNativeBgImagePicked(dataUrl){
  if(!dataUrl || !dataUrl.startsWith('data:image')){
    toast('❌ Неверный формат изображения');
    return;
  }
  // Проверяем размер (~10 МБ = ~13.3 МБ base64, с запасом ставим 20МБ)
  if(dataUrl.length > 20 * 1024 * 1024){
    toast('⚠️ Изображение слишком большое, выбери поменьше');
    return;
  }
  S.customBg = dataUrl;
  S.customBgBlurred = ''; // сбрасываем кэш — пересчитаем для нового фото
  saveLocal();
  applyCustomBg();
  toast('🖼 Фон применён');
}
function onBgFileChosen(e){
  const file=e.target.files && e.target.files[0];
  if(!file) return;
  if(!file.type.startsWith('image/')) { toast('Выбери файл изображения'); return; }
  if(file.size > 10*1024*1024) { toast('Файл слишком большой (макс. 10 МБ)'); return; }
  const reader=new FileReader();
  reader.onload=function(ev){
    S.customBg=ev.target.result;
    S.customBgBlurred=''; // сбрасываем кэш pre-blur
    saveLocal();
    applyCustomBg();
    toast('🖼 Фон применён');
  };
  reader.readAsDataURL(file);
  // Reset input so same file can be picked again
  e.target.value='';
}
function removeBgImage(){
  S.customBg='';
  S.customBgBlurred='';
  document.documentElement.style.removeProperty('--pre-blurred-bg');
  document.body.classList.remove('preblur-ready');
  saveLocal();
  applyCustomBg();
  toast('Фон удалён');
}

// ══════════════════════════════════════════════════════════════════
// ── 🚀 TELEGRAM-STYLE STACKBLUR ENGINE ───────────────────────────
//
// Принцип из Telegram Android (Utilities.java → native blur.c):
//  1. Downsample изображение до 1/4 размера  (tiny canvas)
//  2. Применить StackBlur (алгоритм Марио Клингеманна, O(n) per pixel,
//     НЕ зависит от радиуса — именно этот алгоритм в blur.c Telegram)
//  3. Апскейл обратно на размер экрана → статичный Data URL
//  4. Использовать как background-image — ноль GPU-работы при скролле
//
// StackBlur vs Gaussian vs CSS backdrop-filter:
//  CSS backdrop-filter → GPU каждый кадр           → нагрузка пропорц. кол-ву элементов
//  Gaussian blur       → O(r²) per pixel           → медленно при большом радиусе
//  StackBlur           → O(1) per pixel (constant) → одинаково быстро при любом радиусе
//
// Telegram использует radius=7 на 1/4-1/8 bitmap. Мы делаем то же самое.
// ══════════════════════════════════════════════════════════════════

// Полная реализация алгоритма StackBlur (Mario Klingemann, MIT License)
// Работает на пикселях ImageData напрямую — без внешних библиотек
function stackBlurRGB(pixels, w, h, radius) {
  if (radius < 1) return;
  const wm = w - 1, hm = h - 1;
  const wh = w * h;
  const div = radius + radius + 1;
  const r = new Int32Array(wh), g = new Int32Array(wh), b = new Int32Array(wh);
  let rsum, gsum, bsum, x, y, i, p, yp, yi, yw;
  const vmin = new Int32Array(Math.max(w, h));
  let divsum = (div + 1) >> 1; divsum *= divsum;
  const dv = new Int32Array(256 * divsum);
  for (i = 0; i < 256 * divsum; i++) dv[i] = i / divsum | 0;
  yw = yi = 0;

  const stack = new Int32Array(div * 3);
  let stackpointer, stackstart, sir, rbs;
  let r1 = radius + 1;
  let routsum, goutsum, boutsum, rinsum, ginsum, binsum;

  for (y = 0; y < h; y++) {
    rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0;
    for (i = -radius; i <= radius; i++) {
      p = (yi + (Math.min(wm, Math.max(i, 0)))) * 4;
      sir = (i + radius) * 3;
      stack[sir]     = pixels[p];
      stack[sir + 1] = pixels[p + 1];
      stack[sir + 2] = pixels[p + 2];
      rbs = r1 - Math.abs(i);
      rsum += stack[sir] * rbs; gsum += stack[sir+1] * rbs; bsum += stack[sir+2] * rbs;
      if (i > 0) { rinsum += stack[sir]; ginsum += stack[sir+1]; binsum += stack[sir+2]; }
      else       { routsum += stack[sir]; goutsum += stack[sir+1]; boutsum += stack[sir+2]; }
    }
    stackpointer = radius;
    for (x = 0; x < w; x++) {
      r[yi] = dv[rsum]; g[yi] = dv[gsum]; b[yi] = dv[bsum];
      rsum -= routsum; gsum -= goutsum; bsum -= boutsum;
      stackstart = stackpointer - radius + div;
      sir = (stackstart % div) * 3;
      routsum -= stack[sir]; goutsum -= stack[sir+1]; boutsum -= stack[sir+2];
      if (y === 0) vmin[x] = Math.min(x + radius + 1, wm);
      p = (yw + vmin[x]) * 4;
      stack[sir] = pixels[p]; stack[sir+1] = pixels[p+1]; stack[sir+2] = pixels[p+2];
      rinsum += stack[sir]; ginsum += stack[sir+1]; binsum += stack[sir+2];
      rsum += rinsum; gsum += ginsum; bsum += binsum;
      stackpointer = (stackpointer + 1) % div;
      sir = stackpointer * 3;
      routsum += stack[sir]; goutsum += stack[sir+1]; boutsum += stack[sir+2];
      rinsum -= stack[sir]; ginsum -= stack[sir+1]; binsum -= stack[sir+2];
      yi++;
    }
    yw += w;
  }
  for (x = 0; x < w; x++) {
    rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0;
    yp = -radius * w;
    for (i = -radius; i <= radius; i++) {
      yi = Math.max(0, yp) + x;
      sir = (i + radius) * 3;
      stack[sir] = r[yi]; stack[sir+1] = g[yi]; stack[sir+2] = b[yi];
      rbs = r1 - Math.abs(i);
      rsum += r[yi] * rbs; gsum += g[yi] * rbs; bsum += b[yi] * rbs;
      if (i > 0) { rinsum += stack[sir]; ginsum += stack[sir+1]; binsum += stack[sir+2]; }
      else       { routsum += stack[sir]; goutsum += stack[sir+1]; boutsum += stack[sir+2]; }
      if (i < hm) yp += w;
    }
    yi = x;
    stackpointer = radius;
    for (y = 0; y < h; y++) {
      pixels[yi * 4]     = dv[rsum];
      pixels[yi * 4 + 1] = dv[gsum];
      pixels[yi * 4 + 2] = dv[bsum];
      rsum -= routsum; gsum -= goutsum; bsum -= boutsum;
      stackstart = stackpointer - radius + div;
      sir = (stackstart % div) * 3;
      routsum -= stack[sir]; goutsum -= stack[sir+1]; boutsum -= stack[sir+2];
      if (x === 0) vmin[y] = Math.min(y + r1, hm) * w;
      p = x + vmin[y];
      stack[sir] = r[p]; stack[sir+1] = g[p]; stack[sir+2] = b[p];
      rinsum += stack[sir]; ginsum += stack[sir+1]; binsum += stack[sir+2];
      rsum += rinsum; gsum += ginsum; bsum += binsum;
      stackpointer = (stackpointer + 1) % div;
      sir = stackpointer * 3;
      routsum += stack[sir]; goutsum += stack[sir+1]; boutsum += stack[sir+2];
      rinsum -= stack[sir]; ginsum -= stack[sir+1]; binsum -= stack[sir+2];
      yi += w;
    }
  }
}

// Главная функция pre-blur: точный алгоритм Telegram Android
//
// Telegram (ImageLoader.java):
//   1. Получить bitmap фонового изображения
//   2. Создать scaled bitmap: Bitmaps.createScaledBitmap(src, w/4, h/4, true)
//   3. Utilities.blurBitmap(scaledBitmap, 7, unpin, w, h, rowBytes)  ← radius=7
//   4. Вернуть как BitmapDrawable → использовать как background
//
// Мы делаем то же самое на Canvas API:
//   1. Нарисовать изображение на canvas размером 1/4 оригинала
//   2. getImageData → stackBlurRGB(radius=7) → putImageData
//   3. Нарисовать маленький canvas на финальный (логические пиксели экрана)
//   4. Сохранить как data URL — используется как background-image на кнопках
//
// ⚠ НЕ умножаем на DPR — работаем в логических пикселях (как Telegram в dp)
// ⚠ overlay НЕ запекаем в blur — он добавляется через CSS ::before/background-color
function computePreBlurredBg(srcDataUrl, callback) {
  const img = new Image();
  img.onload = function () {
    try {
      // Логические пиксели экрана (не физические — DPR не нужен)
      const SW = window.screen.width  || 390;
      const SH = window.screen.height || 844;

      // Шаг 1: downsample 1/4 — точно как Telegram createScaledBitmap(src, w/4, h/4)
      const bw = Math.max(4, Math.round(img.naturalWidth  / 4));
      const bh = Math.max(4, Math.round(img.naturalHeight / 4));
      const small = document.createElement('canvas');
      small.width = bw; small.height = bh;
      const sc = small.getContext('2d');
      sc.imageSmoothingEnabled = true;
      sc.imageSmoothingQuality = 'medium';

      // cover-fit (сохраняем пропорции, заполняем весь canvas)
      const ar  = img.naturalWidth / img.naturalHeight;
      const sar = bw / bh;
      let dw, dh, dx, dy;
      if (ar > sar) { dh = bh; dw = dh * ar; dx = (bw - dw) / 2; dy = 0; }
      else          { dw = bw; dh = dw / ar; dx = 0; dy = (bh - dh) / 2; }
      sc.drawImage(img, dx, dy, dw, dh);

      // Шаг 2: StackBlur radius=7 на маленьком canvas
      // Telegram: Utilities.blurBitmap(bitmap, 7, ...) — ТОЧНО тот же алгоритм
      const imgData = sc.getImageData(0, 0, bw, bh);
      stackBlurRGB(imgData.data, bw, bh, 7);
      sc.putImageData(imgData, 0, 0);

      // Шаг 3: upscale на логические пиксели экрана с cover-fit
      const out = document.createElement('canvas');
      out.width = SW; out.height = SH;
      const oc = out.getContext('2d');
      oc.imageSmoothingEnabled = true;
      oc.imageSmoothingQuality = 'high';

      const ar2  = img.naturalWidth / img.naturalHeight;
      const sar2 = SW / SH;
      let fw, fh, fx, fy;
      if (ar2 > sar2) { fh = SH; fw = fh * ar2; fx = (SW - fw) / 2; fy = 0; }
      else             { fw = SW; fh = fw / ar2; fx = 0; fy = (SH - fh) / 2; }
      oc.drawImage(small, fx, fy, fw, fh);

      // Шаг 4: НЕТ overlay в blur! Telegram рисует tint отдельно через Paint/alpha.
      // Мы добавим его через CSS (background-color + ::before pseudo).
      // Это позволяет менять прозрачность под каждый элемент независимо.

      // JPEG 82% — баланс качества и размера (Telegram тоже сжимает в JPEG)
      callback(out.toDataURL('image/jpeg', 0.82));
    } catch (e) {
      callback(null);
    }
  };
  img.onerror = function () { callback(null); };
  img.src = srcDataUrl;
}

function applyPreBlurredBg(blurredUrl) {
  if (!blurredUrl) return;
  document.documentElement.style.setProperty('--pre-blurred-bg', 'url(' + blurredUrl + ')');
  document.body.classList.add('preblur-ready');
}
function renderThemeGrid(){
  ['theme-grid-screen'].forEach(gid => {
    const g=document.getElementById(gid); if(!g) return;
    g.innerHTML='';
    Object.entries(THEMES).forEach(([key,t])=>{
      const c=document.createElement('div');c.className='theme-card'+(S.theme===key?' selected':'');
      c.innerHTML=`
        <div class="theme-swatch">${t.sw.map(cl=>`<div class="swatch" style="background:${cl}"></div>`).join('')}</div>
        <div style="flex:1;min-width:0">
          <div class="theme-name" style="font-size:13px;font-weight:700">${t.ico||''} ${t.name}</div>
        </div>
        <span class="theme-check">✓</span>`;
      c.onclick=()=>{SFX.play('themeSelect');applyTheme(key);}; g.appendChild(c);
    });
  });
}
function updateThemeCurrentRow(){
  const t=THEMES[S.theme];
  const nameEl=document.getElementById('theme-current-name');
  const subEl=document.getElementById('theme-current-sub');
  if(nameEl) nameEl.textContent=(t?.ico||'')+' '+(t?.name||S.theme);
  if(subEl)  subEl.textContent='Нажми для выбора';
}

// ══ DNS ══
function selectDns(key){
  S.dns=key;saveLocal();
  renderDnsGrid();
  const customWrap=document.getElementById('custom-dns-wrap');
  customWrap.classList.toggle('hidden',key!=='custom');
  // Уведомить Android нативно
  if(window.Android?.setDns){
    const doh=key==='custom'?S.customDns:(DNS_PROVIDERS[key]?.doh||'');
    window.Android.setDns(key,doh);
  }
  if(key!=='custom')toast('DNS: '+DNS_PROVIDERS[key]?.name);
}
function saveCustomDns(){
  const v=document.getElementById('custom-dns-input')?.value.trim()||'';
  S.customDns=v;saveLocal();
  if(window.Android?.setDns)window.Android.setDns('custom',v);
  toast('Свой DNS сохранён');
}
function renderDnsGrid(){
  const g=document.getElementById('dns-grid');g.innerHTML='';
  Object.entries(DNS_PROVIDERS).forEach(([key,d])=>{
    const c=document.createElement('div');c.className='dns-card'+(S.dns===key?' selected':'');
    c.innerHTML=`<div class="dns-card-ico">${d.ico}</div><div class="dns-card-name">${d.name}</div><div class="dns-card-addr">${d.addr}</div>`;
    c.onclick=()=>selectDns(key);g.appendChild(c);
  });
}

// ══ DPI стратегии ══
function selectDpi(id) {
  S.dpi = id; saveLocal();
  renderDpiList();
  updateDpiCurrentRow();
updateThemeCurrentRow();
  if (window.Android?.setDpiStrategy) window.Android.setDpiStrategy(id);
  const s = DPI_STRATEGIES.find(x => x.id === id);
  toast('Стратегия: ' + s?.name);
}

function updateDpiCurrentRow() {
  const s = DPI_STRATEGIES.find(x => x.id === S.dpi);
  const nameEl = document.getElementById('dpi-current-name');
  const badgeEl = document.getElementById('dpi-current-badge');
  if (nameEl) nameEl.textContent = s ? s.name : S.dpi;
  if (badgeEl) badgeEl.textContent = (s ? s.badge : '') + (dpiWorkingIds ? ' • ✅ проверено' : ' • Нажми для выбора');
  const row = document.getElementById('dpi-current-row');
  // не подсвечиваем строку постоянно — она просто навигационная
}

function renderDpiList() {
  // Рисуем в обе точки: экран DPI + (если есть) inline список
  ['dpi-list-screen'].forEach(listId => {
    const list = document.getElementById(listId); if (!list) return;
    list.innerHTML = '';
    const toShow = dpiWorkingIds
      ? DPI_STRATEGIES.filter(s => dpiWorkingIds.includes(s.id))
      : DPI_STRATEGIES;
    toShow.forEach(s => {
      const isWorking = dpiWorkingIds && dpiWorkingIds.includes(s.id);
      const item = document.createElement('div');
      item.className = 'dpi-item' + (S.dpi === s.id ? ' selected' : '') + (isWorking ? ' works' : '');
      item.innerHTML = `
        <span class="dpi-badge">${s.badge}</span>
        <div style="flex:1;min-width:0">
          <div class="dpi-name">${s.name}</div>
          ${s.desc ? `<div class="dpi-desc">${s.desc}</div>` : ''}
        </div>
        ${isWorking ? '<span style="font-size:12px;color:var(--success);flex-shrink:0">✅</span>' : ''}
        <span class="dpi-check">✓</span>`;
      item.onclick = () => selectDpi(s.id);
      list.appendChild(item);
    });
  });
}

// ══ VPN (Android) ══
let vpnActive=false;
function toggleVpn(){
  if(!window.Android?.toggleVpn){toast('Только в приложении');return;}
  window.Android.toggleVpn();
}
// Вызывается из Android нативно
function onVpnStateChanged(active,statusText){
  vpnActive=active;
  const dot=document.getElementById('vpn-dot');
  const title=document.getElementById('vpn-title');
  const sub=document.getElementById('vpn-sub');
  const btn=document.getElementById('vpn-btn');
  if(dot)dot.classList.toggle('on',active);
  if(title)title.textContent=active?'VPN обход активен':'VPN обход выключен';
  if(sub)sub.textContent=statusText||(active?'DNS и DPI обход работают':'DNS и DPI обход неактивны');
  if(btn){
    btn.className='btn '+(active?'btn-surface':'btn-accent');
    btn.textContent=active?'Отключить VPN обход':'Включить VPN обход';
  }
}

// ══ НАВИГАЦИЯ ══
// История экранов для кнопки "Назад"
let cur='s-home';
const SCREEN_PARENTS = {
  's-groups':   {parent:'s-home',    nav:'nav-home'},
  's-schedule': {parent:'s-home',    nav:'nav-home'}, // всегда на главную
  's-bells':    {parent:'s-home',    nav:'nav-bells'},
  's-settings': {parent:'s-home',    nav:'nav-home'},
  's-themes':   {parent:'s-settings',nav:null},
};

// Вызывается из Android (кнопка Back на телефоне)
function nativeBack(){
  const info = SCREEN_PARENTS[cur];
  if(info){
    if(info.parent==='s-home'){
      goHome();
    } else {
      showScreen(info.parent,'back');
      if(info.nav) updateNavActive(info.nav);
    }
    return true;
  }
  return false;
}

// ── Плавные переходы: ВСЕГДА с анимацией ──
// requestIdleCallback: если браузер занят — ждём свободный момент, потом анимируем.
// Анимация не пропускается, просто может начаться чуть позже.
function _doTransition(prev, next, dir) {
  prev.classList.add(dir==='back'?'exit-right':'exit-left');
  prev.classList.remove('active');
  setTimeout(()=>prev.classList.remove('exit-left','exit-right'), 320);
  next.style.transition='none';
  void next.getBoundingClientRect();
  requestAnimationFrame(()=>requestAnimationFrame(()=>{
    next.style.transition='';
    next.classList.add('active');
  }));
}
let _pendingScreenId=null;
function showScreen(id, dir='forward'){
  if(id===cur)return;
  const prev=document.getElementById(cur), next=document.getElementById(id);
  // При открытии экрана тем — рендерим темы и иконки заранее
  if(id==='s-themes'){renderThemeGrid();renderIconGrid();}
  if(id==='s-settings'){updateBgUI();applyGlassMode(false);}
  cur=id; _pendingScreenId=id;
  const go=()=>{
    if(_pendingScreenId!==id)return; // если уже другой переход — пропускаем
    _doTransition(prev, next, dir);
  };
  if(typeof requestIdleCallback!=='undefined'){
    requestIdleCallback(go, {timeout:300});
  } else {
    setTimeout(go, 0);
  }
}

function goHome(){
  showScreen('s-home','back');
  updateNavActive('nav-home');
  updateLastGroupBtn();
  const fs=document.getElementById('file-section');
  const err=document.getElementById('home-error-hint');
  const noUrl=document.getElementById('no-url-hint');
  if(fs.classList.contains('hidden')&&err.classList.contains('hidden')&&noUrl.classList.contains('hidden')){
    loadFiles();
  }
}
function navTo(id,navId){showScreen(id);updateNavActive(navId);}
function updateNavActive(aid){['nav-home','nav-bells','nav-settings'].forEach(id=>document.getElementById(id)?.classList.toggle('active',id===aid));}

// ══ ПОСЛЕДНЯЯ ГРУППА ══
function updateLastGroupBtn(){
  const wrap=document.getElementById('last-group-wrap'),btn=document.getElementById('last-group-btn');
  if(S.lastGroup){btn.textContent='▶ '+S.lastGroup;wrap.classList.remove('hidden');}
  else wrap.classList.add('hidden');
}
async function jumpToLastGroup(){
  if(!S.selectedFile){toast('Сначала загрузи файл расписания');return;}
  const btn=document.getElementById('last-group-btn');
  const origText=btn.textContent;
  btn.classList.add('loading');
  btn.innerHTML=`<span class="loading-spinner"></span><span class="btn-label">Загружаю...</span>`;
  try{
    await loadSchedule(S.lastGroup);
  } finally {
    btn.classList.remove('loading');
    btn.textContent=origText;
  }
}

// ══ ЗАГРУЗКА ══
function saveUrlAndLoad(){
  const inp=document.getElementById('url-input');
  const url=inp?inp.value.trim():'';
  if(!url){toast('Введи ссылку');return;}
  S.url=url;saveLocal();
  hideHomeHints();
  document.getElementById('file-section').classList.add('hidden');
  goHome();
  loadFiles();
}
async function loadFiles(){
  if(!S.url){showHomeState('no-url');return;}
  hideHomeHints();
  setStatus('home-status','Загружаю файлы...');setBar('home-bar',30);
  try{
    const data=await yadGet('/v1/disk/public/resources',{public_key:S.url,limit:100});
    S.files=(data._embedded?.items||[]).filter(i=>i.type==='file'&&/\.(doc|docx)$/i.test(i.name))
      .map(i=>({name:i.name,path:i.path||('/'+i.name),size:i.size||0,resourceId:i.resource_id||''}));
    setBar('home-bar',100);setStatus('home-status',`Найдено: ${S.files.length} файлов`);
    setTimeout(()=>{setBar('home-bar',0);setStatus('home-status','');},1200);
    renderFileList();
  }catch(e){
    setBar('home-bar',0);
    setStatus('home-status','');
    showHomeState('error',e.message);
  }
}
function hideHomeHints(){
  ['no-url-hint','home-error-hint'].forEach(id=>document.getElementById(id)?.classList.add('hidden'));
}
function showHomeState(type,msg){
  hideHomeHints();
  document.getElementById('file-section').classList.add('hidden');
  if(type==='no-url'){
    document.getElementById('no-url-hint').classList.remove('hidden');
  } else if(type==='error'){
    const el=document.getElementById('home-error-hint');
    if(el){const em=el.querySelector('.error-msg');if(em)em.textContent=msg||'Ошибка подключения';el.classList.remove('hidden');}
  }
}
function renderFileList(){
  const list=document.getElementById('file-list');list.innerHTML='';
  S.files.forEach(f=>{
    const item=document.createElement('div');
    item.className='list-item'+(S.selectedFile?.name===f.name?' selected':'');
    item.innerHTML=`<span class="item-name">${f.name}</span>`;
    item.onclick=()=>{S.selectedFile=f;renderFileList();toast('Выбран: '+f.name);};
    list.appendChild(item);
  });
  document.getElementById('file-section').classList.remove('hidden');
}

async function getFileBuf(){
  const key=S.selectedFile.path||S.selectedFile.name;
  if(FILE_CACHE[key])return FILE_CACHE[key];
  const filePath=S.selectedFile.path||('/'+S.selectedFile.name);
  const dl=await yadGet('/v1/disk/public/resources/download',{public_key:S.url,path:filePath});
  if(!dl||!dl.href) throw new Error('Яндекс не вернул ссылку на файл. Путь: '+filePath);
  const buf=await yadDownload(dl.href, S.selectedFile.name);
  FILE_CACHE[key]=buf;return buf;
}

// ══ ГРУППЫ ══
async function goToGroups(){
  if(!S.selectedFile){toast('Сначала выбери файл');return;}
  showScreen('s-groups');
  document.getElementById('groups-title').textContent=S.selectedFile.name;
  document.getElementById('group-search').value='';
  document.getElementById('group-list').innerHTML='';
  setStatus('groups-status','Скачиваю...');setBar('groups-bar',20);
  try{
    const buf=await getFileBuf();
    allGroups=detectGroups(buf);
    setBar('groups-bar',100);setStatus('groups-status',`${allGroups.length} групп`);
    setTimeout(()=>setBar('groups-bar',0),800);
    renderGroupList(allGroups);
  }catch(e){setBar('groups-bar',0);setStatus('groups-status','❌ '+e.message);}
}
function renderGroupList(groups){
  const list=document.getElementById('group-list');list.innerHTML='';
  groups.forEach(g=>{
    const item=document.createElement('div');
    item.className='list-item'+(S.lastGroup===g?' selected':'');
    item.innerHTML=`<span class="item-name">${g}</span>`;
    item.onclick=()=>{
      // Показываем визуальный отклик — спиннер в строке
      list.querySelectorAll('.list-item').forEach(el=>el.classList.remove('selected'));
      item.classList.add('selected');
      item.innerHTML=`<span class="item-name">${g}</span><span class="loading-spinner" style="opacity:.6"></span>`;
      loadSchedule(g);
    };
    list.appendChild(item);
  });
}
function filterGroups(q){
  const f=q.trim().toUpperCase();
  renderGroupList(f?allGroups.filter(g=>g.toUpperCase().includes(f)):allGroups);
}

// ══ РАСПИСАНИЕ ══
// Разбирает строку "Никитина Ю.В.к.17(2)" на имя преподавателя и кабинет
// Разбирает строку вида "Фамилия И.О.к.21(1)" на компоненты
function parseTeacherLine(line){
  // Ищем паттерн: к.NN(N) или к.NN
  const ki=line.search(/к\.\d/);
  if(ki<0)return{teacher:line.trim(),cabinetNum:'',korpus:''};
  const teacher=line.slice(0,ki).trim();
  const cabPart=line.slice(ki); // "к.21(1)" или "к.21"
  const numM=cabPart.match(/к\.(\d+)/);
  const korpM=cabPart.match(/\((\d)\)/);
  return{
    teacher,
    cabinetNum:numM?numM[1]:'',
    korpus:korpM?korpM[1]:''
  };
}

// Формирует HTML для строки деталей пары (преподаватель + кабинет + корпус)
function renderDetailLine(line){
  const p=parseTeacherLine(line);
  if(!p.cabinetNum)return`<span>${line}</span>`;
  let html=`<span>${p.teacher}</span>`;
  html+=`<br><span>кабинет ${p.cabinetNum}</span>`;
  if(p.korpus)html+=`<br><span>корпус ${p.korpus}</span>`;
  return html;
}

// Пытается отделить преподавателя+кабинет, если они слиты с названием предмета в одну строку
// Например: "Основы алгоритмизации и программирования Кубасова В.В.к.21(1)"
function splitSubjectAndTeacher(subjectLine){
  // Паттерн: за текстом предмета идёт Фамилия (одно/два слова) И.О. (два инициала с точками)
  // Дополнительно может идти к.NN(N)
  const m=subjectLine.match(
    /^(.+?)\s+([А-ЯЁ][а-яё]+(?:\s+[А-ЯЁ][а-яё]+)?\s+[А-ЯЁ]\.[А-ЯЁ]\.(к\.\d+(?:\(\d\))?)?)$/u
  );
  if(m&&m[1].trim().length>2){
    return{subject:m[1].trim(),teacherStr:m[2].trim()};
  }
  return null;
}
async function loadSchedule(group){
  if(!S.selectedFile){toast('Выбери файл');return;}
  showScreen('s-schedule');
  S.lastGroup=group;saveLocal();updateLastGroupBtn();
  document.getElementById('sched-group-name').textContent=group;
  document.getElementById('sched-date').textContent='';
  // Красивая анимация загрузки
  document.getElementById('sched-body').innerHTML=
    `<div class="sched-loading">
      <div class="sched-loading-circle"></div>
      <div style="color:var(--muted);font-size:13px;font-weight:500">Загружаю расписание…</div>
      <div class="sched-loading-dots">
        <div class="sched-loading-dot"></div>
        <div class="sched-loading-dot"></div>
        <div class="sched-loading-dot"></div>
      </div>
    </div>`;
  try{
    const buf=await getFileBuf();
    const{sched,hdr}=parseDoc(buf,group);
    if(!sched.length)throw new Error(`Группа "${group}" не найдена`);
    renderSchedule(group,hdr,sched,S.selectedFile.name);
  }catch(e){
    document.getElementById('sched-body').innerHTML=`<div style="text-align:center;padding:50px;color:var(--danger)">❌ ${e.message}</div>`;
  }
}
function renderSchedule(group,hdr,sched,filename){
  document.getElementById('sched-group-name').textContent=group;
  const cleanDate=formatScheduleDate(hdr);
  document.getElementById('sched-date').textContent=cleanDate||'';
  // Проверяем совпадение даты расписания с сегодняшней
  const dateM=hdr.match(/(\d{2})\.(\d{2})\.(\d{4})/);
  const today=new Date();
  let isToday=false;
  if(dateM){
    const sd=new Date(+dateM[3],+dateM[2]-1,+dateM[1]);
    isToday=(sd.getFullYear()===today.getFullYear()&&sd.getMonth()===today.getMonth()&&sd.getDate()===today.getDate());
  }
  const isMon=filename.toUpperCase().includes('ПОНЕДЕЛЬНИК');
  const bell=isMon?BELL_MON:BELL_TUE;
  const nowMin=today.getHours()*60+today.getMinutes();
  const body=document.getElementById('sched-body');body.innerHTML='';
  for(const[roman,lesson]of sched){
    const b=bell[roman];
    let isNow=false,isNext=false;
    if(isToday&&b&&b[0]){
      const[sh,sm]=b[0].split(':').map(Number);
      const endS=b[3]||b[1];
      const[eh,em]=endS.split(':').map(Number);
      const startMin=sh*60+sm,endMin=eh*60+em;
      isNow=nowMin>=startMin&&nowMin<=endMin;
      if(!isNow){const diff=startMin-nowMin;isNext=diff>0&&diff<=30;}
    }
    let lines=lesson?lesson.split('\n').map(l=>l.trim()).filter(Boolean):[];
    // Если преподаватель и кабинет слиты с названием предмета в одну строку — разделяем
    if(lines.length>0){
      const split=splitSubjectAndTeacher(lines[0]);
      if(split)lines=[split.subject,split.teacherStr,...lines.slice(1)];
    }
    const isEmpty=!lines.length;
    const card=document.createElement('div');
    card.className='pair-card'+(isEmpty?'':' has-subject')+(isNow?' is-now':isNext?' is-next':'');
    let badge='',remain='';
    if(isNow){
      badge='<span class="now-badge">● сейчас</span>';
      if(b&&b[1]){const endS=b[3]||b[1];const[eh,em]=endS.split(':').map(Number);const diff=(eh*60+em)-nowMin;remain=`<div class="pair-remain">${diff<=0?'заканч.':diff+' мин'}</div>`;}
    }else if(isNext){badge='<span class="now-badge next-badge">◎ скоро</span>';}
    let timesHtml='';
    if(b){
      const[s1,e1,s2,e2]=b;
      timesHtml=`<div class="pair-times"><div class="pair-time-row"><span class="pair-time-val">${s1} – ${e1}</span><span class="pair-time-tag">${s2?'1 урок':'60 мин'}</span></div>${s2?`<div class="pair-time-row"><span class="pair-time-val">${s2} – ${e2}</span><span class="pair-time-tag">2 урок</span></div>`:''}</div>`;
    }
    const detailsHtml=lines.length>1
      ?`<div class="pair-details">${lines.slice(1).map(l=>renderDetailLine(l)).join('<br>')}</div>`
      :'';
    card.innerHTML=`<div class="pair-top"><div class="pair-num">${roman}</div><div class="pair-subject-wrap"><div class="pair-subject${isEmpty?' empty':''}">${isEmpty?'Окно':lines[0]}</div>${badge}</div>${remain}</div>${timesHtml}${detailsHtml}`;
    body.appendChild(card);
  }
}

// ══ ПРИВЕТСТВИЕ ══
const APP_VERSION='3.1.7';
function getGreeting(){
  const now=new Date();
  const h=now.getHours();
  const dow=now.getDay(); // 0=вс, 6=сб
  const isWeekend=(dow===0||dow===6);
  if(isWeekend){
    if(h>=5&&h<12) return{greet:'Доброе утро',icon:'🛋',sub:'Сегодня выходной — отдыхай!'};
    if(h>=12&&h<17) return{greet:'Добрый день',icon:'😎',sub:'Хороших выходных!'};
    if(h>=17&&h<22) return{greet:'Добрый вечер',icon:'🌆',sub:'Наслаждайся вечером 🎉'};
    return{greet:'Доброй ночи',icon:'🌙',sub:'Выходные — не повод не спать 😅'};
  }
  if(h>=5&&h<12) return{greet:'Доброе утро',icon:'🌤',sub:'Хорошего учебного дня!'};
  if(h>=12&&h<17) return{greet:'Добрый день',icon:'☀️',sub:'Успехов на парах!'};
  if(h>=17&&h<22) return{greet:'Добрый вечер',icon:'🌇',sub:'Время отдохнуть.'};
  return{greet:'Доброй ночи',icon:'🌙',sub:'Не забудь поспать 😴'};
}
function showGreeting(){
  const ov=document.getElementById('greeting-overlay');
  if(!ov)return;
  const stored=loadSecret();
  if(stored.greetingOff){ov.classList.add('greet-hidden');return;}

  const now=new Date();
  const g=getGreeting();
  const hh=String(now.getHours()).padStart(2,'0');
  const mm=String(now.getMinutes()).padStart(2,'0');

  // Обновляем логотип и подзаголовок
  const logo=document.getElementById('greet-logo');
  const sub=document.getElementById('greet-sub');
  const time=document.getElementById('greet-time');
  if(logo) logo.textContent=g.icon;
  if(sub)  sub.textContent=g.sub;
  if(time) time.textContent=hh+':'+mm;

  // Typewriter — выводим буквы одна за одной
  const main=document.getElementById('greet-main');
  if(main){
    main.innerHTML='';
    const text=g.greet;
    text.split('').forEach((ch,i)=>{
      const span=document.createElement('span');
      span.className='greet-char';
      span.textContent=ch==' '?'\u00a0':ch;
      span.style.animationDelay=(i*55+80)+'ms';
      main.appendChild(span);
    });
  }

  // Частицы фона
  const pc=document.getElementById('greet-particles');
  if(pc){
    pc.innerHTML='';
    for(let i=0;i<12;i++){
      const p=document.createElement('div');
      p.className='greet-particle';
      const sz=4+Math.random()*8;
      p.style.cssText=`width:${sz}px;height:${sz}px;left:${Math.random()*100}%;bottom:${Math.random()*50}%;--dur:${2.5+Math.random()*2.5}s;--del:${Math.random()*2}s`;
      pc.appendChild(p);
    }
  }

  // Показываем overlay (он уже display:flex по умолчанию)
  ov.classList.remove('greet-hidden');

  // Скрываем через 2.2 сек
  setTimeout(skipGreeting, 2200);
}

function skipGreeting(){
  const ov=document.getElementById('greeting-overlay');
  if(!ov||ov.classList.contains('greet-hidden'))return;
  ov.classList.add('greet-hidden');
}

// ══ 4 ТАПА ПО ЗАГОЛОВКУ → CMD (только МПД-2-24) ══
let _schedTapCount=0,_schedTapTimer=null;
function initSchedTapTrigger(){
  const el=document.getElementById('sched-header-tap');
  if(!el)return;
  el.addEventListener('click',e=>{
    if(S.lastGroup!=='МПД-2-24')return;
    _schedTapCount++;
    clearTimeout(_schedTapTimer);
    _schedTapTimer=setTimeout(()=>{_schedTapCount=0;},800);
    if(_schedTapCount>=4){_schedTapCount=0;clearTimeout(_schedTapTimer);SFX.play('themeSelect');cmdOpen();}
  });
}

// ══ SECRET STORAGE ══
const SECRET_KEY='sched_secret';
function loadSecret(){try{return JSON.parse(stor.get(SECRET_KEY)||'{}')}catch(e){return{};}}
function saveSecret(obj){stor.set(SECRET_KEY,JSON.stringify(obj));}

// ══ РЕКОРДЫ МНИ-ИГР ══
const HI_KEY='sched_hiscores';
function loadHiScores(){try{return JSON.parse(stor.get(HI_KEY)||'{}');}catch(e){return{};}}
function saveHi(game,score){
  const h=loadHiScores();
  if(!h[game]||score>h[game]){h[game]=score;stor.set(HI_KEY,JSON.stringify(h));}
  return Math.max(score,h[game]||0);
}
function getHi(game){return loadHiScores()[game]||0;}

// ══ CMD-КОНСОЛЬ ══
const CMD_HELP=[
  ['/help',         'показать этот список'],
  ['/greeting',     'вкл/выкл приветствие  |  on|off'],
  ['/hiscores',     'рекорды мини-игр  |  reset — сбросить'],
  ['/version',      'информация о версии'],
  ['/group',        'текущая группа и файл'],
  ['/cache',        '[clear] — кэш файлов'],
  ['/theme',        'list|<n> — список тем или сменить'],
  ['/sound',        'вкл/выкл звуки  |  on|off'],
  ['/matrix',       'вкл/выкл Матрицу  |  on|off'],
  ['/snow',         'вкл/выкл снег  |  on|off'],
  ['/disco',        'вкл/выкл RGB диско  |  on|off|contrast <0-100>'],
  ['/glass',        'вкл/выкл Liquid Glass  |  on|off'],
  ['/shake',        'встряхнуть апп'],
  ['/time',         'сколько времени приложение работает'],
  ['/optimize',     'ядерная оптимизация памяти 🚀'],
  ['/fps',          'замерить FPS рендера'],
  ['/ram',          'оценить использование памяти'],
  ['/clear',        'очистить консоль'],
  ['/exit',         'закрыть консоль'],
  ['/uwu',          'активировать UwU-режим 🥺'],
  ['/gpt',          'спросить нейросеть 🤖 (умеет разное)'],
  ['/coffee',       'заварить кофе ☕'],
  ['/homework',     'сделать домашнее задание 📚'],
  ['/absent',       '<имя> — записать как отсутствующего 🙈'],
  ['/hack',         'взломать пентагон 💻'],
  ['/grade',        'поставить оценку (только 5)'],
  ['/summon',       'вызвать декана 😱'],
  ['/ascii',        'ASCII-баннер с группой'],
  ['/weather',      'прогноз погоды 🌤'],
  ['/selftest',     'системный тест приложения 🔬'],
  ['/horoscope',    'гороскоп студента на сегодня 🔮'],
  ['/roast',        'прожарка студента от ИИ 🔥'],
  ['/pair',         'совет как пережить пару 😴'],
  ['/yeet',         'законный выход из пары 🚪'],
  ['/ping',         'пинг до Яндекс Диска 📡'],
];
function cmdOpen(){
  const ov=document.getElementById('cmd-overlay');
  if(!ov)return;
  ov.style.display='flex';
  const body=document.getElementById('cmd-body');
  body.innerHTML='';
  cmdPrint('out','Microsoft Windows [Version 10.0.26100.3194]');
  cmdPrint('out','(c) Microsoft Corporation. Все права защищены.');
  cmdPrint('out','');
  cmdPrint('info','╔══════════════════════════════════════╗');
  cmdPrint('info','║  Schedule App v'+APP_VERSION+'  Dev Console  ║');
  cmdPrint('info','╚══════════════════════════════════════╝');
  cmdPrint('out','');
  cmdPrintHelp();
  cmdPrint('out','');
  setTimeout(()=>document.getElementById('cmd-input')?.focus(),80);
}
function cmdClose(){
  document.getElementById('cmd-overlay').style.display='none';
}
function cmdPrint(cls,text){
  const body=document.getElementById('cmd-body');
  const line=document.createElement('div');
  line.className='cmd-line '+cls;
  line.textContent=text;
  body.appendChild(line);
  body.scrollTop=body.scrollHeight;
}
function cmdPrintHelp(){
  cmdPrint('warn','Доступные команды:');
  CMD_HELP.forEach(([c,d])=>cmdPrint('ok','  '+c.padEnd(14)+' — '+d));
}
function cmdKey(e){
  if(e.key!=='Enter')return;
  const inp=document.getElementById('cmd-input');
  const raw=(inp.value||'').trim();
  inp.value='';
  if(!raw)return;
  cmdPrint('prompt','C:\\> '+raw);
  cmdExec(raw);
}
function cmdExec(raw){
  const parts=raw.split(/\s+/),cmd=parts[0].toLowerCase(),arg=(parts[1]||'').toLowerCase();
  const sec=loadSecret();
  switch(cmd){
    case '/help': cmdPrintHelp(); break;
    case '/greeting': {
      const sec2=loadSecret();
      const greetOn = !sec2.greetingOff;
      if(arg==='off'||(arg!=='on'&&greetOn)){sec2.greetingOff=true;saveSecret(sec2);cmdPrint('ok','Приветствие выключено.');}
      else{delete sec2.greetingOff;saveSecret(sec2);cmdPrint('ok','Приветствие включено.');}
    } break;
    case '/hiscores':{
      const GAME_NAMES={snake:'Змейка',pong:'Пинг-понг',tetris:'Тетрис',dino:'Динозаврик',
        blockblast:'Block Blast',breakout:'Арканоид',bubbles:'Пузыри',flappy:'Флаппи птица','2048':'2048'};
      if(arg==='reset'){stor.set(HI_KEY,'{}');cmdPrint('ok','Все рекорды сброшены.');}
      else{
        cmdPrint('info','── Рекорды мини-игр ──');
        const h=loadHiScores();
        let any=false;
        Object.entries(GAME_NAMES).forEach(([k,n])=>{
          cmdPrint(h[k]?'ok':'out','  '+(n+':').padEnd(18)+(h[k]||'нет'));any=true;
        });
        cmdPrint('prompt','  /hiscores reset — сбросить все');
      }
    } break;
    case '/version':
      cmdPrint('info','Версия приложения: '+APP_VERSION);
      cmdPrint('info','versionCode: 11');
      cmdPrint('info','Платформа: Android WebView');
      break;
    case '/group':
      cmdPrint('info','Группа: '+(S.lastGroup||'не выбрана'));
      cmdPrint('info','Файл: '+(S.selectedFile?.name||'—'));
      break;
    case '/cache':
      if(arg==='clear'){Object.keys(FILE_CACHE).forEach(k=>delete FILE_CACHE[k]);cmdPrint('ok','Кэш очищен.');}
      else cmdPrint('info','Файлов в кэше: '+Object.keys(FILE_CACHE).length+'.  /cache clear — для очистки.');
      break;
    case '/theme':
      if(arg==='list'){Object.entries(THEMES).forEach(([k,t])=>cmdPrint(S.theme===k?'ok':'out','  '+(k+(S.theme===k?' ✓':'')).padEnd(15)+t.name));}
      else if(arg&&THEMES[arg]){applyTheme(arg);cmdPrint('ok','Тема: '+THEMES[arg].name);}
      else if(arg)cmdPrint('err','Тема "'+arg+'" не найдена. /theme list');
      else cmdPrint('info','Тема: '+S.theme+'.  /theme list или /theme <name>');
      break;
    case '/sound': {
      const nowMuted = !!S.muted;
      if(arg==='on'||(arg!=='off'&&nowMuted)){S.muted=false;saveLocal();updateMuteLabel();cmdPrint('ok','🔊 Звук включён.');}
      else{S.muted=true;saveLocal();updateMuteLabel();cmdPrint('ok','🔇 Звук выключен.');}
    } break;
    case '/matrix': {
      const matrixOn = document.getElementById('matrix-canvas').classList.contains('active');
      if(arg==='on'||(arg!=='off'&&!matrixOn)){matrixStart();cmdPrint('ok','🟩 Матрица активирована. Красная таблетка принята.');}
      else{matrixStop();cmdPrint('ok','Матрица отключена.');}
    } break;
    case '/snow': {
      const snowOn = document.getElementById('snow-canvas').style.display!=='none';
      if(arg==='on'||(arg!=='off'&&!snowOn)){snowStart();cmdPrint('ok','❄️ Снег пошёл!');}
      else{snowStop();cmdPrint('ok','🌤 Снег остановлен.');}
    } break;
    case '/disco': {
      if(arg==='contrast'||arg==='intensity'){
        const val=parseInt(parts[2]);
        if(isNaN(val)||val<0||val>100){cmdPrint('err','Укажи значение 0..100. Пример: /disco contrast 60');break;}
        const sec2=loadSecret();sec2.discoIntensity=val;saveSecret(sec2);
        discoApplyIntensity(val);
        cmdPrint('ok','🎨 Интенсивность диско: '+val+'%'+(val===0?' (почти незаметно)':val<=40?' (мягкий режим)':val>=90?' (МАКСИМУМ 🔥)':''));
        if(!_discoActive){cmdPrint('info','Диско сейчас выключено. Включи: /disco on');}
        break;
      }
      if(arg==='on'||(arg!=='off'&&!_discoActive)){
        discoStart();
        const sec2=loadSecret();
        cmdPrint('warn','🕺 DISCO MODE ACTIVATED — ВЕЧЕРИНКА НАЧАЛАСЬ');
        cmdPrint('warn','💃 🎵 🎶 🪩 🔊 🎉 🌈 ✨ 🕺');
        cmdPrint('info','Интенсивность: '+(sec2.discoIntensity!=null?sec2.discoIntensity:100)+'%  (/disco contrast <0-100>)');
      } else {
        discoStop();cmdPrint('ok','😴 Дискотека закончилась. Уборщики пришли.');
      }
    } break;
    case '/glass': {
      if(arg==='on'||(arg!=='off'&&!S.liquidGlass)){
        S.liquidGlass=true;applyGlassMode(true);cmdPrint('ok','🫧 Liquid Glass включён.');
      } else {
        S.liquidGlass=false;S.liquidGlassOpt=false;applyGlassMode(true);cmdPrint('ok','Liquid Glass выключен.');
      }
    } break;
    case '/shake':
      cmdPrint('warn','💥 ВАУ!');
      document.body.classList.remove('shaking');
      document.body.offsetHeight;
      document.body.classList.add('shaking');
      setTimeout(()=>document.body.classList.remove('shaking'),500);
      break;
    case '/time':{
      const upMs=performance.now();
      const upS=Math.floor(upMs/1000);
      const m=Math.floor(upS/60),s=upS%60;
      cmdPrint('info',`Приложение работает: ${m} мин ${s} сек`);
      cmdPrint('info',`Сейчас: ${new Date().toLocaleString('ru')}`);
    } break;
    case '/exit':
      cmdPrint('out','Выход...');
      setTimeout(cmdClose,500);
      break;
    case '/uwu': {
      const uwuFaces=['(ᵔᴥᵔ)','(◕‿◕✿)','(｡◕‿◕｡)','ʕ•ᴥ•ʔ','(≧◡≦)','UwU','OwO'];
      const uwuPhrases=['UwU режим аwтивирован, сенпай замечен OwO','*виляет хвостиком* расписание уже не страшное nyaa~','тебе нужна помощь, чтобы не опоздать на пару? (≧◡≦)','все пары отменены! ...нет, это не так (｡•́︿•̀｡)','мяу~ *мурчит* пары сегодня есть, но ты справишься UwU'];
      const face=uwuFaces[Math.floor(Math.random()*uwuFaces.length)];
      const phrase=uwuPhrases[Math.floor(Math.random()*uwuPhrases.length)];
      cmdPrint('ok',face+' '+phrase);
      // Вместо Comic Sans (плохо работает с кириллицей) — используем CSS-трансформации
      const style=document.createElement('style');
      style.id='uwu-style';
      // Курсивный встроенный шрифт + увеличенный tracking — работает с кириллицей
      style.textContent=`body:not(.cmd-overlay){font-style:italic!important;letter-spacing:.04em!important}
        .pair-subject,.item-name,.hero-title,.greet-main{transform:rotate(-1.5deg) scale(1.01)!important;display:inline-block!important}
        *{transition:transform .3s,letter-spacing .3s!important}`;
      document.head.appendChild(style);
      cmdPrint('warn','⚠️ UwU-режим: интерфейс слегка сошёл с ума на 10 секунд nyaa~');
      setTimeout(()=>{
        const s=document.getElementById('uwu-style');
        if(s)s.remove();
        cmdPrint('ok','UwU-режим деактивирован. Грустно (｡•́︿•̀｡)');
      },10000);
    } break;
    case '/gpt': {
      const userQ=(parts.slice(1).join(' ')||'').trim();
      if(!userQ){cmdPrint('err','Использование: /gpt <вопрос>');break;}
      cmdPrint('info','🤖 Обрабатываю запрос...');
      const q=userQ.toLowerCase();
      // Keyword-based ответы
      let gptReply='';
      if(/пар[аы]|расписани|урок|лекци|семинар/.test(q)){
        const pairs=['Следующая пара начинается ровно тогда, когда ты этого не ждёшь.','Расписание — это просто рекомендация. Преподаватели так не думают.','Согласно моим данным, пары отменены. Ложь, но красивая.','Количество пар конечно. Количество желания на них идти — нет.'];
        gptReply=pairs[Math.floor(Math.random()*pairs.length)];
      } else if(/препод|учитель|преподаватель|профессор/.test(q)){
        gptReply='Преподаватели — загадочные создания. Говорят на 2 скорости: "слишком быстро" и "зачем ты вообще пришёл".';
      } else if(/ответ|задач|домашн|дз/.test(q)){
        const hw=['Ответ: 42. Вопрос уточни потом.','Решение есть, но оно покрыто мраком дедлайнов.','ERROR: ответ существует только у тех, кто слушал на лекции.','Попробуй метод случайного тыка. Работает в 23% случаев.'];
        gptReply=hw[Math.floor(Math.random()*hw.length)];
      } else if(/погод|дожд|снег|тепло/.test(q)){
        gptReply='Я нейросеть внутри APK, погоду не знаю. Но могу сказать: шансы на дождь = вероятность что ты взял зонт.';
      } else if(/любовь|нравится|влюб/.test(q)){
        gptReply='Это не по моей специальности. Я знаю только одно: лучший способ произвести впечатление — не опаздывать на пары.';
      } else if(/помог|помощь|помоги|не знаю/.test(q)){
        gptReply='Я слышу тебя. Но мои советы работают ровно так же, как готовые ответы из интернета — красиво, но 50/50.';
      } else if(/жизнь|смысл|зачем|почему/.test(q)){
        const existential=['Смысл жизни — добраться до последней пары пятницы.','Великие умы задавали тот же вопрос. Ни один не нашёл ответ до зачёта.','Согласно последним исследованиям: кофе. Ответ — кофе.'];
        gptReply=existential[Math.floor(Math.random()*existential.length)];
      } else if(/привет|хай|здравствуй/.test(q)){
        gptReply='Привет! Я GPT-mini, встроенный в твоё расписание. Мощь — бесконечна. Полезность — сомнительна. 🤖';
      } else {
        const generic=['Это интересный вопрос! Но сначала скажи мне три факта о себе.','Анализирую... Анализирую... ошибка анализа. Попробуй спросить проще.','ERROR 402: недостаточно токенов. Пополни баланс 💳','Согласно последним исследованиям MIT, лучше спросить преподавателя.','Ответ прост: это зависит от контекста, предпосылок, условий, парадигмы и времени суток.','Я обработал твой запрос и пришёл к выводу: тебе нужен перерыв. Рекомендую чай.'];
        gptReply=generic[Math.floor(Math.random()*generic.length)];
      }
      setTimeout(()=>{
        cmdPrint('ok','🤖 GPT: '+gptReply);
      },900+Math.random()*600);
    } break;
    case '/coffee': {
      const steps=['☕ Ищу кофемашину...','💧 Наливаю воду...','🫘 Засыпаю зерна...','🔥 Нагреваю...','✨ Готово!'];
      let i=0;
      const brew=setInterval(()=>{
        cmdPrint(i<steps.length-1?'info':'ok',steps[i]);
        i++;
        if(i>=steps.length){
          clearInterval(brew);
          cmdPrint('warn','☕ Кофе готов! Только он виртуальный. Сходи за настоящим :(');
        }
      },600);
    } break;
    case '/homework': {
      const subjects=['математика','физика','история','русский язык','информатика','химия'];
      cmdPrint('info','📚 Запускаю алгоритм выполнения ДЗ...');
      const subj=subjects[Math.floor(Math.random()*subjects.length)];
      setTimeout(()=>cmdPrint('info','📖 Открываю учебник по теме: '+subj+'...'),700);
      setTimeout(()=>cmdPrint('info','🔍 Сканирую интернет на предмет ответов...'),1400);
      setTimeout(()=>cmdPrint('warn','⚠️ Найдено 47 готовых решений, но все неправильные.'),2200);
      setTimeout(()=>cmdPrint('err','❌ КРИТИЧЕСКАЯ ОШИБКА: мозг студента не найден. Придётся думать самому.'),3000);
      setTimeout(()=>cmdPrint('ok','💡 Совет: попробуй открыть учебник. Говорят, там ответы.'),3800);
    } break;
    case '/absent': {
      const name=(parts.slice(1).join(' ')||'Кто-то').trim();
      cmdPrint('info','🙈 Записываю '+name+' как отсутствующего...');
      setTimeout(()=>cmdPrint('ok','✅ '+name+' официально "болен". Причина: ОРЗ, ОРВИ, и ещё 3 буквы.'),800);
      setTimeout(()=>cmdPrint('warn','📋 Журнал обновлён. Или нет. Это всё равно ничего не меняет.'),1500);
    } break;
    case '/hack': {
      const steps2=[
        'Инициализация хакерского режима...',
        'Подключение к серверам Пентагона... 1.2.3.4:80',
        'Обход файрволла... ████████░░ 80%',
        'Загрузка вирусов... malware.exe, sudo.bat',
        'Взлом шифрования SHA-9999...',
        '> ACCESS GRANTED to... ой.',
      ];
      let si=0;
      document.getElementById('cmd-body').style.color='#00ff41';
      const hackInterval=setInterval(()=>{
        cmdPrint('ok',steps2[si++]);
        if(si>=steps2.length){
          clearInterval(hackInterval);
          setTimeout(()=>{
            cmdPrint('err','❌ Пентагон отозвал приглашение. Причина: ты студент.'),
            document.getElementById('cmd-body').style.color='';
          },1000);
        }
      },550);
    } break;
    case '/grade': {
      const gradeNames=['алгебра','физическая культура','история','инфа','черчение'];
      const subj2=gradeNames[Math.floor(Math.random()*gradeNames.length)];
      cmdPrint('info','📝 Открываю электронный журнал...');
      setTimeout(()=>cmdPrint('info','✏️ Ставлю оценку по предмету: '+subj2+'...'),800);
      setTimeout(()=>cmdPrint('warn','🔒 ДОСТУП ЗАПРЕЩЁН. Только преподаватели могут ставить оценки.'),1600);
      setTimeout(()=>cmdPrint('err','Хотя... если бы мог, поставил бы тебе 5. Честно.'),2400);
    } break;
    case '/summon': {
      cmdPrint('warn','😱 ВЫЗОВ ДЕКАНА...');
      matrixStart();
      setTimeout(()=>{
        matrixStop();
        cmdPrint('ok','✨ Декан вызван... и сразу ушёл на собрание.');
        cmdPrint('info','Попробуй снова через 3-4 учебных часа.');
      },4000);
    } break;
    case '/optimize': {
      cmdPrint('warn','🚀 ЯДЕРНАЯ ОПТИМИЗАЦИЯ ЗАПУЩЕНА...');
      let freed=0;
      setTimeout(()=>{
        // 1. Очищаем файловый кэш (только данные, не работающие ссылки)
        const cacheCount=Object.keys(FILE_CACHE).length;
        Object.keys(FILE_CACHE).forEach(k=>delete FILE_CACHE[k]);
        freed+=cacheCount;
        cmdPrint('ok',`  ✓ Файловый кэш очищен (${cacheCount} записей)`);
      },300);
      setTimeout(()=>{
        // 2. Убираем старые DOM-элементы из неактивных игровых canvases
        ['matrix-canvas','snow-canvas'].forEach(id=>{
          const c=document.getElementById(id);
          if(c&&!_matrixRunning&&!_snowRunning){const ctx=c.getContext('2d');if(ctx)ctx.clearRect(0,0,c.width,c.height);freed++;}
        });
        cmdPrint('ok','  ✓ Неактивные canvas-буферы очищены');
      },700);
      setTimeout(()=>{
        // 3. Сбрасываем временные стили
        const uwuStyle=document.getElementById('uwu-style');
        if(uwuStyle){uwuStyle.remove();freed++;}
        // 4. Trim игровых списков (ограничиваем историю консоли)
        const body=document.getElementById('cmd-body');
        if(body&&body.children.length>80){
          while(body.children.length>60)body.removeChild(body.firstChild);
          freed+=20;
        }
        cmdPrint('ok','  ✓ Временные стили и буферы сброшены');
      },1100);
      setTimeout(()=>{
        cmdPrint('ok','  ✓ Принудительный garbage collect (GC подсказка отправлена)');
        cmdPrint('warn','');
        cmdPrint('ok',`🏁 Оптимизация завершена. Очищено ~${freed} объектов.`);
        cmdPrint('info','  Функциональность сохранена. Расписание работает.');
      },1600);
    } break;
    case '/fps': {
      cmdPrint('info','📊 Замеряю FPS...');
      let frames=0,startT=performance.now();
      const rafLoop=()=>{
        frames++;
        if(performance.now()-startT<1000)requestAnimationFrame(rafLoop);
        else{
          const fps=Math.round(frames*1000/(performance.now()-startT));
          const quality=fps>=55?'ok':fps>=30?'warn':'err';
          cmdPrint(quality,`📊 FPS: ${fps} (${fps>=55?'отлично':fps>=30?'нормально':'низкий'})`);
          if(fps<30)cmdPrint('warn','  Совет: /optimize или закрой фоновые приложения');
        }
      };
      requestAnimationFrame(rafLoop);
    } break;
    case '/ram': {
      cmdPrint('info','💾 Анализирую память...');
      setTimeout(()=>{
        const domNodes=document.querySelectorAll('*').length;
        const cacheItems=Object.keys(FILE_CACHE).length;
        const perf=performance?.memory;
        if(perf){
          const used=Math.round(perf.usedJSHeapSize/1024/1024*10)/10;
          const total=Math.round(perf.totalJSHeapSize/1024/1024*10)/10;
          cmdPrint('info',`  JS Heap: ${used} МБ / ${total} МБ`);
        }
        cmdPrint('info',`  DOM-узлов: ${domNodes}`);
        cmdPrint('info',`  Файлов в кэше: ${cacheItems}`);
        const quality=cacheItems>20||domNodes>2000?'warn':'ok';
        cmdPrint(quality,quality==='ok'?'  Память в норме 👍':'  Рекомендую /optimize');
      },400);
    } break;
    case '/clear': {
      const body=document.getElementById('cmd-body');
      if(body){body.innerHTML='';}
      cmdPrint('ok','Консоль очищена.');
    } break;
    case '/ascii': {
      const grp=S.lastGroup||'МПД-2-24';
      cmdPrint('out','┌─────────────────────────┐');
      cmdPrint('out','│  ScheduleApp v'+APP_VERSION+'       │');
      cmdPrint('out','│  Группа: '+grp.padEnd(15)+'│');
      cmdPrint('out','│  🏫 Колледж Расписание   │');
      cmdPrint('out','└─────────────────────────┘');
      cmdPrint('ok','ASCII баннер сгенерирован 🎨');
    } break;
    case '/weather': {
      const weathers=[
        {ico:'☀️',desc:'Солнечно, +22°C. Идеально для прогула пары.',cls:'ok'},
        {ico:'🌧',desc:'Дождь весь день. Отличный повод не выходить.',cls:'info'},
        {ico:'❄️',desc:'Снег, -8°C. Занятия точно отменят... или нет.',cls:'warn'},
        {ico:'⛅',desc:'Переменная облачность. Как твои знания по предмету.',cls:'out'},
        {ico:'⚡',desc:'Гроза. Метеослужба рекомендует сидеть дома.',cls:'err'},
      ];
      const w=weathers[Math.floor(Math.random()*weathers.length)];
      cmdPrint('info','🌍 Получаю данные...');
      setTimeout(()=>cmdPrint(w.cls,w.ico+' '+w.desc),700);
    } break;
    case '/selftest': {
      cmdPrint('warn','🔬 СИСТЕМНЫЙ ТЕСТ...');
      const tests=[
        ['localStorage',()=>{try{localStorage.setItem('_t','1');localStorage.removeItem('_t');return true;}catch(e){return false;}}],
        ['Canvas 2D',()=>{const c=document.createElement('canvas');return !!c.getContext('2d');}],
        ['requestAnimationFrame',()=>typeof requestAnimationFrame==='function'],
        ['Файловый кэш',()=>typeof FILE_CACHE==='object'],
        ['Темы',()=>Object.keys(THEMES||{}).length>0],
        ['Группа выбрана',()=>!!(S.lastGroup)],
        ['Звук',()=>!S.muted],
      ];
      tests.forEach(([name,fn],i)=>{
        setTimeout(()=>{
          let ok=false;try{ok=fn();}catch(e){}
          cmdPrint(ok?'ok':'err',`  ${ok?'✓':'✗'} ${name}`);
          if(i===tests.length-1)setTimeout(()=>cmdPrint('info','🏁 Тест завершён'),100);
        },i*200);
      });
    } break;
    case '/horoscope': {
      const signs=['Овен','Телец','Близнецы','Рак','Лев','Дева','Весы','Скорпион','Стрелец','Козерог','Водолей','Рыбы'];
      const sign=signs[new Date().getDate()%12];
      const predictions=[
        `Звёзды говорят: сдашь зачёт. Но пересдашь его дважды.`,
        `Меркурий в ретрограде — отличный повод не делать домашнее задание.`,
        `Сегодня благоприятный день для... перекладывания учебников с места на место.`,
        `Луна в ${sign} предвещает: преподаватель сегодня добрый. Или нет. 50/50.`,
        `Сатурн намекает: пора закрыть 47 вкладок и открыть конспект.`,
        `Ваш счастливый номер: пара которую вы пропустите. Вы знаете какая.`,
        `Козерог шепчет: кто-то другой сдаст за тебя? Нет. Увы.`,
        `Звёзды сошлись в созвездие "Всё будет нормально". Врут.`,
      ];
      cmdPrint('warn', `🔮 Гороскоп студента (${new Date().toLocaleDateString('ru')})`);
      cmdPrint('info', `  Знак: ${sign}`);
      setTimeout(()=>cmdPrint('out', '  ' + predictions[new Date().getDate() % predictions.length]), 600);
      setTimeout(()=>cmdPrint('ok', '  Удачи. Она понадобится.'), 1300);
    } break;

    case '/roast': {
      const roasts=[
        ['🔥 Анализирую учебную карму...', 'Твой средний балл, судя по всему, — как температура в аудитории зимой: около нуля.'],
        ['🔥 Сканирую посещаемость...', 'Ты бываешь в колледже реже, чем солнце в ноябре. Но хотя бы стабильно.'],
        ['🔥 Оцениваю конспекты...', 'Твои записи такие подробные, что ты сам их не понимаешь. Уважаю.'],
        ['🔥 Измеряю силу воли...', 'Ты открыл приложение расписания. Это уже 80% успеха. Остальное — явиться туда.'],
        ['🔥 Проверяю домашку...', 'Ты точно делал домашнее задание? Или просто надеялся, что никто не спросит? Правильно.'],
      ];
      const r=roasts[Math.floor(Math.random()*roasts.length)];
      cmdPrint('warn', r[0]);
      setTimeout(()=>cmdPrint('err', '  ' + r[1]), 1000);
      setTimeout(()=>cmdPrint('ok', '  (Это шутка. Ты молодец что учишься. Серьёзно.)'), 2200);
    } break;

    case '/pair': {
      const tips=[
        '😴 Положи голову на руки. Это не сон — это "глубокое осмысление материала".',
        '📱 Открой приложение расписания. Вдруг следующей пары нет? Надежда умирает последней.',
        '✏️ Рисуй в тетради. Искусство — тоже образование.',
        '🧃 Достань еду. Медленно. Шурши. Дай всем понять что ты здесь.',
        '💬 Задай преподавателю вопрос не по теме. Это убивает до 15 минут пары.',
        '🪟 Смотри в окно. Философски. Как будто постигаешь суть бытия.',
        '📖 Открой учебник. НЕ читай. Просто держи перед собой — выглядит убедительно.',
        '⏰ Смотри на часы каждые 2 минуты. Время не ускорится, но так честнее.',
      ];
      cmdPrint('warn', '😴 СОВЕТ КАК ПЕРЕЖИТЬ ПАРУ:');
      setTimeout(()=>cmdPrint('ok', '  ' + tips[Math.floor(Math.random()*tips.length)]), 500);
    } break;

    case '/yeet': {
      cmdPrint('warn', '🚪 ГЕНЕРИРУЮ ЗАКОННЫЙ ВЫХОД ИЗ ПАРЫ...');
      const excuses=[
        'Скажи что у тебя "встреча с куратором". Звучит солидно.',
        'Сообщи что "вызвали в деканат". Никто не проверяет.',
        '"Мне плохо" — классика жанра. Вечная классика.',
        'Подними руку: "Можно выйти?" — и не возвращайся 40 минут.',
        'Притворись что получил важное сообщение. Выйди "на 1 минуту".',
        'Скажи что забыл тетрадь. Уйди за ней. Телепортируйся домой.',
      ];
      setTimeout(()=>cmdPrint('info', '  Метод: ' + excuses[new Date().getMinutes()%excuses.length]), 800);
      setTimeout(()=>cmdPrint('err',  '  ⚠️ Это шутка. Ходи на пары, знания пригодятся.'), 1800);
      setTimeout(()=>cmdPrint('ok',   '  Хотя это расписание явно помогает. 😌'), 2500);
    } break;

    case '/ping': {
      const startT=performance.now();
      cmdPrint('info', '📡 Пингую cloud-api.yandex.net...');
      const pingUrl='https://cloud-api.yandex.net/v1/disk';
      const doPing=(attempt)=>{
        const t0=performance.now();
        if(window.Android&&window.Android.nativeFetch){
          setTimeout(()=>{
            try{
              window.Android.nativeFetch(pingUrl);
              const ms=Math.round(performance.now()-t0);
              const q=ms<150?'ok':ms<400?'warn':'err';
              cmdPrint(q,`  [${attempt}] ${ms} мс — ${ms<150?'🟢 отлично':ms<400?'🟡 норм':'🔴 медленно'}`);
            }catch(e){cmdPrint('err',`  [${attempt}] ошибка: `+e.message);}
          },0);
        } else {
          fetch(pingUrl,{method:'HEAD',mode:'no-cors',cache:'no-store'})
            .then(()=>cmdPrint('ok',`  [${attempt}] ${Math.round(performance.now()-t0)} мс — 🟢 ок`))
            .catch(()=>cmdPrint('warn',`  [${attempt}] ${Math.round(performance.now()-t0)} мс — CORS`));
        }
      };
      setTimeout(()=>doPing(1), 100);
      setTimeout(()=>doPing(2), 700);
      setTimeout(()=>doPing(3), 1300);
      setTimeout(()=>cmdPrint('info',`  Готово. Общее время: ${Math.round(performance.now()-startT+1300)} мс`), 1900);
    } break;

    default:
      cmdPrint('err','"'+cmd+'" не найдена. Введи /help');
  }
}

// ══ ЗВОНКИ ══
function renderBells(){
  const body=document.getElementById('bells-body');
  const day=(title,bell)=>{
    let h=`<div class="bell-day">${title}</div>`;
    Object.entries(bell).forEach(([num,[s1,e1,s2,e2]])=>{
      h+=`<div class="bell-card"><div class="bell-num">${num}</div><div class="bell-slots"><div class="bell-slot"><span class="bell-slot-time">${s1} – ${e1}</span><span class="bell-slot-tag">${s2?'1 урок':'60 мин'}</span></div>${s2?`<div class="bell-slot"><span class="bell-slot-time">${s2} – ${e2}</span><span class="bell-slot-tag">2 урок</span></div>`:''}</div></div>`;
    });
    return h;
  };
  body.innerHTML=day('Понедельник',BELL_MON)+day('Вторник – Пятница',BELL_TUE);
}

// ══ УТИЛИТЫ ══
function setStatus(id,t){const el=document.getElementById(id);if(el)el.textContent=t;}
function setBar(id,v){const el=document.getElementById(id);if(el)el.style.width=v+'%';}
let _tt;
function toast(msg){SFX.play('toastShow');const el=document.getElementById('toast');el.textContent=msg;el.classList.add('show');clearTimeout(_tt);_tt=setTimeout(()=>el.classList.remove('show'),2500);}

// ══ DPI ТЕСТИРОВАНИЕ ══
const TEST_URLS = [
  'https://1.1.1.1/cdn-cgi/trace',
  'https://www.google.com/generate_204',
  'https://connectivitycheck.gstatic.com/generate_204'
];
let dpiTestActive = false;
let dpiWorkingIds = null; // null = не тестировалось, [] = результаты теста

async function testUrl(timeout = 4000) {
  for (const url of TEST_URLS) {
    try {
      const r = await Promise.race([
        fetch(url, { method: 'HEAD', cache: 'no-store', mode: 'no-cors' }),
        new Promise((_, rej) => setTimeout(() => rej(new Error('timeout')), timeout))
      ]);
      return true;
    } catch (e) { continue; }
  }
  return false;
}

async function testAllDpi() {
  if (dpiTestActive) return;
  dpiTestActive = true;

  // Используем элементы экрана DPI
  const btn     = document.getElementById('dpi-test-btn2');
  const block   = document.getElementById('dpi-test-block2');
  const bar     = document.getElementById('dpi-test-bar2');
  const status  = document.getElementById('dpi-test-status2');
  const badges  = document.getElementById('dpi-result-badges2');
  const showAllBtn = document.getElementById('dpi-show-all-btn2');
  const label   = document.getElementById('dpi-screen-label');

  if(btn) { btn.disabled = true; btn.innerHTML = '⏳ Тестирование...'; }
  if(block) block.style.display = 'block';
  if(badges) badges.innerHTML = '';
  if(showAllBtn) showAllBtn.style.display = 'none';
  if(bar) bar.style.width = '0%';

  const working = [];
  const total = DPI_STRATEGIES.length;

  for (let i = 0; i < total; i++) {
    const strat = DPI_STRATEGIES[i];
    const pct = Math.round(((i) / total) * 100);
    if(bar) bar.style.width = pct + '%';
    if(status) status.textContent = `Тестирую ${i + 1}/${total}: ${strat.name}...`;

    // Создать бейдж "в процессе"
    const badge = document.createElement('span');
    badge.className = 'test-badge testing';
    badge.id = 'tbadge-' + strat.id;
    badge.textContent = strat.badge;
    if(badges) badges.appendChild(badge);

    // Применить стратегию через Android
    if (window.Android?.setDpiStrategy) {
      window.Android.setDpiStrategy(strat.id);
      await new Promise(r => setTimeout(r, 600)); // дать время VPN применить
    } else {
      await new Promise(r => setTimeout(r, 150)); // без Android — просто симуляция
    }

    // Тест соединения
    let ok;
    if (window.Android?.setDpiStrategy) {
      ok = await testUrl(4000);
    } else {
      // В браузере без Android: симулируем — помечаем "основной" и несколько alt как рабочие
      const simulatedWorking = ['general', 'alt', 'simpleFake'];
      ok = simulatedWorking.includes(strat.id) || Math.random() > 0.7;
      await new Promise(r => setTimeout(r, 80));
    }

    badge.className = 'test-badge ' + (ok ? 'ok' : 'fail');
    badge.textContent = (ok ? '✓ ' : '✗ ') + strat.badge;
    if (ok) working.push(strat.id);
  }

  bar.style.width = '100%';
  dpiWorkingIds = working;

  if (working.length > 0) {
    if(status) status.textContent = `✅ Работает: ${working.length} из ${total} стратегий`;
    // Если текущая выбранная стратегия не рабочая — переключить на первую рабочую
    if (!working.includes(S.dpi)) {
      selectDpi(working[0]);
    } else {
      // Восстановить текущую
      if (window.Android?.setDpiStrategy) window.Android.setDpiStrategy(S.dpi);
    }
    if(label) label.textContent = 'Рабочие стратегии (' + working.length + ')';
    if(showAllBtn) showAllBtn.style.display = 'block';
  } else {
    if(status) status.textContent = '⚠️ Не удалось определить рабочие стратегии';
    dpiWorkingIds = null;
  }

  renderDpiList();
  updateDpiCurrentRow();
updateThemeCurrentRow();
  if(btn) { btn.disabled = false; btn.innerHTML = '🔄 Повторить тест'; }
  dpiTestActive = false;
  setTimeout(() => { if(bar) bar.style.width = '0%'; }, 1500);
}

function showAllDpi() {
  dpiWorkingIds = null;
  const label2 = document.getElementById('dpi-screen-label');
  const btn2   = document.getElementById('dpi-show-all-btn2');
  if (label2) label2.textContent = 'Все стратегии';
  if (btn2)   btn2.style.display = 'none';
  renderDpiList();
  updateDpiCurrentRow();
updateThemeCurrentRow();
  toast('Показаны все стратегии');
}

// ══ INIT ══
loadLocal();
applyTheme(S.theme);
applyGlassMode(false);
applyCustomBg();
updateBgUI();
updateMuteLabel();
// Логируем инициализацию
setTimeout(function(){
  if(window.Android&&window.Android.logMsg){
    window.Android.logMsg('INFO','index.html: JS инициализация началась');
    window.Android.logMsg('INFO','index.html: тема='+S.theme+' dns='+S.dns+' dpi='+S.dpi+' url='+S.url.substring(0,40));
    window.Android.logMsg('INFO','index.html: Android bridge = '+(window.Android?'доступен':'НЕ ДОСТУПЕН'));
    window.Android.logMsg('INFO','index.html: localStorage = '+(function(){try{localStorage.setItem('t','1');localStorage.removeItem('t');return 'работает';}catch(e){return 'НЕДОСТУПЕН: '+e.message;}})());
  }
}, 300);
renderBells();
updateLastGroupBtn();
updateNavActive('nav-home');
updateThemeCurrentRow();
initIconPicker();
initSchedTapTrigger();
document.getElementById('url-input').value=S.url;

loadFiles();
showGreeting();

// ══ Восстанавливаем состояние секретных команд ══
(function restoreSecretState(){
  const sec=loadSecret();
  if(sec.discoIntensity!=null) discoApplyIntensity(sec.discoIntensity);
  if(sec.disco){discoStart();}
  if(sec.snow){snowStart();}
  // /sound восстанавливается через S.muted в loadLocal()
})();

// ══ OTA обновление ══
// ⚠️ CLAUDE: при каждом изменении кода — обновляй эту версию!

// Показываем текущую версию в настройках (APP_VERSION определён выше)
(function(){
  const el = document.getElementById('app-version-str');
  if (el) el.textContent = APP_VERSION + ' — Android';
})();

// ── Автопроверка при запуске отключена — проверка вручную через кнопку в настройках ──

// ── Состояние OTA ──
// _otaApkUrl и _otaVersion объявлены в начале файла

function otaOpen(version, apkUrl, notes) {
  _otaApkUrl = apkUrl;
  _otaVersion = version;
  document.getElementById('ota-version-label').textContent =
    'v' + APP_VERSION + '  →  v' + version;
  const notesEl = document.getElementById('ota-notes-text');
  if (notes && notes.trim()) {
    notesEl.textContent = notes.trim();
    notesEl.classList.add('has-text');
  } else {
    notesEl.classList.remove('has-text');
  }
  document.getElementById('ota-progress-wrap').classList.add('hidden');
  document.getElementById('ota-progress-bar').style.width = '0%';
  document.getElementById('ota-progress-label').textContent = 'Скачивание...';
  const dlBtn = document.getElementById('ota-dl-btn');
  dlBtn.disabled = false;
  dlBtn.textContent = '⬇ Скачать и установить';
  document.getElementById('ota-cancel-btn').disabled = false;
  document.getElementById('ota-overlay').classList.add('show');
}

function otaClose() {
  document.getElementById('ota-overlay').classList.remove('show');
}

function otaOverlayClose(e) {
  if (e.target === document.getElementById('ota-overlay')) otaClose();
}

async function otaStartDownload() {
  if (!_otaApkUrl) { toast('❌ URL APK не найден'); return; }
  const dlBtn = document.getElementById('ota-dl-btn');
  const cancelBtn = document.getElementById('ota-cancel-btn');
  const wrap = document.getElementById('ota-progress-wrap');
  const bar = document.getElementById('ota-progress-bar');
  const label = document.getElementById('ota-progress-label');
  dlBtn.disabled = true;
  dlBtn.textContent = '⏳ Скачиваю...';
  cancelBtn.disabled = true;
  wrap.classList.remove('hidden');

  let fakeProgress = 0;
  const fakeTimer = setInterval(() => {
    if (fakeProgress < 88) {
      fakeProgress += (88 - fakeProgress) * 0.05 + 0.5;
      bar.style.width = Math.min(fakeProgress, 88) + '%';
      label.textContent = Math.round(Math.min(fakeProgress, 88)) + '% — Скачиваю...';
    }
  }, 150);

  try {
    if (window.Android && window.Android.downloadAndInstallApk) {
      clearInterval(fakeTimer);
      bar.style.width = '100%';
      label.textContent = '100% — Запускаю установщик...';
      window.Android.downloadAndInstallApk(_otaApkUrl);
      setTimeout(() => otaClose(), 1200);
    } else {
      clearInterval(fakeTimer);
      bar.style.width = '100%';
      label.textContent = 'Открываю браузер...';
      if (window.Android && window.Android.openUrl) {
        window.Android.openUrl(_otaApkUrl);
      } else {
        window.open(_otaApkUrl, '_blank');
      }
      setTimeout(() => otaClose(), 800);
    }
  } catch(e) {
    clearInterval(fakeTimer);
    dlBtn.disabled = false;
    dlBtn.textContent = '⬇ Попробовать снова';
    cancelBtn.disabled = false;
    label.textContent = '❌ ' + e.message;
    bar.style.width = '0%';
  }
}

function compareVersions(a, b) {
  const pa = (a || '').split('.').map(Number);
  const pb = (b || '').split('.').map(Number);
  for (let i = 0; i < Math.max(pa.length, pb.length); i++) {
    const diff = (pa[i] || 0) - (pb[i] || 0);
    if (diff !== 0) return diff > 0 ? 1 : -1;
  }
  return 0;
}

async function checkOtaUpdate(silent) {
  const btn = document.querySelector('[onclick="checkOtaUpdate()"]');
  if (!silent && btn) { btn.disabled = true; btn.textContent = '⏳'; }
  try {
    const baseApi = 'https://api.github.com/repos/LomKich/ScheduleApp/releases';

    async function ghFetch(url) {
      if (window.Android && window.Android.nativeFetch) {
        // Оборачиваем синхронный @JavascriptInterface в Promise+setTimeout
        // чтобы не блокировать JS event loop на время HTTP запроса
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            try {
              const resStr = window.Android.nativeFetch(url);
              const res = JSON.parse(resStr);
              if (!res.ok) {
                const err = new Error(res.error || 'HTTP ' + res.status);
                err.status = res.status;
                reject(err);
              } else {
                resolve(JSON.parse(res.body));
              }
            } catch(e) { reject(e); }
          }, 0);
        });
      } else {
        const r = await fetch(url);
        if (!r.ok) { const err = new Error('HTTP ' + r.status); err.status = r.status; throw err; }
        return r.json();
      }
    }

    let data;
    try {
      data = await ghFetch(baseApi + '/latest');
    } catch(e) {
      if (e.status === 404) {
        const all = await ghFetch(baseApi + '?per_page=5');
        if (!Array.isArray(all) || all.length === 0) {
          if (!silent) toast('❌ В репозитории нет релизов');
          return;
        }
        data = all[0];
      } else { throw e; }
    }

    const rawTag    = (data.tag_name || '').trim();
    const latestTag = rawTag.replace(/^v/i, '');
    const apkAsset  = (data.assets || []).find(a => a.name && a.name.endsWith('.apk'));

    if (!latestTag) { if (!silent) toast('❌ Не удалось определить версию'); return; }

    const isNewer = compareVersions(latestTag, APP_VERSION) > 0;
    if (!isNewer) {
      if (!silent) toast('✅ Версия ' + APP_VERSION + ' актуальна');
      return;
    }

    if (apkAsset) {
      otaOpen(latestTag, apkAsset.browser_download_url, data.body || '');
    } else {
      if (!silent) toast('🆕 v' + latestTag + ' — APK не прикреплён к релизу');
    }
  } catch(e) {
    if (!silent) toast('❌ ' + e.message);
  }
  if (!silent && btn) { btn.disabled = false; btn.textContent = '🔄 Проверить'; }
}

function showUpdateDialog(version, apkUrl, notes) {
  otaOpen(version, apkUrl, notes || '');
}

function clearCacheAndReload() {
  try { localStorage.clear(); sessionStorage.clear(); } catch(e) {}
  if (window.Android && window.Android.clearWebViewCache) window.Android.clearWebViewCache();
  setTimeout(() => location.reload(true), 200);
}

// ╔══════════════════════════════════════════════════════════════════════════════╗
// ║                    🤖 ИНСТРУКЦИЯ ДЛЯ CLAUDE (ЧИТАЙ ВНИМАТЕЛЬНО!)           ║
// ║                                                                              ║
// ║  Привет! Если ты читаешь этот код — значит пользователь попросил тебя       ║
// ║  обновить приложение или разобраться в нём.                                  ║
// ║                                                                              ║
// ║  НАЧИНАЯ С v1.9.0 — в приложении есть МЕНЮ ВЫБОРА пасхалок.                 ║
// ║  Все игры живут в одном оверлее. Добавляй новые через eggStartGame().        ║
// ║                                                                              ║
// ║  ИСТОРИЯ ПАСХАЛОК (не повторяй!):                                            ║
// ║  • v1.6.0 — Змейка (Snake). Управление: свайп + d-pad.                      ║
// ║  • v1.7.0 — Крестики-нолики против ИИ (minimax). Touch/click.               ║
// ║  • v1.8.0 — Пинг-понг. Управление платформой свайпом/тапом.                 ║
// ║  • v1.9.0 — Тетрис. Свайп + экранные кнопки. Уровни, очки.                 ║
// ║  • v2.2.0 — Динозавр: птеродактили (2 высоты), хаотичные группы кактусов,  ║
// ║             приседание (свайп вниз), стикер управления в начале игры.       ║
// ║                                                                              ║
// ║  КАК АКТИВИРУЕТСЯ: 5 быстрых тапов по строке "Версия" в настройках.         ║
// ║  После 2 тапов — тост "🤔 Продолжай..." как подсказка.                      ║
// ║                                                                              ║
// ║  ТРЕБОВАНИЯ к новым пасхалкам:                                               ║
// ║  1. Стиль: цвета --accent, --surface, --bg — смотри getAccent()             ║
// ║  2. Работает через touch — это мобильное приложение                          ║
// ║  3. Добавь карточку в #egg-picker и секцию .egg-game в HTML                 ║
// ║  4. Добавь case в eggStartGame() и функцию остановки в eggStopAll()         ║
// ║  5. Запиши версию в ИСТОРИЮ выше                                             ║
// ╚══════════════════════════════════════════════════════════════════════════════╝

// ══ СИСТЕМА ПАСХАЛОК v1.9.0 ══
// _eggTaps, _eggTimer, _eggLastTouch объявлены в начале файла

function eggTap() {
  // Защита от двойного срабатывания touchstart + onclick
  const now = Date.now();
  if (now - _eggLastTouch < 350) return;
  _eggLastTouch = now;

  _eggTaps++;
  clearTimeout(_eggTimer);
  if (_eggTaps >= 5) { _eggTaps = 0; eggOpen(); return; }
  if (_eggTaps === 2) toast('🤔 Продолжай...');
  if (_eggTaps === 4) toast('🔥 Ещё раз!');
  _eggTimer = setTimeout(() => { _eggTaps = 0; }, 1500);
}

function eggOpen() {
  SFX.play('eggOpen');
  document.getElementById('egg-overlay').classList.add('show');
  eggShowPicker();
}

function eggClose() {
  document.getElementById('egg-overlay').classList.remove('show');
  eggStopAll();
}

function eggShowPicker() {
  eggStopAll();
  ['egg-snake','egg-ttt','egg-pong','egg-tetris','egg-dino','egg-blockblast','egg-breakout','egg-bubbles','egg-flappy','egg-2048'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.style.display = 'none';
  });
  document.getElementById('egg-picker').style.display = '';
  document.getElementById('egg-back').classList.remove('show');
}

function eggStartGame(name) {
  SFX.play('gameSelect');
  document.getElementById('egg-picker').style.display = 'none';
  document.getElementById('egg-back').classList.add('show');
  eggStopAll();
  if (name === 'snake') { document.getElementById('egg-snake').style.display = ''; snakeInit(); }
  else if (name === 'ttt')  { document.getElementById('egg-ttt').style.display = ''; tttInit(); }
  else if (name === 'pong') { document.getElementById('egg-pong').style.display = ''; pongInit(); }
  else if (name === 'tetris') { document.getElementById('egg-tetris').style.display = ''; tetInit(); }
  else if (name === 'dino') { document.getElementById('egg-dino').style.display = ''; dinoInit(); }
  else if (name === 'blockblast') { document.getElementById('egg-blockblast').style.display = ''; bbInit(); }
  else if (name === 'breakout') { document.getElementById('egg-breakout').style.display = ''; brInit(); }
  else if (name === 'bubbles')  { document.getElementById('egg-bubbles').style.display = '';  bubInit(); }
  else if (name === 'flappy')   { document.getElementById('egg-flappy').style.display = '';   flappyInit(); }
  else if (name === '2048')     { document.getElementById('egg-2048').style.display = '';     g2048Init(); }
}

function eggStopAll() {
  snakeStop();
  pongStop();
  tetStop();
  dinoStop();
  brStop();
  bubStop();
  flappyStop();
  g2048Stop();
}
function g2048Stop(){document.removeEventListener('keydown',g2048Key);}

// ── Утилита: обновить активную кнопку сложности ──
function updateDiffBtns(game) {
  const gameIdMap = {
    snake: 'egg-snake', pong: 'egg-pong', tetris: 'egg-tetris',
    dino: 'egg-dino', blockblast: 'egg-blockblast', breakout: 'egg-breakout', bubbles: 'egg-bubbles'
  };
  const container = document.getElementById(gameIdMap[game]);
  if (!container) return;
  const diffMap = {
    snake: snakeDifficulty, pong: pongDifficulty,
    tetris: tetDifficulty, dino: dinoDifficulty, blockblast: bbDifficulty, breakout: brDifficulty, bubbles: bubDifficulty
  };
  const cur = diffMap[game];
  const order = ['easy', 'normal', 'hard'];
  container.querySelectorAll('.diff-btn').forEach((btn, i) => {
    btn.classList.toggle('active', order[i] === cur);
  });
}

function getAccent() {
  return getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#e87722';
}

// ══════════════════════════════════════════════════════════════════
// ── 🐍 ЗМЕЙКА (v1.6.0) ───────────────────────────────────────────
// ══════════════════════════════════════════════════════════════════
let snakeRaf = null, snakeRunning = false, snakePaused = false;
let snakeGrid, snakeCells, snakeDir_v, snakeNextDir, snakeFood, snakeLen;
let snakeHi = 0, snakeSW, snakeSH, snakeCellSize;
const SNAKE_COLS = 20, SNAKE_ROWS = 24;
let snakeDifficulty = 'normal';
const SNAKE_DIFF = { easy: {baseDelay:280, step:3}, normal: {baseDelay:200, step:4}, hard: {baseDelay:120, step:6} };

function snakeInit() {
  snakeHi = getHi('snake');
  const canvas = document.getElementById('snake-canvas');
  const maxW = Math.min(window.innerWidth - 64, 320);
  snakeCellSize = Math.floor(maxW / SNAKE_COLS);
  canvas.width  = snakeCellSize * SNAKE_COLS;
  canvas.height = snakeCellSize * SNAKE_ROWS;
  snakeSW = canvas.width; snakeSH = canvas.height;

  // Свайп управление
  let tx0, ty0;
  canvas.ontouchstart = e => { e.preventDefault(); tx0 = e.touches[0].clientX; ty0 = e.touches[0].clientY; };
  canvas.ontouchend   = e => {
    e.preventDefault();
    const dx = e.changedTouches[0].clientX - tx0;
    const dy = e.changedTouches[0].clientY - ty0;
    if (Math.abs(dx) < 10 && Math.abs(dy) < 10) { snakeTogglePause(); return; }
    if (Math.abs(dx) > Math.abs(dy)) snakeDir(dx > 0 ? 1 : -1, 0);
    else snakeDir(0, dy > 0 ? 1 : -1);
  };
  snakeRestart();
}

function snakeRestart() {
  snakeStop();
  snakeGrid = Array.from({length: SNAKE_ROWS}, () => new Array(SNAKE_COLS).fill(0));
  const sx = Math.floor(SNAKE_COLS / 2), sy = Math.floor(SNAKE_ROWS / 2);
  snakeCells = [{x: sx, y: sy}, {x: sx-1, y: sy}, {x: sx-2, y: sy}];
  snakeCells.forEach(c => snakeGrid[c.y][c.x] = 1);
  snakeDir_v = {x: 1, y: 0}; snakeNextDir = {x: 1, y: 0};
  snakeLen = 3;
  snakePlaceFood();
  snakeRunning = true; snakePaused = false;
  snakeDraw();
  snakeSchedule();
}

function snakeStop() {
  snakeRunning = false;
  clearTimeout(snakeRaf); snakeRaf = null;
}

function snakeTogglePause() {
  if (!snakeRunning) { snakeRestart(); return; }
  snakePaused = !snakePaused;
  if (!snakePaused) snakeSchedule();
}

function snakeDir(dx, dy) { SFX.play('snakeTurn');
  // Нельзя развернуться назад
  if (dx === -snakeDir_v.x && dy === -snakeDir_v.y) return;
  snakeNextDir = {x: dx, y: dy};
}

function snakePlaceFood() {
  const empty = [];
  for (let y = 0; y < SNAKE_ROWS; y++)
    for (let x = 0; x < SNAKE_COLS; x++)
      if (!snakeGrid[y][x]) empty.push({x, y});
  if (!empty.length) return;
  snakeFood = empty[Math.floor(Math.random() * empty.length)];
}

function snakeSchedule() {
  if (!snakeRunning || snakePaused) return;
  const d = SNAKE_DIFF[snakeDifficulty] || SNAKE_DIFF.normal;
  const delay = Math.max(60, d.baseDelay - (snakeLen - 3) * d.step);
  snakeRaf = setTimeout(() => { snakeTick(); snakeDraw(); snakeSchedule(); }, delay);
}

function snakeTick() {
  snakeDir_v = {...snakeNextDir};
  const head = snakeCells[0];
  let nx = (head.x + snakeDir_v.x + SNAKE_COLS) % SNAKE_COLS;
  let ny = (head.y + snakeDir_v.y + SNAKE_ROWS) % SNAKE_ROWS;

  // Столкновение с собой
  if (snakeGrid[ny][nx] === 1) {
    snakeRunning = false;
    snakeDrawGameOver();
    SFX.play('snakeDie');
    if (snakeLen - 3 > snakeHi) snakeHi = saveHi('snake', snakeLen - 3);
    snakeUpdateScore();
    toast('🐍 Игра окончена! Счёт: ' + (snakeLen - 3));
    return;
  }

  const ate = snakeFood && nx === snakeFood.x && ny === snakeFood.y;
  snakeCells.unshift({x: nx, y: ny});
  snakeGrid[ny][nx] = 1;

  if (!ate) {
    const tail = snakeCells.pop();
    snakeGrid[tail.y][tail.x] = 0;
  } else {
    snakeLen++;
    SFX.play('snakeEat');
    snakePlaceFood();
    snakeUpdateScore();
  }
}

function snakeUpdateScore() {
  const el = document.getElementById('snake-score-label');
  if (el) el.textContent = 'Счёт: ' + (snakeLen - 3) + ' • Рекорд: ' + snakeHi;
}

function snakeDraw() {
  const canvas = document.getElementById('snake-canvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const accent = getAccent();
  const cs = snakeCellSize;

  ctx.fillStyle = '#111';
  ctx.fillRect(0, 0, snakeSW, snakeSH);

  // Сетка
  ctx.strokeStyle = 'rgba(255,255,255,0.03)';
  ctx.lineWidth = 0.5;
  for (let x = 0; x <= SNAKE_COLS; x++) { ctx.beginPath(); ctx.moveTo(x*cs,0); ctx.lineTo(x*cs,snakeSH); ctx.stroke(); }
  for (let y = 0; y <= SNAKE_ROWS; y++) { ctx.beginPath(); ctx.moveTo(0,y*cs); ctx.lineTo(snakeSW,y*cs); ctx.stroke(); }

  // Еда
  if (snakeFood) {
    ctx.shadowColor = '#ff4e00'; ctx.shadowBlur = 12;
    ctx.fillStyle = '#ff4e00';
    ctx.beginPath();
    ctx.arc(snakeFood.x*cs + cs/2, snakeFood.y*cs + cs/2, cs/2 - 2, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // Змея
  snakeCells.forEach((c, i) => {
    const alpha = i === 0 ? 1 : Math.max(0.35, 1 - i / snakeCells.length * 0.65);
    ctx.shadowColor = accent; ctx.shadowBlur = i === 0 ? 10 : 0;
    // Для тела парсим accent и применяем с прозрачностью
    let bodyColor;
    if (i === 0) {
      bodyColor = accent;
    } else {
      // Пробуем распарсить HEX в RGB для прозрачности
      const hex = accent.replace('#','');
      if (hex.length === 6) {
        const r = parseInt(hex.slice(0,2),16);
        const g2 = parseInt(hex.slice(2,4),16);
        const b2 = parseInt(hex.slice(4,6),16);
        bodyColor = `rgba(${r},${g2},${b2},${alpha})`;
      } else {
        bodyColor = accent;
      }
    }
    ctx.fillStyle = bodyColor;
    const pad = i === 0 ? 1 : 2;
    if (ctx.roundRect) ctx.roundRect(c.x*cs+pad, c.y*cs+pad, cs-pad*2, cs-pad*2, 3);
    else ctx.rect(c.x*cs+pad, c.y*cs+pad, cs-pad*2, cs-pad*2);
    ctx.fill();
    ctx.shadowBlur = 0;
  });

  if (snakePaused) {
    ctx.fillStyle = 'rgba(0,0,0,.55)';
    ctx.fillRect(0, snakeSH/2-26, snakeSW, 52);
    ctx.fillStyle = '#f0ede8';
    ctx.font = 'bold 16px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('⏸ Пауза — тапни чтобы продолжить', snakeSW/2, snakeSH/2+6);
  }
}

function snakeDrawGameOver() {
  const canvas = document.getElementById('snake-canvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  snakeDraw();
  ctx.fillStyle = 'rgba(0,0,0,.6)';
  ctx.fillRect(0, snakeSH/2-32, snakeSW, 64);
  ctx.fillStyle = '#f0ede8';
  ctx.font = 'bold 16px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('💀 Игра окончена!', snakeSW/2, snakeSH/2-6);
  ctx.font = '13px sans-serif'; ctx.fillStyle = getAccent();
  ctx.fillText('Нажми «Заново» чтобы сыграть снова', snakeSW/2, snakeSH/2+16);
}

// ══════════════════════════════════════════════════════════════════
// ── ❌ КРЕСТИКИ-НОЛИКИ (v1.7.0) — minimax IG ─────────────────────
// ══════════════════════════════════════════════════════════════════
let tttBoard, tttXWins = 0, tttOWins = 0, tttDraws = 0, tttGameOver;

function tttInit() { tttRestart(); }

function tttRestart() {
  tttBoard = Array(9).fill(null);
  tttGameOver = false;
  tttRenderBoard();
  document.getElementById('ttt-status').textContent = 'Твой ход — ставь ✕';
}

function tttRenderBoard() {
  const el = document.getElementById('ttt-board');
  if (!el) return;
  el.innerHTML = '';
  tttBoard.forEach((v, i) => {
    const cell = document.createElement('div');
    cell.className = 'ttt-cell' + (v === 'X' ? ' x-cell' : v === 'O' ? ' o-cell' : '');
    cell.textContent = v === 'X' ? '✕' : v === 'O' ? '◯' : '';
    if (!v && !tttGameOver) cell.onclick = () => tttMove(i);
    el.appendChild(cell);
  });
}

function tttMove(i) {
  if (tttBoard[i] || tttGameOver) return;
  SFX.play('tttPlace');
  tttBoard[i] = 'X';
  tttRenderBoard();
  const win = tttCheck(tttBoard);
  if (win === 'X') { SFX.play('tttWin'); tttEndGame('✨ Ты победил! Неплохо!', win); return; }
  if (tttFull(tttBoard)) { SFX.play('tttDraw'); tttEndGame('🤝 Ничья!', null); return; }
  document.getElementById('ttt-status').textContent = '🤔 ИИ думает...';
  setTimeout(() => {
    const best = tttMinimax(tttBoard, 'O', -Infinity, Infinity);
    tttBoard[best.idx] = 'O';
    SFX.play('tttPlace');
    tttRenderBoard();
    const win2 = tttCheck(tttBoard);
    if (win2 === 'O') { SFX.play('tttLose'); tttEndGame('🤖 ИИ победил! Ещё раз?', win2); return; }
    if (tttFull(tttBoard)) { SFX.play('tttDraw'); tttEndGame('🤝 Ничья!', null); return; }
    document.getElementById('ttt-status').textContent = 'Твой ход — ставь ✕';
  }, 250);
}

function tttCheck(b) {
  const lines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
  for (const [a,c,d] of lines) if (b[a] && b[a]===b[c] && b[a]===b[d]) return b[a];
  return null;
}

function tttFull(b) { return b.every(v => v); }

function tttMinimax(b, player, alpha, beta) {
  const win = tttCheck(b);
  if (win === 'O') return {score: 10};
  if (win === 'X') return {score: -10};
  if (tttFull(b))  return {score: 0};
  let best = player === 'O' ? {score: -Infinity, idx: -1} : {score: Infinity, idx: -1};
  for (let i = 0; i < 9; i++) {
    if (b[i]) continue;
    b[i] = player;
    const res = tttMinimax(b, player === 'O' ? 'X' : 'O', alpha, beta);
    b[i] = null;
    res.idx = i;
    if (player === 'O') { if (res.score > best.score) best = res; alpha = Math.max(alpha, best.score); }
    else                { if (res.score < best.score) best = res; beta  = Math.min(beta,  best.score); }
    if (beta <= alpha) break;
  }
  return best;
}

function tttEndGame(msg, winner) {
  tttGameOver = true;
  document.getElementById('ttt-status').textContent = msg;
  if (winner === 'X') tttXWins++;
  else if (winner === 'O') tttOWins++;
  else tttDraws++;
  document.getElementById('ttt-score-x').textContent = tttXWins;
  document.getElementById('ttt-score-o').textContent = tttOWins;
  document.getElementById('ttt-score-d').textContent = tttDraws;
  // Подсветить выигрышную линию
  if (winner) {
    const lines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
    const cells = document.getElementById('ttt-board').children;
    for (const [a,c,d] of lines) {
      if (tttBoard[a] === winner && tttBoard[c] === winner && tttBoard[d] === winner) {
        [a,c,d].forEach(idx => cells[idx].classList.add('win'));
        break;
      }
    }
  }
}

// ══════════════════════════════════════════════════════════════════
// ── 🏓 ПИНГ-ПОНГ (v1.8.0) ────────────────────────────────────────
// ══════════════════════════════════════════════════════════════════
let pongRaf = null, pongRunning = false;
let pongScore = 0, pongHi = 0;
let pongBall, pongPad, pongW, pongH, pongSpeed, pongMissed;
let pongDifficulty = 'normal'; // easy / normal / hard
let pongLastTime = 0;

const PONG_DIFF = {
  easy:   { initSpeed: 2.0, maxSpeed: 7,  padW: 0.38 },
  normal: { initSpeed: 3.0, maxSpeed: 10, padW: 0.30 },
  hard:   { initSpeed: 4.5, maxSpeed: 14, padW: 0.22 },
};

function pongInit() {
  const canvas = document.getElementById('pong-canvas');
  const side = Math.min(window.innerWidth - 36, 360);
  canvas.width = side;
  canvas.height = Math.round(side * 1.1);
  pongW = canvas.width; pongH = canvas.height;
  pongHi = getHi('pong');
  pongRestart();
  const movePad = (clientX) => {
    const rect = canvas.getBoundingClientRect();
    pongPad.x = Math.max(pongPad.w/2, Math.min(pongW - pongPad.w/2, clientX - rect.left));
  };
  canvas.ontouchstart = e => { e.preventDefault(); movePad(e.touches[0].clientX); if (!pongRunning && !pongMissed) pongStart(); };
  canvas.ontouchmove  = e => { e.preventDefault(); movePad(e.touches[0].clientX); };
  canvas.onmousemove  = e => movePad(e.clientX);
  canvas.onclick = () => { if (!pongRunning && !pongMissed) pongStart(); };
}

function pongRestart() {
  pongStop();
  pongLastTime = 0;
  const diff = PONG_DIFF[pongDifficulty] || PONG_DIFF.normal;
  const padW = Math.round(pongW * diff.padW);
  pongPad = {x: pongW/2, w: padW, h: 10, y: pongH - 22};
  pongSpeed = diff.initSpeed; pongScore = 0; pongMissed = false; pongRunning = false;
  const angle = (Math.random() * 60 + 60) * (Math.PI/180) * (Math.random() > .5 ? 1 : -1);
  pongBall = {x: pongW/2, y: pongH/2, r: 8, vx: Math.cos(angle)*pongSpeed, vy: -Math.abs(Math.sin(angle)*pongSpeed), sx:1, sy:1, sqT:0, trail:[]};
  pongUpdateScore();
  pongDraw();
  _drawPongMsg('Тапни для старта 🏓');
}

function pongStart() { if (pongRunning) return; pongRunning = true; pongLoop(); }

function pongStop() { cancelAnimationFrame(pongRaf); pongRaf = null; pongRunning = false; }

function pongLoop(ts) {
  if (!pongRunning) return;
  const dt = pongLastTime ? Math.min((ts - pongLastTime) / 16.667, 3) : 1;
  pongLastTime = ts;
  pongTick(dt); pongDraw();
  pongRaf = requestAnimationFrame(pongLoop);
}

function pongTick(dt) {
  const b = pongBall, p = pongPad;
  b.x += b.vx * dt; b.y += b.vy * dt;

  // Trail — храним с временной меткой, чтобы длина не зависела от FPS
  const now1 = performance.now();
  b.trail.push({x: b.x, y: b.y, ts: now1});
  // Удаляем точки старше 160мс
  while (b.trail.length > 0 && now1 - b.trail[0].ts > 160) b.trail.shift();

  // Squish recovery
  if (b.sqT > 0) {
    b.sqT = Math.max(0, b.sqT - dt * 0.17);
    const k = b.sqT;
    b.sx = 1 + (b._sqTx || 0) * k;
    b.sy = 1 + (b._sqTy || 0) * k;
  } else { b.sx = 1; b.sy = 1; }

  if (b.x - b.r < 0) {
    b.x = b.r; b.vx = Math.abs(b.vx);
    b.sx = 0.84; b.sy = 1.14; b._sqTx = -0.16; b._sqTy = 0.14; b.sqT = 1;
    SFX.play('pongWall');
  }
  if (b.x + b.r > pongW) {
    b.x = pongW - b.r; b.vx = -Math.abs(b.vx);
    b.sx = 0.84; b.sy = 1.14; b._sqTx = -0.16; b._sqTy = 0.14; b.sqT = 1;
    SFX.play('pongWall');
  }
  if (b.y - b.r < 0) {
    b.y = b.r; b.vy = Math.abs(b.vy);
    b.sx = 1.14; b.sy = 0.84; b._sqTx = 0.14; b._sqTy = -0.16; b.sqT = 1;
  }
  const padLeft = p.x - p.w/2, padRight = p.x + p.w/2;
  if (b.vy > 0 && b.y+b.r >= p.y && b.y+b.r <= p.y+p.h+4 && b.x >= padLeft-b.r && b.x <= padRight+b.r) {
    b.y = p.y - b.r;
    const hit = (b.x - p.x) / (p.w/2);
    const ba = hit * 65 * (Math.PI/180);
    pongSpeed = Math.min(pongSpeed + 0.18, PONG_DIFF[pongDifficulty].maxSpeed);
    b.vx = Math.sin(ba) * pongSpeed; b.vy = -Math.cos(ba) * pongSpeed;
    b.sx = 1.16; b.sy = 0.86; b._sqTx = 0.16; b._sqTy = -0.14; b.sqT = 1;
    SFX.play('pongHit'); SFX.play('pongScore');
    pongScore++; if (pongScore > pongHi) pongHi = saveHi('pong', pongScore);
    pongUpdateScore();
  }
  if (b.y - b.r > pongH) {
    pongRunning = false; pongMissed = true;
    cancelAnimationFrame(pongRaf);
    SFX.play('pongLose');
    pongDraw(); _drawPongMsg('💀 Промах! Тапни — заново');
    toast('💀 Счёт: ' + pongScore);
  }
}

function pongDraw() {
  const canvas = document.getElementById('pong-canvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const b = pongBall, p = pongPad;
  const accent = getAccent();
  ctx.fillStyle = '#111'; ctx.fillRect(0, 0, pongW, pongH);
  ctx.setLineDash([6,6]); ctx.strokeStyle = 'rgba(255,255,255,.08)'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(0, pongH/2); ctx.lineTo(pongW, pongH/2); ctx.stroke();
  ctx.setLineDash([]);

  // Trail — по возрасту точки, не по индексу
  const trail = b.trail || [];
  const trailDur = 160;
  const nowT = performance.now();
  for (let i = 0; i < trail.length; i++) {
    const age = nowT - trail[i].ts;
    const t = Math.max(0, 1 - age / trailDur); // 1=свежая, 0=старая
    const alpha = t * t * 0.45;
    const r = b.r * (0.25 + t * 0.55);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = accent;
    ctx.beginPath(); ctx.arc(trail[i].x, trail[i].y, r, 0, Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Ball with squish
  const sx = b.sx || 1, sy = b.sy || 1;
  ctx.save();
  ctx.translate(b.x, b.y);
  ctx.scale(sx, sy);
  ctx.shadowColor = accent; ctx.shadowBlur = 16; ctx.fillStyle = accent;
  ctx.beginPath(); ctx.arc(0, 0, b.r, 0, Math.PI*2); ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();

  // Paddle
  const grad = ctx.createLinearGradient(p.x-p.w/2, 0, p.x+p.w/2, 0);
  grad.addColorStop(0, 'rgba(255,255,255,.15)'); grad.addColorStop(.5, accent); grad.addColorStop(1, 'rgba(255,255,255,.15)');
  ctx.fillStyle = grad; ctx.shadowColor = accent; ctx.shadowBlur = 10;
  if (ctx.roundRect) ctx.roundRect(p.x-p.w/2, p.y, p.w, p.h, 6); else ctx.rect(p.x-p.w/2, p.y, p.w, p.h);
  ctx.fill(); ctx.shadowBlur = 0;
}

function _drawPongMsg(msg) {
  const canvas = document.getElementById('pong-canvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = 'rgba(0,0,0,.5)'; ctx.fillRect(0, pongH/2-30, pongW, 56);
  ctx.fillStyle = '#f0ede8'; ctx.font = 'bold 15px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText(msg, pongW/2, pongH/2+8);
  canvas.onclick = () => { pongMissed = false; pongRestart(); pongStart(); };
}

function pongUpdateScore() {
  const el = document.getElementById('pong-score-label');
  if (el) el.textContent = 'Счёт: ' + pongScore + ' • Рекорд: ' + pongHi;
}

// ══════════════════════════════════════════════════════════════════
// ── 🧱 ТЕТРИС (v1.9.0) ───────────────────────────────────────────
// ══════════════════════════════════════════════════════════════════
const TET_COLS = 10, TET_ROWS = 20;
const TET_PIECES = [
  { shape: [[1,1,1,1]],             color: '#00e5ff' }, // I
  { shape: [[1,1],[1,1]],           color: '#f5c518' }, // O
  { shape: [[0,1,0],[1,1,1]],       color: '#a78bfa' }, // T
  { shape: [[1,0],[1,0],[1,1]],     color: '#e87722' }, // L
  { shape: [[0,1],[0,1],[1,1]],     color: '#60cdff' }, // J
  { shape: [[0,1,1],[1,1,0]],       color: '#4caf7d' }, // S
  { shape: [[1,1,0],[0,1,1]],       color: '#c94f4f' }, // Z
];

let tetGrid, tetPiece, tetNext, tetX, tetY;
let tetScore = 0, tetHi = 0, tetLevel = 1, tetLines = 0;
let tetInterval = null, tetRunning = false, tetDead = false;
let tetCellSize, tetCanvasW, tetCanvasH;
let tetSwipeX0, tetSwipeY0, tetSwipeLastX;
let tetDifficulty = 'normal';
const TET_DIFF = { easy: {speedBase:600, minSpeed:150}, normal: {speedBase:500, minSpeed:80}, hard: {speedBase:300, minSpeed:50} };

function tetInit() {
  tetHi = getHi('tetris');
  const canvas = document.getElementById('tet-canvas');
  const maxW = Math.min(window.innerWidth - 64, 220);
  tetCellSize = Math.floor(maxW / TET_COLS);
  canvas.width  = tetCellSize * TET_COLS;
  canvas.height = tetCellSize * TET_ROWS;
  tetCanvasW = canvas.width; tetCanvasH = canvas.height;

  // Свайп: влево/вправо — двигать, вниз — ускорить, вверх — повернуть
  canvas.ontouchstart = e => {
    e.preventDefault();
    tetSwipeX0 = tetSwipeLastX = e.touches[0].clientX;
    tetSwipeY0 = e.touches[0].clientY;
  };
  canvas.ontouchmove = e => {
    e.preventDefault();
    const dx = e.touches[0].clientX - tetSwipeLastX;
    if (Math.abs(dx) >= tetCellSize) {
      tetMove(dx > 0 ? 1 : -1);
      tetSwipeLastX = e.touches[0].clientX;
    }
  };
  canvas.ontouchend = e => {
    e.preventDefault();
    const dy = e.changedTouches[0].clientY - tetSwipeY0;
    const dx = e.changedTouches[0].clientX - tetSwipeX0;
    if (dy > 40 && Math.abs(dx) < 40) tetDrop();
    else if (dy < -40 && Math.abs(dx) < 40) tetRotate();
  };

  tetRestart();
}

function tetRestart() {
  tetStop();
  tetGrid = Array.from({length: TET_ROWS}, () => new Array(TET_COLS).fill(null));
  tetScore = 0; tetLevel = 1; tetLines = 0; tetDead = false;
  tetNext = tetRandomPiece();
  tetSpawn();
  tetRunning = true;
  tetSchedule();
  tetDraw();
}

function tetStop() {
  clearInterval(tetInterval); tetInterval = null;
  tetRunning = false;
}

function tetRandomPiece() {
  return JSON.parse(JSON.stringify(TET_PIECES[Math.floor(Math.random() * TET_PIECES.length)]));
}

function tetSpawn() {
  tetPiece = tetNext;
  tetNext  = tetRandomPiece();
  tetX = Math.floor((TET_COLS - tetPiece.shape[0].length) / 2);
  tetY = 0;
  if (tetCollide(tetPiece.shape, tetX, tetY)) {
    tetDead = true; tetStop();
    SFX.play('tetGameOver');
    if (tetScore > tetHi) tetHi = saveHi("tetris", tetScore);
    tetUpdateScore();
    tetDraw();
    tetDrawMsg('💀 Игра окончена!');
    toast('🧱 Тетрис: ' + tetScore + ' очков');
  }
}

function tetSchedule() {
  const d = TET_DIFF[tetDifficulty] || TET_DIFF.normal;
  const delay = Math.max(d.minSpeed, d.speedBase - (tetLevel - 1) * 45);
  tetInterval = setInterval(() => { tetGravity(); tetDraw(); }, delay);
}

function tetGravity() {
  if (!tetRunning || tetDead) return;
  if (!tetCollide(tetPiece.shape, tetX, tetY + 1)) { tetY++; }
  else { tetLock(); }
}

function tetCollide(shape, ox, oy) {
  for (let r = 0; r < shape.length; r++)
    for (let c = 0; c < shape[r].length; c++)
      if (shape[r][c]) {
        const nx = ox + c, ny = oy + r;
        if (nx < 0 || nx >= TET_COLS || ny >= TET_ROWS) return true;
        if (ny >= 0 && tetGrid[ny][nx]) return true;
      }
  return false;
}

function tetLock() {
  for (let r = 0; r < tetPiece.shape.length; r++)
    for (let c = 0; c < tetPiece.shape[r].length; c++)
      if (tetPiece.shape[r][c] && tetY+r >= 0)
        tetGrid[tetY+r][tetX+c] = tetPiece.color;
  tetClearLines();
  tetSpawn();
}

function tetClearLines() {
  let cleared = 0;
  for (let r = TET_ROWS - 1; r >= 0; r--) {
    if (tetGrid[r].every(v => v)) {
      tetGrid.splice(r, 1);
      tetGrid.unshift(new Array(TET_COLS).fill(null));
      cleared++; r++;
    }
  }
  if (cleared) {
    SFX.play('tetLine');
    const pts = [0, 100, 300, 500, 800][cleared] * tetLevel;
    tetScore += pts; tetLines += cleared;
    tetLevel = Math.floor(tetLines / 10) + 1;
    if (tetScore > tetHi) tetHi = saveHi("tetris", tetScore);
    tetUpdateScore();
    // Перезапланировать с новой скоростью
    tetStop();
    tetRunning = true;
    tetSchedule();
  }
}

function tetMove(dx) {
  if (tetDead || !tetRunning) return;
  if (!tetCollide(tetPiece.shape, tetX + dx, tetY)) { tetX += dx; SFX.play('tetMove'); tetDraw(); }
}

function tetRotate() {
  if (tetDead || !tetRunning) return;
  const rows = tetPiece.shape.length, cols = tetPiece.shape[0].length;
  const rotated = Array.from({length: cols}, (_, c) => Array.from({length: rows}, (_, r) => tetPiece.shape[rows-1-r][c]));
  // Kick: пробуем оригинальное место, ±1, ±2
  for (const kick of [0, -1, 1, -2, 2]) {
    if (!tetCollide(rotated, tetX + kick, tetY)) {
      tetPiece.shape = rotated; tetX += kick; SFX.play('tetRotate'); tetDraw(); return;
    }
  }
}

function tetDrop() {
  if (tetDead || !tetRunning) return;
  while (!tetCollide(tetPiece.shape, tetX, tetY + 1)) { tetY++; tetScore += 1; }
  tetUpdateScore();
  SFX.play('tetDrop');
  tetLock(); tetDraw();
}

function tetUpdateScore() {
  const el = document.getElementById('tet-score-label');
  if (el) el.textContent = 'Счёт: ' + tetScore + ' • Рекорд: ' + tetHi + ' • Уровень: ' + tetLevel;
}

function tetDraw() {
  const canvas = document.getElementById('tet-canvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const cs = tetCellSize;
  const accent = getAccent();

  // Фон
  ctx.fillStyle = '#111'; ctx.fillRect(0, 0, tetCanvasW, tetCanvasH);

  // Сетка
  ctx.strokeStyle = 'rgba(255,255,255,.04)'; ctx.lineWidth = .5;
  for (let x = 0; x <= TET_COLS; x++) { ctx.beginPath(); ctx.moveTo(x*cs,0); ctx.lineTo(x*cs,tetCanvasH); ctx.stroke(); }
  for (let y = 0; y <= TET_ROWS; y++) { ctx.beginPath(); ctx.moveTo(0,y*cs); ctx.lineTo(tetCanvasW,y*cs); ctx.stroke(); }

  // Уложенные блоки
  for (let r = 0; r < TET_ROWS; r++)
    for (let c = 0; c < TET_COLS; c++)
      if (tetGrid[r][c]) { _tetDrawCell(ctx, c, r, tetGrid[r][c], cs); }

  // Тень (ghost piece)
  if (!tetDead && tetRunning) {
    let ghostY = tetY;
    while (!tetCollide(tetPiece.shape, tetX, ghostY + 1)) ghostY++;
    if (ghostY !== tetY) {
      for (let r = 0; r < tetPiece.shape.length; r++)
        for (let c = 0; c < tetPiece.shape[r].length; c++)
          if (tetPiece.shape[r][c]) {
            ctx.fillStyle = 'rgba(255,255,255,.1)';
            ctx.fillRect((tetX+c)*cs+1, (ghostY+r)*cs+1, cs-2, cs-2);
          }
    }

    // Активная фигура
    for (let r = 0; r < tetPiece.shape.length; r++)
      for (let c = 0; c < tetPiece.shape[r].length; c++)
        if (tetPiece.shape[r][c]) { _tetDrawCell(ctx, tetX+c, tetY+r, tetPiece.color, cs); }
  }
}

function _tetDrawCell(ctx, cx, cy, color, cs) {
  ctx.shadowColor = color; ctx.shadowBlur = 2;
  ctx.fillStyle = color;
  if (ctx.roundRect) ctx.roundRect(cx*cs+1, cy*cs+1, cs-2, cs-2, 3);
  else ctx.rect(cx*cs+1, cy*cs+1, cs-2, cs-2);
  ctx.fill();
  // Блик
  ctx.fillStyle = 'rgba(255,255,255,.18)';
  ctx.fillRect(cx*cs+2, cy*cs+2, cs-4, Math.floor((cs-4)*0.4));
  ctx.shadowBlur = 0;
}

function tetDrawMsg(msg) {
  const canvas = document.getElementById('tet-canvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = 'rgba(0,0,0,.65)'; ctx.fillRect(0, tetCanvasH/2-34, tetCanvasW, 68);
  ctx.fillStyle = '#f0ede8'; ctx.font = 'bold 15px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText(msg, tetCanvasW/2, tetCanvasH/2-8);
  ctx.font = '12px sans-serif'; ctx.fillStyle = getAccent();
  ctx.fillText('Нажми «Заново» чтобы ещё раз', tetCanvasW/2, tetCanvasH/2+16);
}

// ══════════════════════════════════════════════════════════════════
// ── 🦕 ДИНОЗАВРИК (v2.0.0) ───────────────────────────────────────
// ══════════════════════════════════════════════════════════════════
// ══════════════════════════════════════════════════════════════════
// ── 🦕 DINO GAME (v2.2 — хаотичные кактусы + птеродактили) ──────
// ══════════════════════════════════════════════════════════════════
let dinoRaf = null, dinoRunning = false;
let dinoScore = 0, dinoHi = 0;
let dinoW, dinoH, dinoCellH;
let dinoDino, dinoGround, dinoObstacles, dinoBirds, dinoCloudX, dinoFrameCount;
let dinoDifficulty = 'normal';
let dinoLastTime = 0;
let dinoLegFrame = 0, dinoLegTimer = 0;
let dinoDucking = false;
let dinoBirdWing = 0, dinoBirdWingTimer = 0;
let dinoDustParticles = [];

const DINO_DIFF = {
  easy:   { initSpeed: 4,   accel: 0.008, jumpVel: -13.5, gravity: 0.72 },
  normal: { initSpeed: 5.5, accel: 0.012, jumpVel: -14.5, gravity: 0.80 },
  hard:   { initSpeed: 7.5, accel: 0.018, jumpVel: -14,   gravity: 0.90 },
};

// Конфигурации групп кактусов: массив высот (как доля от dinoH) для каждого кактуса в группе
const CACTUS_CONFIGS = [
  [0.26],               // одиночный маленький
  [0.34],               // одиночный средний
  [0.40],               // одиночный высокий
  [0.32, 0.36],         // двойной (маленький + высокий)
  [0.38, 0.24],         // двойной (высокий + маленький)
  [0.32, 0.32],         // двойной одинаковый
  [0.28, 0.38, 0.28],   // тройной (арка)
  [0.36, 0.36, 0.36],   // тройной монолит
  [0.24, 0.38, 0.38],   // тройной нарастающий
  [0.40, 0.28, 0.36],   // тройной хаос
];

function dinoInit() {
  dinoHi = getHi("dino");
  const canvas = document.getElementById('dino-canvas');
  const maxW = Math.min(window.innerWidth - 36, 400);
  canvas.width  = maxW;
  canvas.height = Math.round(maxW * 0.48);
  dinoW = canvas.width; dinoH = canvas.height;
  dinoCellH = Math.round(dinoH * 0.28);

  // Тач: свайп вниз = приседание, тап = прыжок
  let _ty = 0, _moved = false;
  canvas.ontouchstart = e => { e.preventDefault(); _ty = e.touches[0].clientY; _moved = false; };
  canvas.ontouchmove  = e => {
    e.preventDefault();
    if (!_moved && e.touches[0].clientY - _ty > 22) {
      _moved = true;
      if (dinoRunning && dinoDino.onGround) dinoDucking = true;
    }
  };
  canvas.ontouchend = e => {
    e.preventDefault();
    dinoDucking = false;
    if (!_moved) dinoJump();
  };
  canvas.onclick = () => dinoJump();
  dinoRestart();
}

function dinoRestart() {
  dinoStop();
  dinoLastTime = 0;
  dinoLegFrame = 0; dinoLegTimer = 0;
  dinoDucking = false;
  dinoBirdWing = 0; dinoBirdWingTimer = 0;
  const d = DINO_DIFF[dinoDifficulty] || DINO_DIFF.normal;
  dinoScore = 0;
  dinoGround = dinoH - Math.round(dinoH * 0.12);
  const baseH = Math.round(dinoH * 0.32);
  dinoDino = {
    x: Math.round(dinoW * 0.12),
    w: Math.round(dinoH * 0.26),
    h: baseH, baseH,
    duckH: Math.round(baseH * 0.55), // высота приседания
    y: 0, vy: 0, onGround: true,
    speed: d.initSpeed, accel: d.accel,
    jumpVel: d.jumpVel, gravity: d.gravity
  };
  dinoDino.y = dinoGround - dinoDino.h;
  dinoObstacles = [];
  dinoBirds = [];
  dinoCloudX = dinoW;
  dinoFrameCount = 0;
  dinoUpdateScore();
  dinoRunning = true;
  dinoLoop();
}

function dinoStop() {
  cancelAnimationFrame(dinoRaf); dinoRaf = null;
  dinoRunning = false;
}

function dinoJump() {
  if (!dinoRunning) { dinoRestart(); return; }
  if (dinoDucking) { dinoDucking = false; return; }
  if (dinoDino.onGround) {
    SFX.play('dinoJump');
    dinoDino.vy = dinoDino.jumpVel;
    dinoDino.onGround = false;
  }
}

function dinoLoop(ts) {
  if (!dinoRunning) return;
  const dt = dinoLastTime ? Math.min((ts - dinoLastTime) / 16.667, 3) : 1;
  dinoLastTime = ts;
  dinoTick(dt);
  dinoDraw();
  dinoRaf = requestAnimationFrame(dinoLoop);
}

function dinoTick(dt) {
  const d = dinoDino;
  // Ускорение
  d.speed = Math.min(d.speed + d.accel * dt, 22);
  dinoFrameCount += dt;

  // Приседание: изменяем высоту дино
  if (d.onGround) {
    const targetH = dinoDucking ? d.duckH : d.baseH;
    d.h = targetH;
    d.y = dinoGround - d.h;
  }

  // Анимация ног
  if (d.onGround) {
    dinoLegTimer += d.speed * dt;
    if (dinoLegTimer >= 38) { dinoLegTimer = 0; dinoLegFrame = 1 - dinoLegFrame; }
  }

  // Анимация крыльев птицы
  dinoBirdWingTimer += d.speed * dt * 0.6;
  if (dinoBirdWingTimer >= 9) { dinoBirdWingTimer = 0; dinoBirdWing = 1 - dinoBirdWing; }

  // Физика
  const wasOnGround = d.onGround;
  d.vy += d.gravity * dt;
  d.y  += d.vy * dt;
  if (d.y >= dinoGround - d.h) {
    d.y = dinoGround - d.h; d.vy = 0;
    if (!wasOnGround) {
      // Landing dust burst
      for (let i = 0; i < 8; i++) {
        const ang = Math.PI + (Math.random() - 0.5) * 1.2;
        const spd = 0.8 + Math.random() * 2;
        dinoDustParticles.push({
          x: d.x + d.w * 0.3, y: dinoGround,
          vx: Math.cos(ang) * spd, vy: Math.sin(ang) * spd - 0.5,
          life: 1, maxLife: 1, r: 3 + Math.random() * 3
        });
      }
    }
    d.onGround = true;
  }

  // Update dust
  for (let i = dinoDustParticles.length - 1; i >= 0; i--) {
    const p = dinoDustParticles[i];
    p.x += p.vx * dt * 0.4; p.y += p.vy * dt * 0.4;
    p.vy += 0.04 * dt;
    p.life -= dt * 0.004;
    if (p.life <= 0) dinoDustParticles.splice(i, 1);
  }

  // Счёт
  dinoScore = Math.floor(dinoFrameCount * 0.1);
  if (dinoScore > dinoHi) dinoHi = saveHi("dino", dinoScore);
  dinoUpdateScore();

  // ── Спавн кактусов (хаотичные группы) ──
  const lastCactX = dinoObstacles.length ? dinoObstacles[dinoObstacles.length - 1].x : -Infinity;
  // Переменный промежуток: от 140 до 380px, зависит от скорости и случайности
  const minGap = Math.max(140, 280 - d.speed * 10) + Math.random() * 120;
  if (lastCactX < dinoW - minGap || dinoObstacles.length === 0) {
    if (Math.random() < 0.018 * dt || dinoObstacles.length === 0) {
      // Выбираем случайную конфигурацию группы кактусов
      const config = CACTUS_CONFIGS[Math.floor(Math.random() * CACTUS_CONFIGS.length)];
      let offsetX = dinoW + 10;
      for (let i = 0; i < config.length; i++) {
        const cactH = Math.round(dinoH * config[i]);
        const cactW = Math.round(cactH * (0.40 + Math.random() * 0.15));
        dinoObstacles.push({ x: offsetX, w: cactW, h: cactH, y: dinoGround - cactH });
        // Между кактусами в группе маленький случайный зазор
        offsetX += cactW + Math.round(6 + Math.random() * 10);
      }
    }
  }

  // ── Спавн птиц (начиная с очков 15) ──
  if (dinoScore >= 15) {
    const lastBirdX = dinoBirds.length ? dinoBirds[dinoBirds.length - 1].x : -Infinity;
    const birdGap = Math.max(300, 550 - d.speed * 15) + Math.random() * 200;
    if (lastBirdX < dinoW - birdGap) {
      if (Math.random() < 0.010 * dt) {
        const bW = Math.round(dinoH * 0.25);
        const bH = Math.round(bW * 0.45);
        // Два уровня высоты: LOW (надо прыгать) и HIGH (надо приседать)
        // LOW: на уровне земли — птица летит на высоте тела дино
        // HIGH: выше — дино пролетает под ней приседая
        const isHigh = Math.random() < 0.45;
        const birdY = isHigh
          ? dinoGround - d.baseH * 1.05 - bH  // высоко — надо присесть
          : dinoGround - d.baseH * 0.65 - bH; // низко — надо прыгнуть
        dinoBirds.push({ x: dinoW + 10, w: bW, h: bH, y: birdY, high: isHigh });
      }
    }
  }

  // Движение препятствий
  for (const obs of dinoObstacles) obs.x -= d.speed * dt;
  while (dinoObstacles.length && dinoObstacles[0].x + dinoObstacles[0].w < 0) dinoObstacles.shift();

  for (const bird of dinoBirds) bird.x -= d.speed * dt;
  while (dinoBirds.length && dinoBirds[0].x + dinoBirds[0].w < 0) dinoBirds.shift();

  // Облако
  dinoCloudX -= d.speed * 0.25 * dt;
  if (dinoCloudX < -100) dinoCloudX = dinoW + 30;

  // Коллизии
  const pad = Math.round(d.w * 0.13);
  const checkHit = (obs) =>
    d.x + d.w - pad > obs.x + pad && d.x + pad < obs.x + obs.w - pad &&
    d.y + d.h - pad > obs.y + pad && d.y + pad < obs.y + obs.h - pad;

  for (const obs of dinoObstacles) {
    if (checkHit(obs)) { dinoDie(); return; }
  }
  for (const bird of dinoBirds) {
    if (checkHit(bird)) { dinoDie(); return; }
  }
}

function dinoDie() {
  dinoStop();
  dinoRunning = false;
  SFX.play('dinoCactus');
  dinoDraw();
  _dinoPaintMsg('💀 Игра окончена! Тапни чтобы снова');
  toast('🦕 Счёт: ' + dinoScore);
}

function dinoDraw() {
  const canvas = document.getElementById('dino-canvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const accent = getAccent();

  // Фон
  ctx.fillStyle = '#111'; ctx.fillRect(0, 0, dinoW, dinoH);

  // Земля
  ctx.fillStyle = 'rgba(255,255,255,0.25)';
  ctx.fillRect(0, dinoGround, dinoW, 1);

  // Пыль при приземлении
  for (const p of dinoDustParticles) {
    ctx.globalAlpha = Math.max(0, p.life * 0.55);
    ctx.fillStyle = accent;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r * p.life, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Камушки на земле
  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  const pebbleSeed = Math.floor(dinoFrameCount * 0.5) % 40;
  for (let i = 0; i < 8; i++) {
    const px = ((i * 53 + 7 - pebbleSeed) % (dinoW + 20)) - 10;
    const pw = 3 + (i * 7 % 5), ph = 2 + (i * 3 % 3);
    ctx.fillRect(px, dinoGround + 3 + (i % 3), pw, ph);
  }

  // Облака
  const drawCloud = (cx, cy, scale) => {
    ctx.fillStyle = 'rgba(255,255,255,0.07)';
    const s = scale || 1;
    ctx.fillRect(cx, cy + 5*s, 46*s, 7*s);
    ctx.fillRect(cx + 8*s, cy + 2*s, 22*s, 5*s);
    ctx.fillRect(cx + 14*s, cy, 14*s, 3*s);
  };
  drawCloud(dinoCloudX, dinoH * 0.1, 1);
  drawCloud((dinoCloudX + dinoW * 0.6) % (dinoW + 60) - 30, dinoH * 0.06, 0.7);
  drawCloud((dinoCloudX + dinoW * 0.3) % (dinoW + 50) - 20, dinoH * 0.2, 0.85);

  // HI + счёт
  const fs = Math.round(dinoH * 0.13);
  ctx.font = `700 ${fs}px "JetBrains Mono",monospace`;
  ctx.textAlign = 'right';
  if (dinoHi > 0) {
    ctx.fillStyle = 'rgba(255,255,255,0.28)';
    ctx.fillText('HI ' + String(dinoHi).padStart(5,'0'), dinoW - 8, fs + 4);
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    const hiW = ctx.measureText('HI 00000').width + 6;
    ctx.fillText(String(dinoScore).padStart(5,'0'), dinoW - 8 - hiW, fs + 4);
  } else {
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.fillText(String(dinoScore).padStart(5,'0'), dinoW - 8, fs + 4);
  }
  ctx.textAlign = 'left';

  // Подсказка по управлению (первые 10 очков)
  if (dinoScore < 10) {
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.font = `${Math.round(dinoH * 0.09)}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText('▲ прыжок  ▼ присесть', dinoW / 2, dinoH * 0.88);
    ctx.textAlign = 'left';
  }

  // ── Кактусы ──
  for (const obs of dinoObstacles) {
    ctx.fillStyle = accent;
    ctx.shadowColor = accent; ctx.shadowBlur = 5;
    const tW = Math.max(3, Math.round(obs.w * 0.32));
    const tX = obs.x + Math.round((obs.w - tW) / 2);
    ctx.fillRect(tX, obs.y, tW, obs.h);
    const aH = Math.round(obs.h * 0.32), aW = Math.round(obs.w * 0.35);
    ctx.fillRect(obs.x, obs.y + Math.round(obs.h * 0.25), aW, aH);
    ctx.fillRect(obs.x, obs.y + Math.round(obs.h * 0.25) - Math.round(aH * 0.55), aW, Math.round(aH * 0.55));
    const rX = obs.x + obs.w - aW;
    ctx.fillRect(rX, obs.y + Math.round(obs.h * 0.35), aW, aH);
    ctx.fillRect(rX + Math.round(aW * 0.55), obs.y + Math.round(obs.h * 0.35) - Math.round(aH * 0.45), Math.round(aW * 0.45), Math.round(aH * 0.45));
    ctx.shadowBlur = 0;
  }

  // ── Птеродактили ──
  for (const bird of dinoBirds) {
    ctx.fillStyle = accent;
    ctx.shadowColor = accent; ctx.shadowBlur = 6;
    const bx = Math.round(bird.x), by = Math.round(bird.y);
    const bw = bird.w, bh = bird.h;
    // Тело птицы (центральный прямоугольник)
    const bodyW = Math.round(bw * 0.45), bodyH = Math.round(bh * 0.42);
    const bodyX = bx + Math.round((bw - bodyW) / 2);
    const bodyY = by + Math.round(bh * 0.35);
    ctx.fillRect(bodyX, bodyY, bodyW, bodyH);
    // Голова (справа от тела)
    const headW = Math.round(bw * 0.22), headH = Math.round(bh * 0.32);
    ctx.fillRect(bodyX + bodyW - Math.round(headW * 0.3), bodyY - Math.round(headH * 0.5), headW, headH);
    // Клюв
    ctx.fillRect(bodyX + bodyW + Math.round(headW * 0.6), bodyY - Math.round(headH * 0.15), Math.round(bw * 0.15), Math.round(bh * 0.12));
    // Хвост (слева)
    ctx.fillRect(bx, bodyY + Math.round(bodyH * 0.2), Math.round(bw * 0.15), Math.round(bh * 0.14));
    // Крылья (2-кадровая анимация)
    const wingW = Math.round(bw * 0.42), wingH = Math.round(bh * 0.38);
    if (dinoBirdWing === 0) {
      // Крылья вверх
      ctx.fillRect(bodyX - Math.round(wingW * 0.5), by, wingW, Math.round(wingH * 0.6));
      ctx.fillRect(bodyX + Math.round(bodyW * 0.3), by, Math.round(wingW * 0.8), Math.round(wingH * 0.5));
    } else {
      // Крылья вниз
      ctx.fillRect(bodyX - Math.round(wingW * 0.5), bodyY - Math.round(wingH * 0.2), wingW, Math.round(wingH * 0.55));
      ctx.fillRect(bodyX + Math.round(bodyW * 0.3), bodyY - Math.round(wingH * 0.15), Math.round(wingW * 0.8), Math.round(wingH * 0.5));
    }
    ctx.shadowBlur = 0;
  }

  // ── Дино (пиксельный, Google-стиль) ──
  const d = dinoDino;
  const isDuck = dinoDucking && d.onGround;
  // Scale unit: в полный рост ~47, в приседе ~26
  const U = d.h / (isDuck ? 26 : 47);
  const bx = Math.round(d.x), by = Math.round(d.y);

  ctx.fillStyle = accent;
  ctx.shadowColor = accent; ctx.shadowBlur = 6;

  if (!isDuck) {
    // ── Обычный дино ──
    ctx.fillRect(bx,                      by + Math.round(23*U), Math.round(6*U),  Math.round(6*U));  // хвост
    ctx.fillRect(bx+Math.round(2*U),      by + Math.round(27*U), Math.round(5*U),  Math.round(4*U));
    ctx.fillRect(bx+Math.round(4*U),      by+Math.round(20*U),   Math.round(18*U), Math.round(20*U)); // торс
    ctx.fillRect(bx+Math.round(18*U),     by+Math.round(24*U),   Math.round(8*U),  Math.round(12*U)); // грудь
    ctx.fillRect(bx+Math.round(15*U),     by+Math.round(12*U),   Math.round(10*U), Math.round(11*U)); // шея
    ctx.fillRect(bx+Math.round(10*U),     by,                    Math.round(22*U), Math.round(14*U)); // голова
    ctx.fillRect(bx+Math.round(8*U),      by+Math.round(4*U),    Math.round(24*U), Math.round(9*U));
    ctx.fillStyle = '#111'; ctx.shadowBlur = 0;
    ctx.fillRect(bx+Math.round(22*U),     by+Math.round(10*U),   Math.round(10*U), Math.round(4*U));  // пасть
    ctx.fillStyle = '#f0ede8';
    ctx.fillRect(bx+Math.round(22*U),     by+Math.round(2*U),    Math.round(6*U),  Math.round(6*U));  // белок
    ctx.fillStyle = '#111';
    ctx.fillRect(bx+Math.round(25*U),     by+Math.round(3*U),    Math.round(3*U),  Math.round(3*U));  // зрачок
    ctx.fillStyle = accent; ctx.shadowColor = accent; ctx.shadowBlur = 4;
    ctx.fillRect(bx+Math.round(18*U),     by+Math.round(27*U),   Math.round(6*U),  Math.round(3*U));  // лапка
    // Ноги
    const legW = Math.round(5*U), legH = Math.round(11*U);
    const legY = by + Math.round(38*U);
    if (!d.onGround) {
      ctx.fillRect(bx+Math.round(8*U),  legY, legW, Math.round(8*U));
      ctx.fillRect(bx+Math.round(16*U), legY + Math.round(4*U), legW, Math.round(6*U));
    } else if (dinoLegFrame === 0) {
      ctx.fillRect(bx+Math.round(7*U),  legY,                    legW, legH);
      ctx.fillRect(bx+Math.round(7*U),  legY+legH-Math.round(U), Math.round(7*U), Math.round(2*U));
      ctx.fillRect(bx+Math.round(18*U), legY+Math.round(4*U),    legW, legH-Math.round(4*U));
      ctx.fillRect(bx+Math.round(16*U), legY+legH-Math.round(U), Math.round(7*U), Math.round(2*U));
    } else {
      ctx.fillRect(bx+Math.round(7*U),  legY+Math.round(4*U),    legW, legH-Math.round(4*U));
      ctx.fillRect(bx+Math.round(5*U),  legY+legH-Math.round(U), Math.round(7*U), Math.round(2*U));
      ctx.fillRect(bx+Math.round(18*U), legY,                    legW, legH);
      ctx.fillRect(bx+Math.round(18*U), legY+legH-Math.round(U), Math.round(7*U), Math.round(2*U));
    }
  } else {
    // ── Дино в приседе (плоский, вытянутый) ──
    const DW = d.w * 1.3; // присев — длиннее
    ctx.fillRect(bx,                   by + Math.round(8*U),  Math.round(8*U),  Math.round(8*U));  // хвост
    ctx.fillRect(bx+Math.round(6*U),   by + Math.round(6*U),  Math.round(DW*0.55), Math.round(14*U)); // тело
    ctx.fillRect(bx+Math.round(DW*0.45), by,                  Math.round(DW*0.35), Math.round(10*U)); // голова
    ctx.fillRect(bx+Math.round(DW*0.78), by+Math.round(2*U), Math.round(DW*0.18), Math.round(5*U));  // клюв
    ctx.fillStyle = '#f0ede8';
    ctx.fillRect(bx+Math.round(DW*0.5), by+Math.round(1*U), Math.round(5*U), Math.round(4*U));  // глаз
    ctx.fillStyle = '#111'; ctx.shadowBlur = 0;
    ctx.fillRect(bx+Math.round(DW*0.53), by+Math.round(2*U), Math.round(3*U), Math.round(2*U)); // зрачок
    ctx.fillStyle = accent; ctx.shadowColor = accent; ctx.shadowBlur = 4;
    // Ноги при приседе (горизонтальные)
    const legH2 = Math.round(5*U);
    ctx.fillRect(bx+Math.round(8*U),  by+Math.round(18*U), Math.round(7*U), legH2);
    ctx.fillRect(bx+Math.round(18*U), by+Math.round(20*U), Math.round(7*U), legH2);
  }
  ctx.shadowBlur = 0;
}

function _dinoPaintMsg(msg) {
  const canvas = document.getElementById('dino-canvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = 'rgba(0,0,0,.6)'; ctx.fillRect(0, dinoH/2-26, dinoW, 52);
  ctx.fillStyle = '#f0ede8'; ctx.font = 'bold 14px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText(msg, dinoW/2, dinoH/2+6);
}

function dinoUpdateScore() {
  const el = document.getElementById('dino-score-label');
  if (el) el.textContent = 'Счёт: ' + dinoScore + ' • Рекорд: ' + dinoHi;
}

// ══════════════════════════════════════════════════════════════════
// ── 🟦 BLOCK BLAST (v2.0.0) ──────────────────────────────────────
// ══════════════════════════════════════════════════════════════════
const BB_ROWS = 8, BB_COLS = 8;
let bbGrid, bbScore = 0, bbHi = 0, bbPieces, bbDragging = null;
let bbCellSize, bbDifficulty = 'normal';

const BB_SHAPES = [
  [[1,1],[1,1]],      // 2x2
  [[1,1,1]],          // 1x3
  [[1],[1],[1]],      // 3x1
  [[1,1,1],[0,1,0]], // T-shape
  [[1,0],[1,1]],     // L small
  [[0,1],[1,1]],     // J small
  [[1,1,0],[0,1,1]], // S
  [[0,1,1],[1,1,0]], // Z
  [[1,1,1,1]],       // I
  [[1]],             // dot
  [[1,1,1],[1,0,0]], // L
  [[1,1,1],[0,0,1]], // J
];

const BB_COLORS = ['#e87722','#00e5ff','#a78bfa','#4caf7d','#f5c518','#c94f4f','#60cdff','#f472b6'];

function bbInit() {
  bbHi = getHi("blockblast");
  const wrap = document.getElementById('bb-board-wrap');
  const maxW = Math.min(window.innerWidth - 64, 280);
  bbCellSize = Math.floor(maxW / BB_COLS);
  bbRestart();
}

function bbRestart() {
  bbGrid = Array.from({length: BB_ROWS}, () => Array(BB_COLS).fill(null));
  bbScore = 0;
  bbUpdateScore();
  bbGeneratePieces();
  bbRenderBoard();
}

function bbRandomPiece() {
  const shape = BB_SHAPES[Math.floor(Math.random() * BB_SHAPES.length)];
  const color = BB_COLORS[Math.floor(Math.random() * BB_COLORS.length)];
  return { shape, color, placed: false };
}

function bbGeneratePieces() {
  bbPieces = [bbRandomPiece(), bbRandomPiece(), bbRandomPiece()];
  bbRenderPieces();
}

function bbUpdateScore() {
  const el = document.getElementById('bb-score-label');
  if (el) el.textContent = 'Счёт: ' + bbScore + ' • Рекорд: ' + bbHi;
}

function bbRenderBoard() {
  const wrap = document.getElementById('bb-board-wrap');
  if (!wrap) return;
  const cs = bbCellSize;
  const bw = cs * BB_COLS, bh = cs * BB_ROWS;

  wrap.innerHTML = '';
  const canvas = document.createElement('canvas');
  canvas.id = 'bb-canvas';
  canvas.width = bw; canvas.height = bh;
  canvas.style.borderRadius = '12px';
  canvas.style.border = '1.5px solid var(--surface3)';
  wrap.appendChild(canvas);

  canvas.addEventListener('dragover', e => { e.preventDefault(); bbOnDragOver(e, canvas); });
  canvas.addEventListener('drop',     e => { e.preventDefault(); bbOnDrop(e, canvas); });
  // Touch events for mobile drag-and-drop
  canvas.addEventListener('touchmove',  e => { e.preventDefault(); bbOnTouchMove(e, canvas); }, {passive:false});
  canvas.addEventListener('touchend',   e => { e.preventDefault(); bbOnTouchEnd(e, canvas); }, {passive:false});

  bbDrawBoard();
}

function bbDrawBoard() {
  const canvas = document.getElementById('bb-canvas'); if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const cs = bbCellSize;
  ctx.fillStyle = '#181818'; ctx.fillRect(0, 0, cs*BB_COLS, cs*BB_ROWS);
  for (let r = 0; r < BB_ROWS; r++) for (let c = 0; c < BB_COLS; c++) {
    const v = bbGrid[r][c];
    if (v) {
      ctx.fillStyle = v; ctx.shadowColor = v; ctx.shadowBlur = 4;
      if (ctx.roundRect) { ctx.beginPath(); ctx.roundRect(c*cs+1.5, r*cs+1.5, cs-3, cs-3, 3); ctx.fill(); }
      else ctx.fillRect(c*cs+1.5, r*cs+1.5, cs-3, cs-3);
      ctx.shadowBlur = 0;
      ctx.fillStyle = 'rgba(255,255,255,.14)'; ctx.fillRect(c*cs+2.5, r*cs+2.5, cs-5, (cs-5)*0.35);
    } else {
      ctx.strokeStyle = 'rgba(255,255,255,.06)'; ctx.lineWidth = 0.5;
      ctx.strokeRect(c*cs+0.5, r*cs+0.5, cs-1, cs-1);
    }
  }
  // Drop preview
  if (bbDragging && bbDragging.previewR !== undefined) {
    const piece = bbDragging.piece;
    const pr = bbDragging.previewR, pc = bbDragging.previewC;
    const canPlace = bbCanPlace(piece.shape, pr, pc);
    piece.shape.forEach((row, dr) => row.forEach((v, dc) => {
      if (!v) return;
      const gr = pr + dr, gc = pc + dc;
      if (gr < 0 || gr >= BB_ROWS || gc < 0 || gc >= BB_COLS) return;
      ctx.fillStyle = canPlace ? (piece.color + '80') : 'rgba(201,79,79,0.5)';
      if (ctx.roundRect) { ctx.beginPath(); ctx.roundRect(gc*cs+1.5, gr*cs+1.5, cs-3, cs-3, 3); ctx.fill(); }
      else ctx.fillRect(gc*cs+1.5, gr*cs+1.5, cs-3, cs-3);
    }));
  }
}

// Piece mini-canvas rendering + drag setup
function bbRenderPieces() {
  const wrap = document.getElementById('bb-pieces-wrap'); if (!wrap) return;
  wrap.innerHTML = '';
  // Remove old global touch listeners
  document.removeEventListener('touchmove', bbDocTouchMove);
  document.removeEventListener('touchend', bbDocTouchEnd);

  bbPieces.forEach((piece, idx) => {
    if (piece.placed) { const ph = document.createElement('div'); ph.style.width='80px'; wrap.appendChild(ph); return; }
    const cs = Math.floor(bbCellSize * 0.85);
    const pw = piece.shape[0].length * cs, ph2 = piece.shape.length * cs;
    const cv = document.createElement('canvas');
    cv.width = pw; cv.height = ph2;
    cv.style.cursor = 'grab';
    cv.style.touchAction = 'none';
    cv.style.opacity = '1';
    cv.style.display = 'block';
    cv.style.flexShrink = '0';
    cv.style.transition = 'transform .15s, opacity .15s';
    wrap.appendChild(cv);
    const ctx2 = cv.getContext('2d');
    piece.shape.forEach((row, r) => row.forEach((v, c) => {
      if (!v) return;
      ctx2.fillStyle = piece.color; ctx2.shadowColor = piece.color; ctx2.shadowBlur = 3;
      if (ctx2.roundRect) { ctx2.beginPath(); ctx2.roundRect(c*cs+1, r*cs+1, cs-2, cs-2, 3); ctx2.fill(); }
      else ctx2.fillRect(c*cs+1, r*cs+1, cs-2, cs-2);
      ctx2.shadowBlur = 0;
      ctx2.fillStyle = 'rgba(255,255,255,.15)'; ctx2.fillRect(c*cs+2, r*cs+2, cs-4, (cs-4)*0.35);
    }));

    // Desktop drag
    cv.setAttribute('draggable', 'true');
    cv.addEventListener('dragstart', e => {
      // Track where within piece the user grabbed (in cell units)
      const rect = cv.getBoundingClientRect();
      const localX = e.clientX - rect.left, localY = e.clientY - rect.top;
      const grabCol = Math.floor(localX / cs), grabRow = Math.floor(localY / cs);
      bbDragging = { piece, idx, pieceCS: cs, grabRow, grabCol };
      cv.style.opacity = '0.5';
      e.dataTransfer.effectAllowed = 'move';
    });
    cv.addEventListener('dragend', () => { if (cv) cv.style.opacity = '1'; bbDragging = null; bbDrawBoard(); });

    // Mobile touch drag
    cv.addEventListener('touchstart', e => {
      e.preventDefault();
      const t = e.touches[0];
      const rect = cv.getBoundingClientRect();
      const localX = t.clientX - rect.left, localY = t.clientY - rect.top;
      const grabCol = Math.floor(localX / cs), grabRow = Math.floor(localY / cs);
      bbDragging = { piece, idx, pieceCS: cs, grabRow, grabCol };
      cv.style.transform = 'scale(1.15)';
      cv.style.opacity = '0.7';
      // Attach global doc listeners so we track movement outside piece canvas
      document.addEventListener('touchmove', bbDocTouchMove, {passive:false});
      document.addEventListener('touchend', bbDocTouchEnd, {passive:false});
    }, {passive:false});
  });
}

function bbDocTouchMove(e) {
  if (!bbDragging) return;
  e.preventDefault();
  const t = e.touches[0];
  const canvas = document.getElementById('bb-canvas');
  if (!canvas) return;
  const rect = canvas.getBoundingClientRect();
  const cs = bbCellSize;
  const x = t.clientX - rect.left, y = t.clientY - rect.top;
  const touchCol = Math.floor(x / cs), touchRow = Math.floor(y / cs);
  const pr = touchRow - (bbDragging.grabRow || 0);
  const pc = touchCol - (bbDragging.grabCol || 0);
  bbDragging.previewR = pr; bbDragging.previewC = pc;
  bbDrawBoard();
}

function bbDocTouchEnd(e) {
  if (!bbDragging) return;
  e.preventDefault();
  document.removeEventListener('touchmove', bbDocTouchMove);
  document.removeEventListener('touchend', bbDocTouchEnd);
  // Remove visual feedback from all piece canvases
  const wrap = document.getElementById('bb-pieces-wrap');
  if (wrap) wrap.querySelectorAll('canvas').forEach(cv => { cv.style.transform = ''; cv.style.opacity = '1'; });
  const pr = bbDragging.previewR, pc = bbDragging.previewC;
  if (pr !== undefined) {
    bbTryPlaceDirect(pr, pc);
  } else {
    bbDragging = null; bbDrawBoard();
  }
}

function bbGetGridCell(e, canvas) {
  const rect = canvas.getBoundingClientRect();
  const cs = bbCellSize;
  const x = (e.clientX !== undefined ? e.clientX : (e.touches ? e.touches[0].clientX : 0)) - rect.left;
  const y = (e.clientY !== undefined ? e.clientY : (e.touches ? e.touches[0].clientY : 0)) - rect.top;
  return { r: Math.floor(y / cs), c: Math.floor(x / cs) };
}

function bbOnDragOver(e, canvas) {
  if (!bbDragging) return;
  const { r, c } = bbGetGridCell(e, canvas);
  const pr = r - (bbDragging.grabRow || Math.floor(bbDragging.piece.shape.length / 2));
  const pc = c - (bbDragging.grabCol || Math.floor(bbDragging.piece.shape[0].length / 2));
  bbDragging.previewR = pr; bbDragging.previewC = pc;
  bbDrawBoard();
}

function bbOnTouchMove(e, canvas) {
  // handled by document-level bbDocTouchMove
}

function bbOnTouchEnd(e, canvas) {
  // handled by document-level bbDocTouchEnd
}

function bbOnDrop(e, canvas) {
  if (!bbDragging) return;
  const { r, c } = bbGetGridCell(e, canvas);
  bbTryPlace(r, c);
}

function bbOnTouchEnd(e, canvas) {
  if (!bbDragging) return;
  // Use last known position from last touchmove
  const pr = bbDragging.previewR, pc = bbDragging.previewC;
  if (pr !== undefined) {
    bbTryPlaceDirect(pr, pc);
  }
  // Reset piece visuals
  const wrap = document.getElementById('bb-pieces-wrap');
  if (wrap) wrap.querySelectorAll('canvas').forEach(cv => { cv.style.transform = ''; });
  bbDragging = null;
  bbDrawBoard();
}

function bbTryPlace(r, c) {
  if (!bbDragging) return;
  const pr = r - (bbDragging.grabRow || Math.floor(bbDragging.piece.shape.length / 2));
  const pc = c - (bbDragging.grabCol || Math.floor(bbDragging.piece.shape[0].length / 2));
  bbTryPlaceDirect(pr, pc);
}

function bbCanPlace(shape, pr, pc) {
  for (let dr = 0; dr < shape.length; dr++) for (let dc = 0; dc < shape[dr].length; dc++) {
    if (!shape[dr][dc]) continue;
    const gr = pr + dr, gc = pc + dc;
    if (gr < 0 || gr >= BB_ROWS || gc < 0 || gc >= BB_COLS || bbGrid[gr][gc]) return false;
  }
  return true;
}

function bbTryPlaceDirect(pr, pc) {
  if (!bbDragging) return;
  const piece = bbDragging.piece;
  if (!bbCanPlace(piece.shape, pr, pc)) {
    toast('❌ Не влезает!'); bbDragging = null; bbDrawBoard(); return;
  }
  // Place
  piece.shape.forEach((row, dr) => row.forEach((v, dc) => {
    if (v) bbGrid[pr + dr][pc + dc] = piece.color;
  }));
  bbDragging.piece.placed = true;
  bbDragging = null;
  SFX.play('bbPlace');

  // Count cells
  let cells = 0; piece.shape.forEach(r => r.forEach(v => { if(v) cells++; }));
  bbScore += cells;
  if (bbScore > bbHi) bbHi = saveHi("blockblast", bbScore);

  bbClearLines();
  bbDrawBoard();
  bbUpdateScore();

  // If all placed, generate new
  if (bbPieces.every(p => p.placed)) setTimeout(() => { bbGeneratePieces(); bbDrawBoard(); }, 300);
  else bbRenderPieces();
}

function bbClearLines() {
  const toClear = new Set();
  // Check rows
  for (let r = 0; r < BB_ROWS; r++) if (bbGrid[r].every(v => v)) {
    for (let c = 0; c < BB_COLS; c++) toClear.add(`${r},${c}`);
  }
  // Check cols
  for (let c = 0; c < BB_COLS; c++) {
    let full = true;
    for (let r = 0; r < BB_ROWS; r++) if (!bbGrid[r][c]) { full = false; break; }
    if (full) for (let r = 0; r < BB_ROWS; r++) toClear.add(`${r},${c}`);
  }
  if (!toClear.size) return;
  SFX.play('bbLine');
  bbScore += toClear.size * 10;
  if (bbScore > bbHi) bbHi = saveHi("blockblast", bbScore);

  const canvas = document.getElementById('bb-canvas'); if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const cs = bbCellSize;

  // Collect cell data for animation
  const cells = [];
  toClear.forEach(key => {
    const [r, c] = key.split(',').map(Number);
    cells.push({ r, c, color: bbGrid[r][c], scale: 1, alpha: 1, vy: 0 });
  });

  const startTime = performance.now();
  const DURATION = 380;

  function animFrame(now) {
    const elapsed = now - startTime;
    const t = Math.min(elapsed / DURATION, 1);
    // Easing: fast at start, smooth out
    const ease = 1 - Math.pow(1 - t, 3);

    bbDrawBoard();

    // Draw animating cells on top
    for (const cell of cells) {
      const sc = 1 - ease * 0.8; // shrink
      const alpha = 1 - ease;
      const x = cell.c * cs + cs / 2;
      const y = cell.r * cs + cs / 2 + ease * cs * 0.4; // slight drop

      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.translate(x, y);
      ctx.scale(sc, sc);
      ctx.fillStyle = cell.color;
      ctx.shadowColor = cell.color;
      ctx.shadowBlur = 8 * (1 - ease);
      if (ctx.roundRect) { ctx.beginPath(); ctx.roundRect(-cs/2 + 1.5, -cs/2 + 1.5, cs - 3, cs - 3, 3); ctx.fill(); }
      else ctx.fillRect(-cs/2 + 1.5, -cs/2 + 1.5, cs - 3, cs - 3);
      // Gleam flash at start
      if (t < 0.3) {
        ctx.fillStyle = `rgba(255,255,255,${0.6 * (1 - t / 0.3)})`;
        ctx.fillRect(-cs/2 + 1.5, -cs/2 + 1.5, cs - 3, (cs - 3) * 0.5);
      }
      ctx.restore();
    }
    ctx.globalAlpha = 1; ctx.shadowBlur = 0;

    if (t < 1) {
      requestAnimationFrame(animFrame);
    } else {
      toClear.forEach(key => { const [r, c] = key.split(',').map(Number); bbGrid[r][c] = null; });
      bbDrawBoard();
      bbUpdateScore();
    }
  }
  requestAnimationFrame(animFrame);
}

// ══════════════════════════════════════════════════════════════════
// ── 🧱 АРКАНОИД (v2.1.0) ─────────────────────────────────────────
// ══════════════════════════════════════════════════════════════════
const BR_COLS = 8, BR_BRICK_ROWS = 5;
let brRaf = null, brRunning = false, brLastTime = 0;
let brScore = 0, brHi = 0, brLives = 3, brDifficulty = 'normal';
let brW, brH, brBall, brPad, brBricks, brSpeed;
let brParticles = [];
let brWaiting = true;

const BR_DIFF = {
  easy:   { speed: 4.5, padW: 0.35 },
  normal: { speed: 5.5, padW: 0.27 },
  hard:   { speed: 7,   padW: 0.20 },
};

const BR_BRICK_COLORS = [
  ['#c94f4f','#c94f4f','#c94f4f','#c94f4f','#c94f4f','#c94f4f','#c94f4f','#c94f4f'],
  ['#e87722','#e87722','#e87722','#e87722','#e87722','#e87722','#e87722','#e87722'],
  ['#f5c518','#f5c518','#f5c518','#f5c518','#f5c518','#f5c518','#f5c518','#f5c518'],
  ['#4caf7d','#4caf7d','#4caf7d','#4caf7d','#4caf7d','#4caf7d','#4caf7d','#4caf7d'],
  ['#60cdff','#60cdff','#60cdff','#60cdff','#60cdff','#60cdff','#60cdff','#60cdff'],
];

function brInit() {
  brHi = getHi("breakout");
  const canvas = document.getElementById('br-canvas');
  const w = Math.min(window.innerWidth - 36, 360);
  canvas.width = w;
  canvas.height = Math.round(w * 1.3);
  brW = canvas.width; brH = canvas.height;
  const movePad = (clientX) => {
    const rect = canvas.getBoundingClientRect();
    const x = clientX - rect.left;
    brPad.x = Math.max(brPad.w/2, Math.min(brW - brPad.w/2, x));
    if (brWaiting) brBall.x = brPad.x;
  };
  canvas.ontouchmove = e => { e.preventDefault(); movePad(e.touches[0].clientX); };
  canvas.ontouchstart = e => { e.preventDefault(); movePad(e.touches[0].clientX); if (brWaiting && brRunning) brLaunch(); };
  canvas.onmousemove = e => movePad(e.clientX);
  canvas.onclick = () => { if (brWaiting && brRunning) brLaunch(); };
  brRestart();
}

function brRestart() {
  brStop();
  brLastTime = 0;
  brScore = 0; brLives = 3; brWaiting = true;
  const d = BR_DIFF[brDifficulty] || BR_DIFF.normal;
  brSpeed = d.speed;
  const padW = Math.round(brW * d.padW);
  brPad = { x: brW/2, w: padW, h: 10, y: brH - 28 };
  brBall = { x: brW/2, y: brPad.y - 9, r: 7, vx: 0, vy: 0, sx:1, sy:1, sqT:0, trail:[] };
  brBricks = [];
  const bw = Math.floor((brW - 16) / BR_COLS);
  const bh = Math.round(bw * 0.38);
  const startY = 30;
  for (let row = 0; row < BR_BRICK_ROWS; row++) {
    for (let col = 0; col < BR_COLS; col++) {
      brBricks.push({
        x: 8 + col * bw, y: startY + row * (bh + 4),
        w: bw - 3, h: bh,
        color: BR_BRICK_COLORS[row][col],
        alive: true, hits: row < 2 ? 2 : 1
      });
    }
  }
  brUpdateScore();
  brRunning = true;
  brRaf = requestAnimationFrame(brLoop);
}

function brLaunch() {
  if (!brWaiting) return;
  brWaiting = false;
  const angle = (Math.random() * 40 + 70) * Math.PI / 180;
  brBall.vx = Math.cos(angle) * brSpeed * (Math.random() > 0.5 ? 1 : -1);
  brBall.vy = -Math.abs(Math.sin(angle) * brSpeed);
}

function brStop() { cancelAnimationFrame(brRaf); brRaf = null; brRunning = false; }

function brLoop(ts) {
  if (!brRunning) return;
  const dt = brLastTime ? Math.min((ts - brLastTime) / 16.667, 3) : 1;
  brLastTime = ts;
  if (!brWaiting) brTick(dt);
  brDraw();
  brRaf = requestAnimationFrame(brLoop);
}

function brTick(dt) {
  const b = brBall;
  b.x += b.vx * dt; b.y += b.vy * dt;

  // Trail — храним с временной меткой
  if (!b.trail) b.trail = [];
  const now2 = performance.now();
  b.trail.push({x: b.x, y: b.y, ts: now2});
  while (b.trail.length > 0 && now2 - b.trail[0].ts > 160) b.trail.shift();

  // Squish recovery
  if (b.sqT > 0) {
    b.sqT = Math.max(0, b.sqT - dt * 0.17);
    b.sx = 1 + (b._sqTx || 0) * b.sqT;
    b.sy = 1 + (b._sqTy || 0) * b.sqT;
  } else { b.sx = 1; b.sy = 1; }

  if (b.x - b.r < 0) {
    b.x = b.r; b.vx = Math.abs(b.vx);
    b.sx = 0.84; b.sy = 1.14; b._sqTx = -0.16; b._sqTy = 0.14; b.sqT = 1;
    SFX.play('brWall');
  }
  if (b.x + b.r > brW) {
    b.x = brW - b.r; b.vx = -Math.abs(b.vx);
    b.sx = 0.84; b.sy = 1.14; b._sqTx = -0.16; b._sqTy = 0.14; b.sqT = 1;
    SFX.play('brWall');
  }
  if (b.y - b.r < 0) {
    b.y = b.r; b.vy = Math.abs(b.vy);
    b.sx = 1.14; b.sy = 0.84; b._sqTx = 0.14; b._sqTy = -0.16; b.sqT = 1;
  }
  const pl = brPad.x - brPad.w/2, pr2 = brPad.x + brPad.w/2;
  if (b.vy > 0 && b.y + b.r >= brPad.y && b.y + b.r <= brPad.y + brPad.h + 4
      && b.x >= pl - b.r && b.x <= pr2 + b.r) {
    b.y = brPad.y - b.r;
    const hit = (b.x - brPad.x) / (brPad.w / 2);
    const angle = hit * 65 * Math.PI / 180;
    const spd = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
    b.vx = Math.sin(angle) * spd;
    b.vy = -Math.cos(angle) * spd;
    b.sx = 1.16; b.sy = 0.86; b._sqTx = 0.16; b._sqTy = -0.14; b.sqT = 1;
    SFX.play('brPaddle');
  }
  let brokeCount = 0;
  for (const bk of brBricks) {
    if (!bk.alive) continue;
    if (b.x + b.r > bk.x && b.x - b.r < bk.x + bk.w &&
        b.y + b.r > bk.y && b.y - b.r < bk.y + bk.h) {
      bk.hits--;
      if (bk.hits <= 0) {
        bk.alive = false; brokeCount++;
        // Brick death particles
        if (!brParticles) brParticles = [];
        for (let i = 0; i < 8; i++) {
          const ang = Math.random() * Math.PI * 2;
          const spd2 = 1.5 + Math.random() * 2.5;
          brParticles.push({ x: bk.x + bk.w/2, y: bk.y + bk.h/2, vx: Math.cos(ang)*spd2, vy: Math.sin(ang)*spd2, life: 1, color: bk.color });
        }
        SFX.play('brBrick');
      } else {
        bk.hitTime = performance.now(); // hit flash timestamp
      }
      const overlapL = (b.x + b.r) - bk.x, overlapR = (bk.x + bk.w) - (b.x - b.r);
      const overlapT = (b.y + b.r) - bk.y, overlapB = (bk.y + bk.h) - (b.y - b.r);
      if (Math.min(overlapL, overlapR) < Math.min(overlapT, overlapB)) {
        b.vx = -b.vx;
        b.sx = 0.86; b.sy = 1.14; b._sqTx = -0.14; b._sqTy = 0.14; b.sqT = 1;
      } else {
        b.vy = -b.vy;
        b.sx = 1.14; b.sy = 0.86; b._sqTx = 0.14; b._sqTy = -0.14; b.sqT = 1;
      }
      break;
    }
  }
  if (brokeCount) { brScore += brokeCount * 10; if (brScore > brHi) brHi = saveHi("breakout", brScore); brUpdateScore(); }
  if (brBricks.every(bk => !bk.alive)) {
    brStop(); brWaiting = true;
    SFX.play('brLevelUp');
    setTimeout(() => { brRestart(); toast('🎉 Уровень пройден!'); }, 400);
    return;
  }
  if (b.y - b.r > brH) {
    brLives--;
    SFX.play('brLive');
    brUpdateScore();
    if (brLives <= 0) {
      brStop(); brRunning = false;
      brDraw(); brDrawMsg('💀 Игра окончена! Тапни чтобы снова');
      toast('🧱 Счёт: ' + brScore); return;
    }
    brWaiting = true;
    b.x = brPad.x; b.y = brPad.y - b.r - 2; b.vx = 0; b.vy = 0;
    b.trail = [];
    toast('❤️ Осталось жизней: ' + brLives);
  }
  // Update particles
  if (brParticles) {
    for (let i = brParticles.length - 1; i >= 0; i--) {
      const p2 = brParticles[i];
      p2.x += p2.vx * dt * 0.5; p2.y += p2.vy * dt * 0.5;
      p2.life -= dt * 0.003;
      if (p2.life <= 0) brParticles.splice(i, 1);
    }
  }
}

function brDraw() {
  const canvas = document.getElementById('br-canvas'); if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const accent = getAccent();
  ctx.fillStyle = '#0d0d0d'; ctx.fillRect(0, 0, brW, brH);

  // Bricks
  for (const bk of brBricks) {
    if (!bk.alive) continue;
    const flashAge = bk.hitTime ? performance.now() - bk.hitTime : Infinity;
    const flashT = Math.max(0, 1 - flashAge / 120);
    ctx.globalAlpha = bk.hits > 1 ? 1 : 0.82;
    ctx.fillStyle = flashT > 0 ? `rgba(255,255,255,${flashT})` : bk.color;
    ctx.shadowColor = bk.color; ctx.shadowBlur = bk.hits > 1 ? 8 : 3;
    if (ctx.roundRect) { ctx.beginPath(); ctx.roundRect(bk.x, bk.y, bk.w, bk.h, 3); ctx.fill(); }
    else ctx.fillRect(bk.x, bk.y, bk.w, bk.h);
    ctx.shadowBlur = 0;
    ctx.fillStyle = 'rgba(255,255,255,0.18)';
    ctx.fillRect(bk.x + 2, bk.y + 2, bk.w - 4, Math.floor((bk.h - 4) * 0.4));
    ctx.globalAlpha = 1;
  }

  // Particles
  if (brParticles) {
    for (const p2 of brParticles) {
      ctx.globalAlpha = Math.max(0, p2.life * 0.9);
      ctx.fillStyle = p2.color;
      ctx.shadowColor = p2.color; ctx.shadowBlur = 4;
      const sz = 3 * p2.life;
      ctx.fillRect(p2.x - sz/2, p2.y - sz/2, sz, sz);
    }
    ctx.shadowBlur = 0; ctx.globalAlpha = 1;
  }

  // Paddle
  const grad = ctx.createLinearGradient(brPad.x - brPad.w/2, 0, brPad.x + brPad.w/2, 0);
  grad.addColorStop(0, 'rgba(255,255,255,.15)'); grad.addColorStop(.5, accent); grad.addColorStop(1, 'rgba(255,255,255,.15)');
  ctx.fillStyle = grad; ctx.shadowColor = accent; ctx.shadowBlur = 10;
  if (ctx.roundRect) { ctx.beginPath(); ctx.roundRect(brPad.x - brPad.w/2, brPad.y, brPad.w, brPad.h, 6); ctx.fill(); }
  else ctx.fillRect(brPad.x - brPad.w/2, brPad.y, brPad.w, brPad.h);
  ctx.shadowBlur = 0;

  // Ball trail — по возрасту точки
  const bt = brBall.trail || [];
  const brTrailDur = 160;
  const nowBr = performance.now();
  for (let i = 0; i < bt.length; i++) {
    const age = nowBr - bt[i].ts;
    const t = Math.max(0, 1 - age / brTrailDur);
    const alpha = t * t * 0.5;
    const r = brBall.r * (0.2 + t * 0.6);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = '#fff';
    ctx.shadowColor = accent; ctx.shadowBlur = 6;
    ctx.beginPath(); ctx.arc(bt[i].x, bt[i].y, r, 0, Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha = 1; ctx.shadowBlur = 0;

  // Ball with squish
  const sx = brBall.sx || 1, sy = brBall.sy || 1;
  ctx.save();
  ctx.translate(brBall.x, brBall.y);
  ctx.scale(sx, sy);
  ctx.fillStyle = '#fff'; ctx.shadowColor = accent; ctx.shadowBlur = 14;
  ctx.beginPath(); ctx.arc(0, 0, brBall.r, 0, Math.PI*2); ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();

  if (brWaiting && brRunning) {
    ctx.fillStyle = 'rgba(0,0,0,.55)'; ctx.fillRect(0, brH/2 - 20, brW, 40);
    ctx.fillStyle = '#f0ede8'; ctx.font = 'bold 13px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('Тапни для запуска 🏓', brW/2, brH/2 + 6); ctx.textAlign = 'left';
  }
}

function brDrawMsg(msg) {
  const canvas = document.getElementById('br-canvas'); if (!canvas) return;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = 'rgba(0,0,0,.65)'; ctx.fillRect(0, brH/2-30, brW, 60);
  ctx.fillStyle = '#f0ede8'; ctx.font = 'bold 14px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText(msg, brW/2, brH/2 + 6); ctx.textAlign = 'left';
  canvas.ontouchstart = () => brRestart();
  canvas.onclick = () => brRestart();
}

function brUpdateScore() {
  const el = document.getElementById('br-score-label'); if (!el) return;
  const hearts = '❤️'.repeat(Math.max(0,brLives)) + '🖤'.repeat(Math.max(0, 3 - brLives));
  el.textContent = 'Счёт: ' + brScore + ' • Рекорд: ' + brHi + ' • ' + hearts;
}


// ══════════════════════════════════════════════════════════════════
// ── 🫧 ПУЗЫРИ (v2.2.0) ───────────────────────────────────────────
// ══════════════════════════════════════════════════════════════════
const BUB_COLORS = ['#e87722','#00e5ff','#a78bfa','#4caf7d','#f5c518','#f472b6','#60cdff','#c94f4f'];
let bubRaf = null, bubRunning = false, bubLastTime = 0;
let bubScore = 0, bubHi = 0, bubLives = 3;
let bubW, bubH, bubBubbles = [], bubSpawnTimer = 0, bubDifficulty = 'normal', bubLevel = 1;
let bubLevelTimer = 0, bubCombo = 0, bubComboTimer = 0;

const BUB_DIFF = {
  easy:   { spawnInterval: 2200, lifespan: 3500, minR: 26, maxR: 42, maxBubs: 8  },
  normal: { spawnInterval: 1500, lifespan: 2800, minR: 22, maxR: 36, maxBubs: 12 },
  hard:   { spawnInterval: 900,  lifespan: 2000, minR: 16, maxR: 30, maxBubs: 16 },
};

function bubInit() {
  bubHi = getHi("bubbles");
  const canvas = document.getElementById('bub-canvas');
  const w = Math.min(window.innerWidth - 36, 360);
  canvas.width = w;
  canvas.height = Math.round(w * 1.2);
  bubW = canvas.width; bubH = canvas.height;
  const handleTap = (clientX, clientY) => {
    const rect = canvas.getBoundingClientRect();
    const tx = clientX - rect.left, ty = clientY - rect.top;
    let popped = false;
    for (let i = bubBubbles.length - 1; i >= 0; i--) {
      const b = bubBubbles[i];
      if (b.popped) continue;
      const dx = tx - b.x, dy = ty - b.y;
      if (dx*dx + dy*dy <= (b.r + 8)*(b.r + 8)) {
        b.popped = true; b.popTime = 0;
        bubCombo++; bubComboTimer = 1500;
        SFX.play('bubPop'); if(bubCombo>=3) SFX.play('bubCombo');
        const pts = Math.round(10 * bubCombo * (1 + bubLevel * 0.1));
        bubScore += pts; if (bubScore > bubHi) bubHi = saveHi("bubbles", bubScore);
        bubUpdateScore(); popped = true; break;
      }
    }
    if (!popped && bubRunning) bubCombo = 0;
  };
  canvas.ontouchstart = e => { e.preventDefault(); const t = e.touches[0]; handleTap(t.clientX, t.clientY); };
  canvas.onclick = e => handleTap(e.clientX, e.clientY);
  bubRestart();
}

function bubRestart() {
  bubStop();
  bubLastTime = 0; bubBubbles = []; bubSpawnTimer = 0;
  bubScore = 0; bubLives = 3; bubLevel = 1; bubLevelTimer = 0;
  bubCombo = 0; bubComboTimer = 0;
  bubUpdateScore(); bubRunning = true;
  bubRaf = requestAnimationFrame(bubLoop);
}

function bubStop() { cancelAnimationFrame(bubRaf); bubRaf = null; bubRunning = false; }

function bubLoop(ts) {
  if (!bubRunning) return;
  const dt = bubLastTime ? Math.min(ts - bubLastTime, 50) : 16;
  bubLastTime = ts;
  bubTick(dt); bubDraw();
  bubRaf = requestAnimationFrame(bubLoop);
}

function bubTick(dt) {
  const d = BUB_DIFF[bubDifficulty] || BUB_DIFF.normal;
  bubLevelTimer += dt; if (bubLevelTimer >= 25000) { bubLevelTimer = 0; bubLevel++; }
  if (bubComboTimer > 0) { bubComboTimer -= dt; if (bubComboTimer <= 0) bubCombo = 0; }
  const interval = Math.max(400, d.spawnInterval - bubLevel * 60);
  bubSpawnTimer += dt;
  if (bubSpawnTimer >= interval && bubBubbles.filter(b=>!b.popped).length < d.maxBubs) {
    bubSpawnTimer = 0;
    const r = d.minR + Math.random() * (d.maxR - d.minR);
    const lifespan = Math.max(900, d.lifespan - bubLevel * 80 + (Math.random()-0.5)*400);
    bubBubbles.push({
      x: r*1.5 + Math.random()*(bubW - r*3), y: r*1.5 + Math.random()*(bubH - r*3 - 40),
      r, color: BUB_COLORS[Math.floor(Math.random()*BUB_COLORS.length)],
      age: 0, lifespan, popped: false, popTime: -1,
      vy: (Math.random()-0.5)*0.25, vx: (Math.random()-0.5)*0.18,
      spawnT: 0,  // 0→1 появление
      wobble: Math.random() * Math.PI * 2, // фаза покачивания
      wobbleSpeed: 0.003 + Math.random() * 0.002,
    });
  }
  for (let i = bubBubbles.length-1; i >= 0; i--) {
    const b = bubBubbles[i];
    if (b.popped) { b.popTime += dt; if (b.popTime > 520) bubBubbles.splice(i,1); continue; }
    b.age += dt;
    b.spawnT = Math.min(1, (b.spawnT || 0) + dt * 0.006);
    b.wobble = (b.wobble || 0) + (b.wobbleSpeed || 0.003) * dt;
    b.x += b.vx * dt * 0.06; b.y += b.vy * dt * 0.06;
    if (b.x-b.r < 0) { b.x=b.r; b.vx=Math.abs(b.vx); }
    if (b.x+b.r > bubW) { b.x=bubW-b.r; b.vx=-Math.abs(b.vx); }
    if (b.y-b.r < 0) { b.y=b.r; b.vy=Math.abs(b.vy); }
    if (b.y+b.r > bubH-40) { b.y=bubH-40-b.r; b.vy=-Math.abs(b.vy); }
    if (b.age >= b.lifespan) {
      bubBubbles.splice(i,1); SFX.play('bubMiss'); bubLives--; bubCombo = 0; bubUpdateScore();
      if (bubLives <= 0) {
        bubStop(); bubRunning = false; bubDraw();
        const canvas = document.getElementById('bub-canvas'); if (!canvas) return;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle='rgba(0,0,0,.7)'; ctx.fillRect(0,bubH/2-35,bubW,70);
        ctx.fillStyle='#f0ede8'; ctx.font='bold 14px sans-serif'; ctx.textAlign='center';
        ctx.fillText('💀 Игра окончена! Тапни чтобы снова',bubW/2,bubH/2+6); ctx.textAlign='left';
        toast('🫧 Счёт: '+bubScore);
        canvas.ontouchstart = e => { e.preventDefault(); canvas.ontouchstart=null; canvas.onclick=null; bubRestart(); };
        canvas.onclick = () => { canvas.ontouchstart=null; canvas.onclick=null; bubRestart(); };
        return;
      }
    }
  }
}

function bubDraw() {
  const canvas = document.getElementById('bub-canvas'); if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const accent = getAccent();
  ctx.fillStyle='#0d0d0d'; ctx.fillRect(0,0,bubW,bubH);

  for (const b of bubBubbles) {
    // ── Анимация лопанья ──
    if (b.popped) {
      const t = Math.min(b.popTime / 520, 1);
      const ease = 1 - Math.pow(1 - t, 2);
      // Расходящееся кольцо
      const ringR = b.r * (1 + ease * 1.3);
      ctx.globalAlpha = (1 - ease) * 0.9;
      ctx.strokeStyle = b.color;
      ctx.lineWidth = 2.8 * (1 - ease) + 0.5;
      ctx.shadowColor = b.color; ctx.shadowBlur = 12 * (1 - ease);
      ctx.beginPath(); ctx.arc(b.x, b.y, ringR, 0, Math.PI * 2); ctx.stroke();
      ctx.shadowBlur = 0;
      // Брызги
      for (let i = 0; i < 8; i++) {
        const ang = (i / 8) * Math.PI * 2 + (b.wobble || 0);
        const dist = b.r * (0.3 + ease * 1.6);
        const dropR = Math.max(0.5, (1 - ease) * b.r * 0.26 + 1);
        ctx.globalAlpha = Math.max(0, (1 - ease) * 0.9);
        ctx.fillStyle = b.color;
        ctx.shadowColor = b.color; ctx.shadowBlur = 4;
        ctx.beginPath(); ctx.arc(b.x + Math.cos(ang)*dist, b.y + Math.sin(ang)*dist, dropR, 0, Math.PI*2); ctx.fill();
      }
      ctx.shadowBlur = 0; ctx.globalAlpha = 1;
      continue;
    }

    // ── Появление с упругим отскоком ──
    const spawnT = Math.min(b.spawnT || 0, 1);
    let spawnScale;
    if (spawnT < 1) {
      const c2 = (2 * Math.PI) / 3;
      spawnScale = spawnT === 0 ? 0 : Math.pow(2, -8 * spawnT) * Math.sin((spawnT * 8 - 0.75) * c2) + 1;
    } else { spawnScale = 1; }

    // ── Прозрачность появления/исчезания ──
    const ageFrac = b.age / b.lifespan;
    const fadeIn = Math.min(1, b.age / 180);
    const fadeOut = ageFrac > 0.78 ? 1 - Math.pow((ageFrac - 0.78) / 0.22, 2) * 0.3 : 1;
    const alpha = fadeIn * fadeOut;

    // ── Покачивание ──
    const wob = Math.sin(b.wobble || 0) * 0.035;
    const drawR = b.r * spawnScale;

    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.scale(1 + wob, 1 - wob);
    ctx.globalAlpha = Math.max(0.04, alpha);

    // Тело
    ctx.shadowColor = b.color; ctx.shadowBlur = drawR * 0.5;
    ctx.beginPath(); ctx.arc(0, 0, drawR, 0, Math.PI*2);
    const grad = ctx.createRadialGradient(-drawR*0.28, -drawR*0.3, drawR*0.04, 0, 0, drawR);
    grad.addColorStop(0, b.color + '55');
    grad.addColorStop(0.55, b.color + '18');
    grad.addColorStop(1, b.color + '88');
    ctx.fillStyle = grad; ctx.fill(); ctx.shadowBlur = 0;
    // Обводка
    ctx.strokeStyle = b.color + 'cc'; ctx.lineWidth = 1.8; ctx.stroke();
    // Основной блик
    ctx.fillStyle = 'rgba(255,255,255,0.40)';
    ctx.beginPath(); ctx.ellipse(-drawR*0.25, -drawR*0.28, drawR*0.26, drawR*0.13, -Math.PI/4, 0, Math.PI*2); ctx.fill();
    // Вторичный блик
    ctx.fillStyle = 'rgba(255,255,255,0.14)';
    ctx.beginPath(); ctx.ellipse(drawR*0.2, drawR*0.25, drawR*0.1, drawR*0.055, Math.PI/5, 0, Math.PI*2); ctx.fill();

    ctx.restore();

    // Пульсирующее предупреждение
    if (ageFrac > 0.65) {
      const warn = (ageFrac - 0.65) / 0.35;
      const pulse = 0.5 + 0.5 * Math.sin(b.age * 0.018);
      ctx.globalAlpha = warn * pulse * 0.8;
      ctx.strokeStyle = `rgba(255,80,80,1)`;
      ctx.lineWidth = 1.5 + warn * 2;
      ctx.shadowColor = 'rgba(255,60,60,0.8)'; ctx.shadowBlur = 8 * warn;
      ctx.beginPath(); ctx.arc(b.x, b.y, drawR + 4 + warn * 3, 0, Math.PI*2); ctx.stroke();
      ctx.shadowBlur = 0;
    }
    ctx.globalAlpha = 1;
  }

  // HUD
  ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(0,bubH-38,bubW,38);
  ctx.font=`700 12px "JetBrains Mono",monospace`;
  ctx.fillStyle=accent; ctx.textAlign='left'; ctx.fillText('Lv'+bubLevel,8,bubH-12);
  if (bubCombo>1) {
    ctx.fillStyle='#f5c518'; ctx.textAlign='center';
    ctx.fillText('x'+bubCombo+' КОМБО!',bubW/2,bubH-12);
  }
  const hearts='❤️'.repeat(Math.max(0,bubLives))+'🖤'.repeat(Math.max(0,3-bubLives));
  ctx.fillStyle='rgba(255,255,255,0.75)'; ctx.textAlign='right';
  ctx.fillText(hearts,bubW-6,bubH-12); ctx.textAlign='left';
}

function bubUpdateScore() {
  const el=document.getElementById('bub-score-label'); if(!el) return;
  const hearts='❤️'.repeat(Math.max(0,bubLives))+'🖤'.repeat(Math.max(0,3-bubLives));
  el.textContent='Счёт: '+bubScore+' • Рекорд: '+bubHi+' • '+hearts;
}

// ══ СЕКРЕТНЫЕ ЭФФЕКТЫ ══

// ── 🟩 МАТРИЦА ──
let _matrixRaf=null,_matrixRunning=false;
function matrixStart(){
  const c=document.getElementById('matrix-canvas');
  if(!c)return;
  _matrixRunning=true;
  c.width=window.innerWidth;c.height=window.innerHeight;
  c.classList.add('active');
  const ctx=c.getContext('2d');
  const cols=Math.ceil(c.width/18); // чуть реже столбцов
  const drops=Array(cols).fill(1);
  const chars='アイウエオカキクケコ01アBCabcサシスセソ9EFタチツテトナ';
  const accent=getAccent();
  let _lastMatT=0;
  function draw(t){
    if(!_matrixRunning)return;
    if(t-_lastMatT<38){_matrixRaf=requestAnimationFrame(draw);return;} // ~26fps
    _lastMatT=t;
    ctx.fillStyle='rgba(0,0,0,.1)';ctx.fillRect(0,0,c.width,c.height);
    ctx.font='13px monospace';
    drops.forEach((y,i)=>{
      const ch=chars[Math.floor(Math.random()*chars.length)];
      ctx.fillStyle=i%8===0?'#fff':accent;
      ctx.fillText(ch,i*18,y*16);
      if(y*16>c.height&&Math.random()>.97)drops[i]=0;
      drops[i]++;
    });
    _matrixRaf=requestAnimationFrame(draw);
  }
  cancelAnimationFrame(_matrixRaf);
  requestAnimationFrame(draw);
}
function matrixStop(){
  _matrixRunning=false;cancelAnimationFrame(_matrixRaf);
  const c=document.getElementById('matrix-canvas');
  if(c){c.classList.remove('active');setTimeout(()=>{const ctx=c.getContext('2d');ctx.clearRect(0,0,c.width,c.height);},500);}
}

// ── ❄️ СНЕГ ──
let _snowRaf=null,_snowRunning=false,_snowFlakes=[];
function snowStart(){
  const c=document.getElementById('snow-canvas');
  if(!c)return;
  _snowRunning=true;c.style.display='';
  // Сохраняем
  const sec=loadSecret();sec.snow=true;saveSecret(sec);
  c.width=window.innerWidth;c.height=window.innerHeight;
  // Оптимизация: 50 снежинок вместо 80, с throttle на 30fps
  const flakeCount=Math.min(50,Math.round(window.innerWidth/8));
  _snowFlakes=Array.from({length:flakeCount},()=>({
    x:Math.random()*c.width,y:Math.random()*c.height,
    r:.8+Math.random()*2.5,vy:.3+Math.random()*.9,vx:(Math.random()-.5)*.4,
    op:.35+Math.random()*.5
  }));
  const ctx=c.getContext('2d');
  let _lastSnowT=0;
  function draw(t){
    if(!_snowRunning)return;
    // Throttle: ~30fps максимум
    if(t-_lastSnowT<28){_snowRaf=requestAnimationFrame(draw);return;}
    _lastSnowT=t;
    ctx.clearRect(0,0,c.width,c.height);
    ctx.fillStyle='rgba(255,255,255,0.7)';
    ctx.beginPath();
    _snowFlakes.forEach(f=>{
      ctx.moveTo(f.x+f.r,f.y);
      ctx.arc(f.x,f.y,f.r,0,Math.PI*2);
      f.y+=f.vy;f.x+=f.vx;
      if(f.y>c.height){f.y=-5;f.x=Math.random()*c.width;}
      if(f.x<0)f.x=c.width;if(f.x>c.width)f.x=0;
    });
    ctx.fill();
    _snowRaf=requestAnimationFrame(draw);
  }
  cancelAnimationFrame(_snowRaf);requestAnimationFrame(draw);
}
function snowStop(){
  _snowRunning=false;cancelAnimationFrame(_snowRaf);
  const c=document.getElementById('snow-canvas');
  if(c)c.style.display='none';
  const sec=loadSecret();delete sec.snow;saveSecret(sec);
}

// ── 🕺 ДИСКО — чистый RGB без смены тем ──
// _discoActive объявлен в начале файла
function discoApplyIntensity(val){
  // val: 0..100, default 100
  const v = Math.max(0, Math.min(100, val||100));
  document.documentElement.style.setProperty('--disco-intensity', (v/100).toFixed(2));
}
function discoStart(){
  _discoActive=true;
  document.body.classList.add('disco-mode');
  const sec=loadSecret();sec.disco=true;saveSecret(sec);
  discoApplyIntensity(sec.discoIntensity!=null?sec.discoIntensity:100);
}
function discoStop(){
  _discoActive=false;
  document.body.classList.remove('disco-mode');
  const sec=loadSecret();delete sec.disco;saveSecret(sec);
}

// ══════════════════════════════════════════════════════════════════
// ── 🐦 ФЛАППИ ПТИЦА (v2.6.0) ─────────────────────────────────────
// ══════════════════════════════════════════════════════════════════
let flappyRaf=null,flappyRunning=false,flappyStarted=false;
let flappyW=0,flappyH=0,flappyScore=0,flappyHi=0;
let flappyBird={x:0,y:0,vy:0,r:14};
const FLAPPY_GRAVITY=0.38,FLAPPY_JUMP=-7.2,FLAPPY_PIPE_W=52,FLAPPY_GAP=140,FLAPPY_SPEED=2.4;
let flappyPipes=[];
let flappyFrames=0;

function flappyInit(){
  flappyHi=getHi('flappy');
  const canvas=document.getElementById('flappy-canvas');
  flappyW=Math.min(window.innerWidth-36,360);
  flappyH=Math.round(flappyW*1.45);
  canvas.width=flappyW; canvas.height=flappyH;
  canvas.ontouchstart=e=>{e.preventDefault();flappyFlap();};
  canvas.onclick=flappyFlap;
  document.addEventListener('keydown',flappyKeyDown);
  flappyRestart();
}
function flappyKeyDown(e){if(e.code==='Space'||e.code==='ArrowUp'){e.preventDefault();flappyFlap();}}
function flappyStop(){
  flappyRunning=false;cancelAnimationFrame(flappyRaf);
  document.removeEventListener('keydown',flappyKeyDown);
}
function flappyFlap(){
  if(!flappyStarted){flappyStarted=true;}
  flappyBird.vy=FLAPPY_JUMP;
  SFX.play('pongHit');
}
function flappyRestart(){
  flappyScore=0; flappyStarted=false;
  flappyBird={x:flappyW*0.28,y:flappyH*0.45,vy:0,r:14};
  flappyPipes=[]; flappyFrames=0;
  flappyRunning=true;
  cancelAnimationFrame(flappyRaf);
  flappyRaf=requestAnimationFrame(flappyLoop);
  flappyUpdateScore();
}
function flappySpawnPipe(){
  const minY=80,maxY=flappyH-FLAPPY_GAP-80;
  const topH=minY+Math.random()*(maxY-minY);
  flappyPipes.push({x:flappyW,topH,passed:false});
}
function flappyLoop(){
  if(!flappyRunning)return;
  const canvas=document.getElementById('flappy-canvas');
  if(!canvas){flappyRunning=false;return;}
  if(flappyStarted){
    flappyBird.vy+=FLAPPY_GRAVITY;
    flappyBird.y+=flappyBird.vy;
    flappyFrames++;
    if(flappyFrames%90===0)flappySpawnPipe();
    for(let p of flappyPipes){p.x-=FLAPPY_SPEED;}
    flappyPipes=flappyPipes.filter(p=>p.x>-FLAPPY_PIPE_W-10);
    // Score
    for(let p of flappyPipes){
      if(!p.passed&&p.x+FLAPPY_PIPE_W<flappyBird.x){p.passed=true;flappyScore++;flappyUpdateScore();SFX.play('pongScore');}
    }
    // Collision
    const b=flappyBird;
    if(b.y+b.r>flappyH||b.y-b.r<0){flappyDie();return;}
    for(let p of flappyPipes){
      const inX=b.x+b.r>p.x&&b.x-b.r<p.x+FLAPPY_PIPE_W;
      if(inX&&(b.y-b.r<p.topH||b.y+b.r>p.topH+FLAPPY_GAP)){flappyDie();return;}
    }
  }
  flappyDraw(canvas);
  flappyRaf=requestAnimationFrame(flappyLoop);
}
function flappyDie(){
  flappyRunning=false;
  if(flappyScore>flappyHi)flappyHi=saveHi('flappy',flappyScore);
  flappyUpdateScore();
  const canvas=document.getElementById('flappy-canvas');
  flappyDraw(canvas);
  const ctx=canvas.getContext('2d');
  ctx.fillStyle='rgba(0,0,0,.6)';ctx.fillRect(0,flappyH/2-44,flappyW,88);
  ctx.fillStyle='#f0ede8';ctx.font='bold 16px sans-serif';ctx.textAlign='center';
  ctx.fillText('💥 Игра окончена!',flappyW/2,flappyH/2-12);
  ctx.fillText('Тапни чтобы снова',flappyW/2,flappyH/2+16);
  canvas.onclick=()=>{canvas.onclick=null;canvas.ontouchstart=e=>{e.preventDefault();flappyFlap();};canvas.onclick=flappyFlap;flappyRestart();};
  canvas.ontouchstart=e=>{e.preventDefault();canvas.ontouchstart=null;canvas.onclick=null;canvas.onclick=flappyFlap;canvas.ontouchstart=e2=>{e2.preventDefault();flappyFlap();};flappyRestart();};
}
function flappyDraw(canvas){
  const ctx=canvas.getContext('2d');
  const accent=getAccent();
  // Sky
  const skyGrad=ctx.createLinearGradient(0,0,0,flappyH);
  skyGrad.addColorStop(0,'#0d1b2a');skyGrad.addColorStop(1,'#162032');
  ctx.fillStyle=skyGrad;ctx.fillRect(0,0,flappyW,flappyH);
  // Ground
  ctx.fillStyle='#2a1f0e';ctx.fillRect(0,flappyH-24,flappyW,24);
  ctx.fillStyle='#3d2e14';ctx.fillRect(0,flappyH-24,flappyW,4);
  // Pipes
  for(const p of flappyPipes){
    const grad=ctx.createLinearGradient(p.x,0,p.x+FLAPPY_PIPE_W,0);
    grad.addColorStop(0,'#2d6a2d');grad.addColorStop(0.5,'#3e9e3e');grad.addColorStop(1,'#2d6a2d');
    ctx.fillStyle=grad;
    ctx.fillRect(p.x,0,FLAPPY_PIPE_W,p.topH);
    ctx.fillRect(p.x,p.topH+FLAPPY_GAP,FLAPPY_PIPE_W,flappyH-p.topH-FLAPPY_GAP);
    // Pipe caps
    ctx.fillStyle='#4ab84a';
    ctx.fillRect(p.x-4,p.topH-18,FLAPPY_PIPE_W+8,18);
    ctx.fillRect(p.x-4,p.topH+FLAPPY_GAP,FLAPPY_PIPE_W+8,18);
  }
  // Bird
  const b=flappyBird;
  const angle=Math.min(Math.PI/4,Math.max(-Math.PI/5,b.vy*0.05));
  ctx.save();ctx.translate(b.x,b.y);ctx.rotate(angle);
  // Body
  ctx.shadowColor=accent;ctx.shadowBlur=12;
  ctx.fillStyle=accent;ctx.beginPath();ctx.ellipse(0,0,b.r,b.r*0.85,0,0,Math.PI*2);ctx.fill();
  // Eye
  ctx.shadowBlur=0;ctx.fillStyle='#fff';ctx.beginPath();ctx.arc(b.r*0.4,-b.r*0.2,b.r*0.32,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#222';ctx.beginPath();ctx.arc(b.r*0.5,-b.r*0.15,b.r*0.15,0,Math.PI*2);ctx.fill();
  // Wing
  ctx.fillStyle=accent+'bb';ctx.beginPath();ctx.ellipse(-b.r*0.2,b.r*0.1,b.r*0.55,b.r*0.3,flappyStarted?Math.sin(flappyFrames*0.3)*0.4:0,0,Math.PI*2);ctx.fill();
  // Beak
  ctx.fillStyle='#f5a623';ctx.beginPath();ctx.moveTo(b.r*0.7,0);ctx.lineTo(b.r*1.3,b.r*0.15);ctx.lineTo(b.r*0.7,b.r*0.3);ctx.closePath();ctx.fill();
  ctx.restore();
  // Score HUD
  ctx.fillStyle='rgba(0,0,0,.45)';ctx.fillRect(0,0,flappyW,38);
  ctx.fillStyle='#f0ede8';ctx.font='bold 20px sans-serif';ctx.textAlign='center';
  ctx.fillText(flappyScore,flappyW/2,26);
  if(!flappyStarted){
    ctx.fillStyle='rgba(0,0,0,.5)';ctx.fillRect(0,flappyH/2-30,flappyW,60);
    ctx.fillStyle='#f0ede8';ctx.font='bold 15px sans-serif';ctx.textAlign='center';
    ctx.fillText('🐦 Тапни чтобы начать!',flappyW/2,flappyH/2+7);
  }
}
function flappyUpdateScore(){
  const el=document.getElementById('flappy-score-label');if(!el)return;
  el.textContent='Счёт: '+flappyScore+' • Рекорд: '+flappyHi;
}

// ══════════════════════════════════════════════════════════════════
// ── 🔢 2048 (v2.6.0) ─────────────────────────────────────────────
// ══════════════════════════════════════════════════════════════════
const G2048_COLORS={0:'#1f1f1f',2:'#3a3a3a',4:'#4a3820',8:'#7c4010',16:'#a04a10',32:'#c45a0a',
  64:'#e07020',128:'#d4a020',256:'#c8b030',512:'#b0c040',1024:'#60b060',2048:'#30a030'};
const G2048_TC={0:'#555',2:'#ccc',4:'#ddb',8:'#fff',16:'#fff',32:'#fff',64:'#fff',
  128:'#fff',256:'#fff',512:'#fff',1024:'#fff',2048:'#fff'};
let g2048Grid=[],g2048Score=0,g2048Hi=0,g2048Over=false;
let g2048SwX=0,g2048SwY=0;

function g2048Init(){
  g2048Hi=getHi('2048');
  g2048Restart();
  const board=document.getElementById('g2048-board');
  board.ontouchstart=e=>{e.preventDefault();g2048SwX=e.touches[0].clientX;g2048SwY=e.touches[0].clientY;};
  board.ontouchend=e=>{
    e.preventDefault();
    const dx=e.changedTouches[0].clientX-g2048SwX,dy=e.changedTouches[0].clientY-g2048SwY;
    if(Math.abs(dx)<20&&Math.abs(dy)<20)return;
    if(Math.abs(dx)>Math.abs(dy))g2048Move(dx>0?'right':'left');
    else g2048Move(dy>0?'down':'up');
  };
  document.addEventListener('keydown',g2048Key);
}
function g2048Key(e){
  const map={'ArrowLeft':'left','ArrowRight':'right','ArrowUp':'up','ArrowDown':'down'};
  if(map[e.key]){e.preventDefault();g2048Move(map[e.key]);}
}
function g2048Stop(){document.removeEventListener('keydown',g2048Key);}
function g2048Restart(){
  g2048Grid=Array(4).fill(null).map(()=>Array(4).fill(0));
  g2048Score=0;g2048Over=false;
  g2048Spawn();g2048Spawn();
  g2048Render();g2048UpdateScore();
}
function g2048Spawn(){
  const empty=[];
  for(let r=0;r<4;r++)for(let c=0;c<4;c++)if(g2048Grid[r][c]===0)empty.push([r,c]);
  if(!empty.length)return;
  const [r,c]=empty[Math.floor(Math.random()*empty.length)];
  g2048Grid[r][c]=Math.random()<0.9?2:4;
}
function g2048Slide(row){
  let a=row.filter(v=>v);
  for(let i=0;i<a.length-1;i++){if(a[i]===a[i+1]){a[i]*=2;g2048Score+=a[i];a.splice(i+1,1);i++;}}
  while(a.length<4)a.push(0);
  return a;
}
function g2048Move(dir){
  if(g2048Over)return;
  let changed=false;
  const prev=g2048Grid.map(r=>[...r]);
  if(dir==='left'){for(let r=0;r<4;r++){const n=g2048Slide(g2048Grid[r]);if(n.join()!==g2048Grid[r].join()){g2048Grid[r]=n;changed=true;}}}
  else if(dir==='right'){for(let r=0;r<4;r++){const n=g2048Slide([...g2048Grid[r]].reverse()).reverse();if(n.join()!==g2048Grid[r].join()){g2048Grid[r]=n;changed=true;}}}
  else if(dir==='up'){for(let c=0;c<4;c++){const col=[0,1,2,3].map(r=>g2048Grid[r][c]);const n=g2048Slide(col);n.forEach((v,r)=>{if(v!==g2048Grid[r][c]){g2048Grid[r][c]=v;changed=true;}});}}
  else if(dir==='down'){for(let c=0;c<4;c++){const col=[0,1,2,3].map(r=>g2048Grid[r][c]);const n=g2048Slide([...col].reverse()).reverse();n.forEach((v,r)=>{if(v!==g2048Grid[r][c]){g2048Grid[r][c]=v;changed=true;}});}}
  if(changed){
    if(g2048Score>g2048Hi)g2048Hi=saveHi('2048',g2048Score);
    g2048Spawn();g2048Render();g2048UpdateScore();SFX.play('pongHit');
    // Check game over
    const hasMoves=g2048Grid.some((row,r)=>row.some((v,c)=>{
      if(v===0)return true;
      if(c<3&&v===g2048Grid[r][c+1])return true;
      if(r<3&&v===g2048Grid[r+1][c])return true;
      return false;
    }));
    if(!hasMoves){g2048Over=true;toast('🔢 Игра окончена! '+g2048Score+' очков');}
  }
}
function g2048Render(){
  const board=document.getElementById('g2048-board');if(!board)return;
  board.innerHTML='';
  const cellSize=Math.floor((Math.min(300,window.innerWidth*0.85)-3*8)/4);
  for(let r=0;r<4;r++)for(let c=0;c<4;c++){
    const v=g2048Grid[r][c];
    const cell=document.createElement('div');
    const bg=G2048_COLORS[Math.min(v,2048)]||'#208020';
    const tc=G2048_TC[Math.min(v,2048)]||'#fff';
    const fs=v<100?22:v<1000?17:13;
    cell.style.cssText=`width:${cellSize}px;height:${cellSize}px;border-radius:8px;background:${bg};
      display:flex;align-items:center;justify-content:center;
      font-family:'JetBrains Mono',monospace;font-size:${fs}px;font-weight:800;color:${tc};
      transition:background .12s;box-shadow:0 2px 8px rgba(0,0,0,.3);`;
    cell.textContent=v||'';
    board.appendChild(cell);
  }
}
function g2048UpdateScore(){
  const el=document.getElementById('g2048-score-label');if(!el)return;
  el.textContent='Счёт: '+g2048Score+' • Рекорд: '+g2048Hi;
}
</script>